<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Curtis&apos; Spot</title>
        <link>https://lkangd.com/feed.xml</link>
        <description>Front-end Engineer. Bloggin about life, tech &amp; everything I love.</description>
        <lastBuildDate>Wed, 11 Sep 2019 06:28:17 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>https://github.com/nuxt-community/feed-module</generator>
        <copyright>All rights reserved 2019, Curtis Liong</copyright>
        <category>Curtis&apos; Spot</category>
        <item>
            <title><![CDATA[为什么React元素有一个$$typeof属性？]]></title>
            <link>/post/why-do-react-elements-have-typeof-property-zh</link>
            <guid>/post/why-do-react-elements-have-typeof-property-zh</guid>
            <description><![CDATA[有些部分是关于安全的。]]></description>
            <content:encoded><![CDATA[<p>你觉得你在写 JSX：</p>
<pre   class="language-jsx"><code class="language-jsx">&lt;marquee bgcolor=&quot;#ffa7c4&quot;&gt;hi&lt;/marquee&gt;
</code></pre><p>其实，你在调用一个方法：</p>
<pre   class="language-jsx"><code class="language-jsx">React.createElement(
  /* type */ 'marquee',
  /* props */ { bgcolor: '#ffa7c4' },
  /* children */ 'hi'
)
</code></pre><p>之后方法会返回一个对象给你，我们称此对象为React的 <em>元素</em>（element），它告诉 React 下一个要渲染什么。你的组件（component）返回一个它们组成的树（tree）。</p>
<pre data-line="9,"  9="" class="language-jsx"><code 9="" class="language-jsx">{
  type: 'marquee',
  props: {
    bgcolor: '#ffa7c4',
    children: 'hi',
  },
  key: null,
  ref: null,
  $$typeof: Symbol.for('react.element'), // 🧐是谁
}
</code></pre><p>如果你用过 React，对 <code>type</code>、 <code>props</code>、 <code>key</code>、 和 <code>ref</code> 应该熟悉。 <strong>但 <code>$$typeof</code> 是什么？为什么用 <code>Symbol()</code> 作为它的值</strong>？</p>
<p>这又是一个与你学习使用 React 不 <em>相关</em> 的点，但了解后你会觉得舒坦。这篇文章里也提到了些关于安全的提示，你可能会感兴趣。也许有一天你会有自己的UI库，这些都会派上用场的，我真的希望如此。</p>
<hr>
<p>在客户端 UI 库变得普遍且具有基本保护作用之前，应用程序代码通常是先构建 HTML，然后把它插入 DOM 中：</p>
<pre   class="language-jsx"><code class="language-jsx">const messageEl = document.getElementById('message');
messageEl.innerHTML = '&lt;p&gt;' + message.text + '&lt;/p&gt;';
</code></pre><p>这样看起来没什么问题，但当你 <code>message.text</code> 的值类似 <code>'&lt;img src onerror=&quot;stealYourPassword()&quot;&gt;'</code> 时，<strong>你不会希望别人写的内容在你应用的 HTML 中逐字显示的。</strong></p>
<p>（有趣的是：如果你只是在前端渲染，这里为 <code>&lt;script&gt;</code> 标签，JavaScript 代码不会被运行。但<a href="https://gomakethings.com/preventing-cross-site-scripting-attacks-when-using-innerhtml-in-vanilla-javascript/">不要因此</a>让你陷入已经安全的错觉。）</p>
<p>为什么防止此类攻击，你可以用只处理文本的 <code>document.createTextNode()</code> 或者 <code>textContent</code>等安全的 API。你也可以事先将用户输入的内容，用转义符把潜在危险字符（<code>&lt;</code>、<code>&gt;</code>等）替换掉。</p>
<p>尽管如此，这个问题的成本代价很高，且很难做到用户每次输入都记得转换一次。<strong>因此像React等新库会默认进行文本转义：</strong></p>
<pre   class="language-jsx"><code class="language-jsx">&lt;p&gt;
  {message.text}
&lt;/p&gt;
</code></pre><p>如果 <code>message.text</code> 是一个带有 <code>&lt;img&gt;</code> 或其他标签的恶意字符串，它不会被当成真的 <code>&lt;img&gt;</code> 标签处理，React 会先进行转义 <em>然后</em> 插入 DOM 里。所以 <code>&lt;img&gt;</code> 标签会以文本的形式展现出来。</p>
<p>要在 React 元素中渲染任意 HTML，你不得不写 <code>dangerouslySetInnerHTML={{ __html: message.text }}</code>。<strong>其实这种愚蠢的写法是一个功能</strong>，在 code reviews 和代码库审核时，你可以非常清晰的定位到代码。</p>
<hr>
<p><strong>这意味着React完全不惧注入攻击了吗？不</strong>，HTML 和 DOM 暴露了<a href="https://github.com/facebook/react/issues/3473#issuecomment-90594748">大量攻击点</a>，对 React 或者其他 UI 库来说，要减轻伤害太难或进展缓慢。大部分存在的攻击方向涉及到属性，例如，如果你渲染 <code>&lt;a href={user.website}</code>，要提防用户的网址是 <code>'javascript: stealYourPassword()'</code>。 像 <code>&lt;div {...userData}&gt;</code> 写法几乎不受用户输入影响，但也有危险。</p>
<p>React <a href="https://github.com/facebook/react/issues/10506">可以</a>逐步提供更多保护，但在很多情况下，威胁是服务器产生的，这不管怎样都<a href="https://github.com/facebook/react/issues/3473#issuecomment-91327040">应该</a>要避免。</p>
<p>不过，转义文本这第一道防线可以拦下许多潜在攻击，知道这样的代码是安全的就够了吗？</p>
<pre   class="language-jsx"><code class="language-jsx">// 自动转义
&lt;p&gt;
  {message.text}
&lt;/p&gt;
</code></pre><p><strong>好吧，也不总是有效的</strong>。这就是 <code>$$typeof</code> 的用武之地了。</p>
<hr>
<p>React 元素（elements）是设计好的 <em>plain object</em>：</p>
<pre   class="language-jsx"><code class="language-jsx">{
  type: 'marquee',
  props: {
    bgcolor: '#ffa7c4',
    children: 'hi',
  },
  key: null,
  ref: null,
  $$typeof: Symbol.for('react.element'),
}
</code></pre><p>虽然通常用 <code>React.createElement()</code> 创建它，但这不是必须的。有一些 React 用例来证实像上面这样的 <em>plain object</em> 元素是有效的。当然，你不会<em>想</em>这样写的，但这<a href="https://github.com/facebook/react/pull/3583#issuecomment-90296667">可以用来</a>优化编译器，在 workers 之间传递 UI 元素，或者将 JSX 从 React 包解耦出来。</p>
<p>但是，如果你的服务器有允许用户存储任意 JSON 对象的漏洞，而前端需要一个字符串，这可能会发生一个问题：</p>
<pre data-line="2-10,15,"  2-10,15="" class="language-jsx"><code 2-10,15="" class="language-jsx">// 服务端允许用户存储 JSON
let expectedTextButGotJSON = {
  type: 'div',
  props: {
    dangerouslySetInnerHTML: {
      __html: '/* 把你想的搁着 */'
    },
  },
  // ...
};
let message = { text: expectedTextButGotJSON };

// React 0.13 中有风险
&lt;p&gt;
  {message.text}
&lt;/p&gt;
</code></pre><p>在这个例子中，React 0.13<a href="http://danlec.com/blog/xss-via-a-spoofed-react-element">很容易</a>受到 XSS 攻击。再次声明，<strong>这个攻击是服务端存在漏洞导致的</strong>。不过，React 会为了大家的安全做更多工作。从 React 0.14 开始，它做到了。</p>
<p>React 0.14 修复手段是用 Symbol 标记每个 React 元素（element）：</p>
<pre data-line="9,"  9="" class="language-jsx"><code 9="" class="language-jsx">{
  type: 'marquee',
  props: {
    bgcolor: '#ffa7c4',
    children: 'hi',
  },
  key: null,
  ref: null,
  $$typeof: Symbol.for('react.element'),
}
</code></pre><p>这是个有效的办法，因为JSON不支持 <code>Symbol</code> 类型。<strong>所以即使服务器存在用JSON作为文本返回安全漏洞，JSON 里也不包含 <code>Symbol.for('react.element')</code></strong>。React 会检测 <code>element.$$typeof</code>，如果元素丢失或者无效，会拒绝处理该元素。</p>
<p>特意用 <code>Symbol.for()</code> 的好处是 <strong>Symbols 通用于 iframes 和 workers 等环境中</strong>。因此无论在多奇怪的条件下，这方案也不会影响到应用不同部分传递可信的元素。同样，即使页面上有很多个 React 副本，它们也 「接受」 有效的 <code>$$typeof</code> 值。</p>
<hr>
<p>如果浏览器不支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility">Symbols</a> 怎么办？</p>
<p>唉，那这种保护方案就无效了。React仍然会加上 <code>$$typeof</code> 字段以保证一致性，但只是<a href="https://github.com/facebook/react/blob/8482cbe22d1a421b73db602e1f470c632b09f693/packages/shared/ReactSymbols.js#L14-L16">设置一个数字</a>而已 —— <code>0xeac7</code>。</p>
<p>为什么是这个数字？因为 <code>0xeac7</code> 看起来有点像 「React」。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Why Do React Elements Have a $$typeof Property?]]></title>
            <link>/post/why-do-react-elements-have-typeof-property</link>
            <guid>/post/why-do-react-elements-have-typeof-property</guid>
            <description><![CDATA[It has something to do with security.]]></description>
            <content:encoded><![CDATA[<p>You might think you’re writing JSX:</p>
<pre   class="language-jsx"><code class="language-jsx">&lt;marquee bgcolor=&quot;#ffa7c4&quot;&gt;hi&lt;/marquee&gt;
</code></pre><p>But really, you’re calling a function:</p>
<pre   class="language-jsx"><code class="language-jsx">React.createElement(
  /* type */ 'marquee',
  /* props */ { bgcolor: '#ffa7c4' },
  /* children */ 'hi'
)
</code></pre><p>And that function gives you back an object. We call this object a React <em>element</em>. It tells React what to render next. Your components return a tree of them.</p>
<pre data-line="9,"  9="" class="language-jsx"><code 9="" class="language-jsx">{
  type: 'marquee',
  props: {
    bgcolor: '#ffa7c4',
    children: 'hi',
  },
  key: null,
  ref: null,
  $$typeof: Symbol.for('react.element'), // 🧐 Who dis
}
</code></pre><p>If you used React you might be familiar with <code>type</code>, <code>props</code>, <code>key</code>, and <code>ref</code> fields. <strong>But what is <code>$$typeof</code>? And why does it have a <code>Symbol()</code> as a value?</strong></p>
<p>That’s another one of those things that you don’t <em>need</em> to know to use React, but that will make you feel good when you do. There’s also some tips about security in this post that you might want to know. Maybe one day you’ll write your own UI library and all of this will come in handy. I certainly hope so.</p>
<hr>
<p>Before client-side UI libraries became common and added basic protection, it was common for app code to construct HTML and insert it into the DOM:</p>
<pre   class="language-jsx"><code class="language-jsx">const messageEl = document.getElementById('message');
messageEl.innerHTML = '&lt;p&gt;' + message.text + '&lt;/p&gt;';
</code></pre><p>That works fine, except when your <code>message.text</code> is something like <code>'&lt;img src onerror=&quot;stealYourPassword()&quot;&gt;'</code>. <strong>You don’t want things written by strangers to appear verbatim in your app’s rendered HTML.</strong></p>
<p>(Fun fact: if you only do client-side rendering, a <code>&lt;script&gt;</code> tag here wouldn’t let you run JavaScript. But <a href="https://gomakethings.com/preventing-cross-site-scripting-attacks-when-using-innerhtml-in-vanilla-javascript/">don’t let this</a> lull you into a false sense of security.)</p>
<p>To protect against such attacks, you can use safe APIs like <code>document.createTextNode()</code> or <code>textContent</code> that only deal with text. You can also preemptively “escape” inputs by replacing potentially dangerous characters like <code>&lt;</code>, <code>&gt;</code> and others in any user-provided text.</p>
<p>Still, the cost of a mistake is high and it’s a hassle to remember it every time you interpolate a user-written string into your output. <strong>This is why modern libraries like React escape text content for strings by default:</strong></p>
<pre   class="language-jsx"><code class="language-jsx">&lt;p&gt;
  {message.text}
&lt;/p&gt;
</code></pre><p>If <code>message.text</code> is a malicious string with an <code>&lt;img&gt;</code> or another tag, it won’t turn into a real <code>&lt;img&gt;</code> tag. React will escape the content and <em>then</em> insert it into the DOM. So instead of seeing the <code>&lt;img&gt;</code> tag you’ll just see its markup.</p>
<p>To render arbitrary HTML inside a React element, you have to write <code>dangerouslySetInnerHTML={{ __html: message.text }}</code>. <strong>The fact that it’s clumsy to write is a <em>feature</em>.</strong> It’s meant to be highly visible so that you can catch it in code reviews and codebase audits.</p>
<hr>
<p><strong>Does it mean React is entirely safe from injection attacks? No.</strong> HTML and DOM offer <a href="https://github.com/facebook/react/issues/3473#issuecomment-90594748">plenty of attack surface</a> that is too difficult or slow for React or other UI libraries to mitigate against. Most of the remaining attack vectors involve attributes. For example, if you render <code>&lt;a href={user.website}&gt;</code>, beware of the user whose website is <code>'javascript: stealYourPassword()'</code>. Spreading user input like <code>&lt;div {...userData}&gt;</code> is rare but also dangerous.</p>
<p>React <a href="https://github.com/facebook/react/issues/10506">could</a> provide more protection over time but in many cases these are consequences of server issues that <a href="https://github.com/facebook/react/issues/3473#issuecomment-91327040">should</a> be fixed there anyway.</p>
<p>Still, escaping text content is a reasonable first line of defence that catches a lot of potential attacks. Isn’t it nice to know that code like this is safe?</p>
<pre   class="language-jsx"><code class="language-jsx">// Escaped automatically
&lt;p&gt;
  {message.text}
&lt;/p&gt;
</code></pre><p><strong>Well, that wasn’t always true either.</strong> And that’s where <code>$$typeof</code> comes in.</p>
<hr>
<p>React elements are plain objects by design:</p>
<pre   class="language-jsx"><code class="language-jsx">{
  type: 'marquee',
  props: {
    bgcolor: '#ffa7c4',
    children: 'hi',
  },
  key: null,
  ref: null,
  $$typeof: Symbol.for('react.element'),
}
</code></pre><p>While normally you create them with <code>React.createElement()</code>, it is not required. There are valid use cases for React to support plain element objects written like I just did above. Of course, you probably wouldn’t <em>want</em> to write them like this — but this <a href="https://github.com/facebook/react/pull/3583#issuecomment-90296667">can be</a> useful for an optimizing compiler, passing UI elements between workers, or for decoupling JSX from the React package.</p>
<p>However, <strong>if your server has a hole that lets the user store an arbitrary JSON object</strong> while the client code expects a string, this could become a problem:</p>
<pre data-line="2-10,15,"  2-10,15="" class="language-jsx"><code 2-10,15="" class="language-jsx">// Server could have a hole that lets user store JSON
let expectedTextButGotJSON = {
  type: 'div',
  props: {
    dangerouslySetInnerHTML: {
      __html: '/* put your exploit here */'
    },
  },
  // ...
};
let message = { text: expectedTextButGotJSON };

// Dangerous in React 0.13
&lt;p&gt;
  {message.text}
&lt;/p&gt;
</code></pre><p>In that case, React 0.13 would be <a href="http://danlec.com/blog/xss-via-a-spoofed-react-element">vulnerable</a> to an XSS attack. To clarify, again, <strong>this attack depends on an existing server hole</strong>. Still, React could do a better job of protecting people against it. And starting with React 0.14, it does.</p>
<p>The fix in React 0.14 was to <a href="https://github.com/facebook/react/pull/4832">tag every React element with a Symbol</a>:</p>
<pre data-line="9,"  9="" class="language-jsx"><code 9="" class="language-jsx">{
  type: 'marquee',
  props: {
    bgcolor: '#ffa7c4',
    children: 'hi',
  },
  key: null,
  ref: null,
  $$typeof: Symbol.for('react.element'),
}
</code></pre><p>This works because you can’t just put <code>Symbol</code>s in JSON. <strong>So even if the server has a security hole and returns JSON instead of text, that JSON can’t include <code>Symbol.for('react.element')</code>.</strong> React will check <code>element.$$typeof</code>, and will refuse to process the element if it’s missing or invalid.</p>
<p>The nice thing about using <code>Symbol.for()</code> specifically is that <strong>Symbols are global between environments like iframes and workers.</strong> So this fix doesn’t prevent passing trusted elements between different parts of the app even in more exotic conditions. Similarly, even if there are multiple copies of React on the page, they can still “agree” on the valid <code>$$typeof</code> value.</p>
<hr>
<p>What about the browsers that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility">don’t support</a> Symbols?</p>
<p>Alas, they don’t get this extra protection. React still includes the <code>$$typeof</code> field on the element for consistency, but it’s <a href="https://github.com/facebook/react/blob/8482cbe22d1a421b73db602e1f470c632b09f693/packages/shared/ReactSymbols.js#L14-L16">set to a number</a> — <code>0xeac7</code>.</p>
<p>Why this number specifically? <code>0xeac7</code> kinda looks like “React”.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[为什么我们要写 super(props) ？]]></title>
            <link>/post/why-do-we-write-super-props-zh</link>
            <guid>/post/why-do-we-write-super-props-zh</guid>
            <description><![CDATA[结尾处有彩蛋。]]></description>
            <content:encoded><![CDATA[<p>据说 <a href="https://reactjs.org/docs/hooks-intro.html">Hooks</a> 势头正盛，不过我还是想略带调侃地从 <em>class</em> 的有趣之处开始这篇博客。可还行？</p>
<p><strong>这些梗对于使用 React 输出产品并<em>不</em>重要，但如果你想深入的了解它们的运作原理，它们会非常的有用。</strong></p>
<hr>
<p>首先，在这一生中，<code>super(props)</code> 出现在我代码里的次数比我知道的还要多：</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOn: true };
  }
  // ...
}
</code></pre><p>当然了，我们可以通过 <a href="https://github.com/tc39/proposal-class-fields">class fields proposal</a> 来省略这个声明：</p>
<pre   class="language-jsx"><code class="language-jsx">class Checkbox extends React.Component {
  state = { isOn: true };
  // ...
}
</code></pre><p>早在 2015 年 React 0.13 已经<a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers">计划支持</a> 。在当时，声明 <code>constructor</code> 和调用 <code>super(props)</code> 一直被视作暂时的解决方案，直到有合适的类字段声明形式。</p>
<p>但在此之前，我们先回到 ES2015 风格的代码：</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOn: true };
  }
  // ...
}
</code></pre><p>**为什么我们要调用 <code>super</code>，我们可以不这么做吗？那么在我们调用它时不传入 <code>props</code>，又会发生什么呢？会有其他的缺省参数吗？**接来下我们就解开这一系列谜题。</p>
<hr>
<p>在 JavaScript 中，<code>super</code> 指的是父类（即超类）的构造函数。（在我们的例子中，它指向了 <code>React.Component</code> 的实现。）</p>
<p>值得注意的是，在调用父类的构造函数之前，你是不能在 constructor 中使用 <code>this</code> 关键字的。JavaScript 不允许这个行为。</p>
<pre   class="language-jsx"><code class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    // 🔴  还不能使用 `this`
    super(props);
    // ✅  现在可以了
    this.state = { isOn: true };
  }
  // ...
}
</code></pre><p>JavaScript 有足够合理的动机来强制你在接触 <code>this</code> 之前执行父类构造函数。考虑考虑一些类层次结构的东西：</p>
<pre   class="language-jsx"><code class="language-jsx">class Person {
  constructor(name) {
    this.name = name;
  }
}

class PolitePerson extends Person {
  constructor(name) {
    this.greetColleagues(); // 🔴  这是禁止的，往后见原因
    super(name);
  }
  greetColleagues() {
    alert('Good morning folks!');
  }
}
</code></pre><p>试想一下，在调用 <code>super</code> 之前使用 <code>this</code> 不被禁止的情况下，一个月后，我们可能在 <code>greetColleagues</code> 打印的消息中使用了 person 的 name 属性：</p>
<pre   class="language-jsx"><code class="language-jsx">  greetColleagues() {
    alert('Good morning folks!');
    alert('My name is ' + this.name + ', nice to meet you!');
  }
</code></pre><p>但是我们并未想起 <code>this.greetColleagues</code> 在 <code>super()</code> 给 <code>this.name</code> 赋值前就已经执行。<code>this.name</code> 此时甚至尚未定义。可以看到，这样的代码难以往下推敲。</p>
<p>为了避免落入这个陷阱，**JavaScript 强制你在使用 <code>this</code> 之前先行调用 <code>super</code>。**让父类来完成这件事情！：</p>
<pre   class="language-jsx"><code class="language-jsx">  constructor(props) {
    super(props);
    // ✅ 能使用 `this` 了
    this.state = { isOn: true };
  }
</code></pre><p>这里留下了另一个问题：为什么要传入 <code>props</code> ？</p>
<hr>
<p>你或许会想到，为了让 React.Component 构造函数能够初始化 <code>this.props</code>，将 <code>props</code> 传入 <code>super</code> 是必须的：</p>
<pre   class="language-jsx"><code class="language-jsx">// React 內部
class Component {
  constructor(props) {
    this.props = props;
    // ...
  }
}
</code></pre><p>这几乎就是真相了 — 确然，它是 <a href="https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22">这样做</a> 的。</p>
<p>但有些扑朔迷离的是，即便你调用 <code>super()</code> 的时候没有传入 <code>props</code>，你依然能够在 <code>render</code> 函数或其他方法中访问到 <code>this.props</code>。（如果你质疑这个机制，尝试一下即可）</p>
<p>那么这是怎么做到的呢？事实证明，React 在调用构造函数后也立即将 <code>props</code> 赋值到了实例上：**</p>
<pre   class="language-jsx"><code class="language-jsx">  // React 内部
  const instance = new YourComponent(props);
  instance.props = props;
</code></pre><p>因此即便你忘记了将 <code>props</code> 传给 <code>super()</code>，React 也仍然会在之后将它定义到实例上。这么做是有原因的。</p>
<p>当 React 增加了对类的支持时，不仅仅是为了服务于 ES6。其目标是尽可能广泛地支持类抽象。当时我们 <a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages">不清楚</a>  ClojureScript，CoffeeScript，ES6，Fable，Scala.js，TypeScript 等解決方案是如何成功的实践组件定义的。因而 React 刻意地没有显式要求调用 <code>super()</code> —— 即便 ES6 自身就包含这个机制。</p>
<p>这意味着你能够用 <code>super()</code> 代替 <code>super(props)</code> 吗？</p>
<p><strong>最好不要，毕竟这样写在逻辑上并不明确</strong>确然，React 会在构造函数执行完毕<em>之后</em>给 <code>this.props</code> 赋值。但如此为之会使得 <code>this.props</code> 在 <code>super</code> 调用<em>一直到构造函数结束期间</em>值为 undefined。</p>
<pre data-line="14,"  14="" class="language-jsx"><code 14="" class="language-jsx">// React 內部
class Component {
  constructor(props) {
    this.props = props;
    // ...
  }
}

// 你的程式碼內部
class Button extends React.Component {
  constructor(props) {
    super(); // 😬 我们忘了传入 props
    console.log(props);      // ✅ {}
    console.log(this.props); // 😬 未定义
  }
  // ...
}
</code></pre><p>如果在构造函数中调用了其他的内部方法，那么一旦出错这会使得调试过程阻力更大。<strong>这就是我建议开发者一定执行 <code>super(props)</code> 的原因，即使理论上这并非必要：</strong></p>
<pre   class="language-jsx"><code class="language-jsx">class Button extends React.Component {
  constructor(props) {
    super(props); // ✅ 传入 props
    console.log(props);      // ✅ {}
    console.log(this.props); // ✅ {}
  }
  // ...
}
</code></pre><p>确保了 <code>this.props</code> 在构造函数执行完毕之前已被赋值。</p>
<hr>
<p>最后，还有一点是 React 爱好者长期以来的好奇之处。</p>
<p>你会发现当你在类中使用 Context API （无论是旧版的 <code>contextTypes</code> 或是在 React 16.6 更新的新版 <code>contextTypes</code>）的时候，<code>context</code> 是作为第二个参数传入构造函数的。</p>
<p>那么为什么我们不能转而写成 <code>super(props, context)</code> 呢？我们当然可以，但 context 的使用频率较低，因而并没有掘这个坑。</p>
<p><strong>class fields proposal 出台后，这些坑大部分都会自然地消失</strong>在没有显示的定义构造函数的情况下，以上的属性都会被自动地初始化。这使得像 <code>state = {}</code> 这类表达式能够在需要的情况下引用 <code>this.props</code> 和 <code>this.context</code> 的内容。</p>
<p>然而，有了 Hooks 以后，我们几乎就不需要 <code>super</code> 和 <code>this</code> 了。但那就是另一个下午的茶点了。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Why Do We Write super(props)?]]></title>
            <link>/post/why-do-we-write-super-props</link>
            <guid>/post/why-do-we-write-super-props</guid>
            <description><![CDATA[There’s a twist at the end.]]></description>
            <content:encoded><![CDATA[<p>I heard <a href="https://reactjs.org/docs/hooks-intro.html">Hooks</a> are the new hotness. Ironically, I want to start this blog by describing fun facts about <em>class</em> components. How about that!</p>
<p><strong>These gotchas are <em>not</em> important for using React productively. But you might find them amusing if you like to dig deeper into how things work.</strong></p>
<p>Here’s the first one.</p>
<hr>
<p>I wrote <code>super(props)</code> more times in my life than I’d like to know:</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOn: true };
  }
  // ...
}
</code></pre><p>Of course, the <a href="https://github.com/tc39/proposal-class-fields">class fields proposal</a> lets us skip the ceremony:</p>
<pre data-line="1,2,3,"  1,2,3="" class="language-jsx"><code 1,2,3="" class="language-jsx">class Checkbox extends React.Component {
  state = { isOn: true };
  // ...
}
</code></pre><p>A syntax like this was <a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers">planned</a> when React 0.13 added support for plain classes in 2015. Defining <code>constructor</code> and calling <code>super(props)</code> was always intended to be a temporary solution until class fields provide an ergonomic alternative.</p>
<p>But let’s get back to this example using only ES2015 features:</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOn: true };
  }
  // ...
}
</code></pre><p><strong>Why do we call <code>super</code>? Can we <em>not</em> call it? If we have to call it, what happens if we don’t pass <code>props</code>? Are there any other arguments?</strong> Let’s find out.</p>
<hr>
<p>In JavaScript, <code>super</code> refers to the parent class constructor. (In our example, it points to the <code>React.Component</code> implementation.)</p>
<p>Importantly, you can’t use <code>this</code> in a constructor until <em>after</em> you’ve called the parent constructor. JavaScript won’t let you:</p>
<pre   class="language-jsx"><code class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    // 🔴 Can’t use `this` yet
    super(props);
    // ✅ Now it’s okay though
    this.state = { isOn: true };
  }
  // ...
}
</code></pre><p>There’s a good reason for why JavaScript enforces that parent constructor runs before you touch <code>this</code>. Consider a class hierarchy:</p>
<pre   class="language-jsx"><code class="language-jsx">class Person {
  constructor(name) {
    this.name = name;
  }
}

class PolitePerson extends Person {
  constructor(name) {
    this.greetColleagues(); // 🔴 This is disallowed, read below why
    super(name);
  }
  greetColleagues() {
    alert('Good morning folks!');
  }
}
</code></pre><p>Imagine using <code>this</code> before <code>super</code> call <em>was</em> allowed. A month later, we might change <code>greetColleagues</code> to include the person’s name in the message:</p>
<pre   class="language-jsx"><code class="language-jsx">  greetColleagues() {
    alert('Good morning folks!');
    alert('My name is ' + this.name + ', nice to meet you!');
  }
</code></pre><p>But we forgot that <code>this.greetColleagues()</code> is called before the <code>super()</code> call had a chance to set up <code>this.name</code>. So <code>this.name</code> isn’t even defined yet! As you can see, code like this can be very difficult to think about.</p>
<p>To avoid such pitfalls, <strong>JavaScript enforces that if you want to use <code>this</code> in a constructor, you <em>have to</em> call <code>super</code> first.</strong> Let the parent do its thing! And this limitation applies to React components defined as classes too:</p>
<pre   class="language-jsx"><code class="language-jsx">  constructor(props) {
    super(props);
    // ✅ Okay to use `this` now
    this.state = { isOn: true };
  }
</code></pre><p>This leaves us with another question: why pass <code>props</code>?</p>
<hr>
<p>You might think that passing <code>props</code> down to <code>super</code> is necessary so that the base <code>React.Component</code> constructor can initialize <code>this.props</code>:</p>
<pre   class="language-jsx"><code class="language-jsx">// Inside React
class Component {
  constructor(props) {
    this.props = props;
    // ...
  }
}
</code></pre><p>And that’s not far from truth — indeed, that’s <a href="https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22">what it does</a>.</p>
<p>But somehow, even if you call <code>super()</code> without the <code>props</code> argument, you’ll still be able to access <code>this.props</code> in the <code>render</code> and other methods. (If you don’t believe me, try it yourself!)</p>
<p>How does <em>that</em> work? It turns out that <strong>React also assigns <code>props</code> on the instance right after calling <em>your</em> constructor:</strong></p>
<pre   class="language-jsx"><code class="language-jsx">  // Inside React
  const instance = new YourComponent(props);
  instance.props = props;
</code></pre><p>So even if you forget to pass <code>props</code> to <code>super()</code>, React would still set them right afterwards. There is a reason for that.</p>
<p>When React added support for classes, it didn’t just add support for ES6 classes alone. The goal was to support as wide range of class abstractions as possible. It was <a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages">not clear</a> how relatively successful would ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript, or other solutions be for defining components. So React was intentionally unopinionated about whether calling <code>super()</code> is required — even though ES6 classes are.</p>
<p>So does this mean you can just write <code>super()</code> instead of <code>super(props)</code>?</p>
<p><strong>Probably not because it’s still confusing.</strong> Sure, React would later assign <code>this.props</code> <em>after</em> your constructor has run. But <code>this.props</code> would still be undefined <em>between</em> the <code>super</code> call and the end of your constructor:</p>
<pre data-line="14,"  14="" class="language-jsx"><code 14="" class="language-jsx">// Inside React
class Component {
  constructor(props) {
    this.props = props;
    // ...
  }
}

// Inside your code
class Button extends React.Component {
  constructor(props) {
    super(); // 😬 We forgot to pass props
    console.log(props);      // ✅ {}
    console.log(this.props); // 😬 undefined 
  }
  // ...
}
</code></pre><p>It can be even more challenging to debug if this happens in some method that’s called <em>from</em> the constructor. <strong>And that’s why I recommend always passing down <code>super(props)</code>, even though it isn’t strictly necessary:</strong></p>
<pre   class="language-jsx"><code class="language-jsx">class Button extends React.Component {
  constructor(props) {
    super(props); // ✅ We passed props
    console.log(props);      // ✅ {}
    console.log(this.props); // ✅ {}
  }
  // ...
}
</code></pre><p>This ensures <code>this.props</code> is set even before the constructor exits.</p>
<hr>
<p>There’s one last bit that longtime React users might be curious about.</p>
<p>You might have noticed that when you use the Context API in classes (either with the legacy <code>contextTypes</code> or the modern <code>contextType</code> API added in React 16.6), <code>context</code> is passed as a second argument to the constructor.</p>
<p>So why don’t we write <code>super(props, context)</code> instead? We could, but context is used less often so this pitfall just doesn’t come up as much.</p>
<p><strong>With the class fields proposal this whole pitfall mostly disappears anyway.</strong> Without an explicit constructor, all arguments are passed down automatically. This is what allows an expression like <code>state = {}</code> to include references to <code>this.props</code> or <code>this.context</code> if necessary.</p>
<p>With Hooks, we don’t even have <code>super</code> or <code>this</code>. But that’s a topic for another day.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[为什么 'XX' 不是一个 Hooks API?]]></title>
            <link>/post/why-isnt-x-a-hook-zh</link>
            <guid>/post/why-isnt-x-a-hook-zh</guid>
            <description><![CDATA[我们可以这样做，但并不是意味着我们应该这样做。]]></description>
            <content:encoded><![CDATA[<p>自从 <a href="https://reactjs.org/hooks">React Hooks</a> 发布 alpha 版本, 就有很多人对一些问题的讨论，比如: “为什么有些 API 不是一个 Hook?”。</p>
<p>比如下面这些就是一些 Hooks API：</p>
<ul>
<li><a href="https://reactjs.org/docs/hooks-reference.html#usestate"><code>useState()</code></a> 可以用来声明 <code>state</code> 变量。</li>
<li><a href="https://reactjs.org/docs/hooks-reference.html#useeffect"><code>useEffect()</code></a> 可以用来声明 <code>side effects</code>。</li>
<li><a href="https://reactjs.org/docs/hooks-reference.html#usecontext"><code>useContext()</code></a> 可以用来读取 <code>context</code>。</li>
</ul>
<p>但是有些 API 就不是 hooks，比如 <code>React.memo()</code> 和 <code>&lt;Context.Provider&gt;</code>。一般大家提出来的 Hook 基本上是*不可组合（noncompositional）<em>和</em>反模块化（antimodular）*的，这篇文章会帮助你理解为什么。</p>
<p><strong>注：这篇文章是一篇深入探讨的文章，阅读对象应该是对 API 的讨论是非常感兴趣的，而不是为了考虑使用 React 来提升效率的！</strong></p>
<hr>
<p>我们想让 React 的 API 保持以下非常重要的两点:</p>
<ol>
<li>
<p><strong>组合:</strong> 对于 Hooks API来说，可以<a href="https://reactjs.org/docs/hooks-custom.html">自定义 Hooks</a> 是让我们感到非常兴奋的. 我们期望大家都可以来构建自己的Hooks API, 并且我们需要确保不同人写的 Hooks API <a href="/why-do-hooks-rely-on-call-order/#flaw-4-the-diamond-problem">不会造成冲突</a>。 (我们是不是已经被自由的组合组件而不用担心相互造成影响给惯坏了？)</p>
</li>
<li>
<p><strong>调试:</strong> 我们希望随着应用规模的不断增长 <a href="/the-bug-o-notation/">bug 是很容易发现的</a>的。React最棒的一个特性就是如果某些内容被错误的渲染了，你可以轻松的找到对应的组件的 prop 或者 state 导致了这个问题。</p>
</li>
</ol>
<p>结合这两点来看，我们就可以知道哪些是<em>不能</em>成为一个 Hook。我们可以用一些例子来说明：</p>
<hr>
<h2>一个 Hook: <code>useState()</code></h2>
<h3>组合</h3>
<p>多个自定义的 Hooks 调用 <code>useState()</code>，而不会造成冲突：</p>
<pre   class="language-js"><code class="language-js">function useMyCustomHook1() {
  const [value, setValue] = useState(0);
  // What happens here, stays here.
}

function useMyCustomHook2() {
  const [value, setValue] = useState(0);
  // What happens here, stays here.
}

function MyComponent() {
  useMyCustomHook1();
  useMyCustomHook2();
  // ...
}
</code></pre><p>添加一个不在条件判断里的 <code>useState()</code> ， 调用这个 API 是很安全的。你不需要了解在一个组件里面声明了新的 state 变量被其他 Hooks 使用了。也不会因为更新了其他状态导致 state 变量被破坏。</p>
<p><strong>结论:</strong> ✅ <code>useState()</code> 不会对其他自定义的 Hooks 造成破坏。</p>
<h3>调试</h3>
<p>Hooks 是非常有用的，你可以在 Hooks <em>之间</em>传递值：</p>
<pre data-line="4,12,14,"  4,12,14="" class="language-js"><code 4,12,14="" class="language-js">function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  // ...
  return width;
}

function useTheme(isMobile) {
  // ...
}

function Comment() {
  const width = useWindowWidth();
  const isMobile = width &lt; MOBILE_VIEWPORT;
  const theme = useTheme(isMobile);
  return (
    &lt;section className={theme.comment}&gt;
      {/* ... */}
    &lt;/section&gt;
  );
}
</code></pre><p>但是如过我们的代码出错了，我们怎么调试？</p>
<p>假设我们从 <code>theme.comment</code> 里拿出来的一个 css class 是错误的, 那我们怎么调试这个问题？我们可以在组件里设置一个断点或者输出一些日志。</p>
<p>也许我们可以发现 <code>theme</code> 是错误的，但是 <code>width</code> 和 <code>isMobile</code>是正确的。这就告诉我们问题是发生在 <code>useTheme()</code> 里面。也有可能 <code>width</code> 不对，那么相应的问题就出在 <code>useWindowWidth()</code> 里。</p>
<p><strong>一看最顶部的对应 Hooks 里的中间值就知道问题发生在哪里了。</strong> 我们不需要查看组件里所有的 Hooks 的实现。</p>
<p>我们直接查看有问题的那个实现，重复这个步骤就可以确定问题具体问题发生在什么地方。</p>
<p>如果自定义 Hooks 的嵌套层级增加了，那么这个就变的更加重要。想象一下，我们有三层嵌套的自定义 Hook，每层使用了三个不同的自定 Hooks。 定位<strong>3个有问题的地方</strong>和定位 <strong>3 + 3×3 + 3×3×3 = 39个有问题地方</strong>，二者之间的成本<a href="/the-bug-o-notation/">差别</a>是非常大的。幸运的是，<code>useState()</code> 不会对其他 Hooks 或者组件造成莫名其妙的影响。雁过留痕，一个 Hooks 返回的错误值，和普通的变量是没有任何区别的。🐛</p>
<p><strong>结论:</strong> ✅ <code>useState()</code> 不会隐藏我们代码中的因果关系。我们可以一步步的定位到对应的bug。</p>
<hr>
<h2>不是一个 Hook: <code>useBailout()</code></h2>
<p>作为一种优化, 组件使用 Hooks 可以避免重新渲染。</p>
<p>另一种方式是我们可以使用 <a href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactmemo"><code>React.memo()</code></a> 包裹整个组件。 为了避免重新渲染，<code>React.memo()</code> 会用本次即将渲染的 props 和最后一次然的 props 通过 <code>shallowly equal</code> 去做比较， 这个和 <code>PureComponent</code> 是类似的。</p>
<p><code>React.memo()</code> 接收一个组件作为参数并返回一个组件：</p>
<pre data-line="4,"  4="" class="language-js"><code 4="" class="language-js">function Button(props) {
  // ...
}
export default React.memo(Button);
</code></pre><p><strong>但是 <code>useBailout()</code> 为什么不仅仅是一个钩子</strong></p>
<p>不论你将其称之为 <code>useShouldComponentUpdate()</code>， <code>usePure()</code>， <code>useSkipRender()</code> 或者 <code>useBailout()</code>， 这个提案(proposal)看起来就和下面这个是一样的：</p>
<pre   class="language-js"><code class="language-js">function Button({ color }) {
  // ⚠️ 非真实API
  useBailout(prevColor =&gt; prevColor !== color, color);

  return (
    &lt;button className={'button-' + color}&gt;  
      OK
    &lt;/button&gt;
  )
}
</code></pre><p>也有一些其他不同的提案（比如：<a href="https://github.com/reactjs/rfcs/pull/30#issuecomment-371337630"><code>usePure()</code></a>），但是一般来说，这个提案也有同样的问题。</p>
<h3>组合</h3>
<p>让我们尝试将 <code>useBailout()</code> 在两个自定义的 Hooks 中使用：</p>
<pre data-line="4,5,19,20,"  4,5,19,20="" class="language-js"><code 4,5,19,20="" class="language-js">function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ⚠️ 非真实API
  useBailout(prevIsOnline =&gt; prevIsOnline !== isOnline, isOnline);

  useEffect(() =&gt; {
    const handleStatusChange = status =&gt; setIsOnline(status.isOnline);
    ChatAPI.subscribe(friendID, handleStatusChange);
    return () =&gt; ChatAPI.unsubscribe(friendID, handleStatusChange);
  });

  return isOnline;
}

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  
  // ⚠️ 非真实API
  useBailout(prevWidth =&gt; prevWidth !== width, width);

  useEffect(() =&gt; {
    const handleResize = () =&gt; setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () =&gt; window.removeEventListener('resize', handleResize);
  });

  return width;
}
</code></pre><p>如果现在在同一个组件中使用这两个自定义的 Hooks 会发生什么？</p>
<pre data-line="2,3,"  2,3="" class="language-js"><code 2,3="" class="language-js">function ChatThread({ friendID, isTyping }) {
  const width = useWindowWidth();
  const isOnline = useFriendStatus(friendID);
  return (
    &lt;ChatLayout width={width}&gt;
      &lt;FriendStatus isOnline={isOnline} /&gt;
      {isTyping &amp;&amp; 'Typing...'}
    &lt;/ChatLayout&gt;
  );
}
</code></pre><p>什么时候重新渲染?</p>
<p>如果每一个 <code>useBailout()</code> 都有权限去跳过更新，那么 <code>useWindowWidth()</code> 里面的更新就会被 <code>useFriendStatus()</code> 给阻塞，反之亦然。 <strong>这些 Hooks 会相互影响。</strong></p>
<p>然而，如果允许<code>useBailout()</code> 在一个组件里去阻止更新的话，那么我们的 <code>ChatThread</code> 组件里的 <code>isTyping</code> 属性发生变化时也无法去更新这个组件。</p>
<p>更糟糕的是，如果我们使用这种语义，<strong>任何新添加到 <code>ChatThread</code> 里的 Hooks 如果没有<em>同样</em>调用 <code>useBailout()</code>，那么这些 Hooks 也同样会被阻断</strong>。不然 <code>useBailout()</code> 也没有办法在 <code>useWindowWidth()</code> 和 <code>useFriendStatus()</code> 阻止更新时 “投上反对票（vote against）”。</p>
<p><strong>结论:</strong> 🔴 <code>useBailout()</code> 违反了组合原则. 添加 <code>useBailout()</code> 到一个 Hook 里面就会影响其他 Hooks 的状态更新。我希望和 API 是<a href="/optimized-for-change/">健壮的(antifragile)</a>, 但是 <code>useBailout()</code> 的行为是完完全全相反的。</p>
<h3>调试</h3>
<p>像 <code>useBailout()</code> 的这样的 hook 会对调试造成什么影响？</p>
<p>我们使用同样的列子:</p>
<pre   class="language-js"><code class="language-js">function ChatThread({ friendID, isTyping }) {
  const width = useWindowWidth();
  const isOnline = useFriendStatus(friendID);
  return (
    &lt;ChatLayout width={width}&gt;
      &lt;FriendStatus isOnline={isOnline} /&gt;
      {isTyping &amp;&amp; 'Typing...'}
    &lt;/ChatLayout&gt;
  );
}
</code></pre><p>假设有些上层组件的属性发生了变化，但是 <code>Typing...</code> label 没有按照我们预期显示出来。这时候我们怎么调试呢？</p>
<p><strong>通常，你会很自信的回答这个问题，我们只需要去看<em>上层组件</em>。</strong> 如果 <code>ChatThread</code> 没有获得 <code>isTyping</code> 的新值。我们可以打开渲染 <code>&lt;ChatThread isTyping={myVar} /&gt;</code> 的组件，然后去检查 <code>myVar</code> 等等。在同级组件中，我们可能在 <code>shouldComponentUpdate()</code> 中发现被阻止了，或者 <code>isTyping</code> 的值没有正确的传递过去。检查在这个链中的每一个组件通常也能轻松的定位到问题的根源。</p>
<p>如果 <code>useBailout()</code> Hook 是一个真实的 API。在你深度地检查 <code>ChatThread</code> 和 <code>ChatThread</code> 里所有组件<em>中使用到的每一个自定义 Hook</em> 之前，你永远不知道跳过更新的原因。由于每一个父组件<em>同样</em>可以使用自定义 Hooks，这个<a href="/the-bug-o-notation/">情况（scales）</a>就变的更加复杂了。</p>
<p>这就像你在一个抽屉柜里有一堆小抽屉的其中一个找到一把小螺丝刀一样。你永远不知道这个“坑”到底有多深。</p>
<p><strong>结论:</strong> 🔴 <code>useBailout()</code> Hook 不仅仅破坏可组合性, 为了找到有 bug 的阻止更新代码，大大的增加了调试步骤和认知负荷 —— 在某些情况下，这是指数级别的。</p>
<hr>
<p>我们讨论了一个真正存在的 Hook - <code>useState()</code>，和另一个看上去是 Hook，但是实际上<em>不</em>是一个 Hook - <code>useBailout()</code> 的例子，我们比较了组合和调试，并讨论了为什么其中一个是有效的，另一个事无效的。</p>
<p>虽然没有 “Hook 版本” 的 <code>memo()</code> 和 <code>shouldComponentUpdate()</code>，但是React确实提供了一个叫 <a href="https://reactjs.org/docs/hooks-reference.html#usememo"><code>useMemo()</code></a> 的 API. 虽然有相同的用途，但是 <code>useMemo()</code> 本身的语义是不一样的，不会遇到上面所说的问题。</p>
<p><code>useBailout()</code> 只是一个不会像 Hook 一样工作的例子。但是也还有一些其他的 Hooks API —— 比如，<code>useProvider()</code>, <code>useCatch()</code>, 和 <code>useSuspense()</code>。</p>
<p>现在明白为什么了吗?</p>
<p><em>(低头嘀咕: 组合... 调试...)</em></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Why Isn’t X a Hook?]]></title>
            <link>/post/why-isnt-x-a-hook</link>
            <guid>/post/why-isnt-x-a-hook</guid>
            <description><![CDATA[Just because we can, doesn’t mean we should.]]></description>
            <content:encoded><![CDATA[<p>Since the first alpha version of <a href="https://reactjs.org/hooks">React Hooks</a> was released, there is a question that keeps coming up in discussions: “Why isn’t <em>&lt;some other API&gt;</em> a Hook?”</p>
<p>To remind you, here’s a few things that <em>are</em> Hooks:</p>
<ul>
<li><a href="https://reactjs.org/docs/hooks-reference.html#usestate"><code>useState()</code></a> lets you declare a state variable.</li>
<li><a href="https://reactjs.org/docs/hooks-reference.html#useeffect"><code>useEffect()</code></a> lets you declare a side effect.</li>
<li><a href="https://reactjs.org/docs/hooks-reference.html#usecontext"><code>useContext()</code></a> lets you read some context.</li>
</ul>
<p>But there are some other APIs, like <code>React.memo()</code> and <code>&lt;Context.Provider&gt;</code>, that are <em>not</em> Hooks. Commonly proposed Hook versions of them would be <em>noncompositional</em> or <em>antimodular</em>. This article will help you understand why.</p>
<p><strong>Note: this post is a deep dive for folks who are interested in API discussions. You don’t need to think about any of this to be productive with React!</strong></p>
<hr>
<p>There are two important properties that we want React APIs to preserve:</p>
<ol>
<li>
<p><strong>Composition:</strong> <a href="https://reactjs.org/docs/hooks-custom.html">Custom Hooks</a> are largely the reason we’re excited about the Hooks API. We expect people to build their own Hooks very often, and we need to make sure Hooks written by different people <a href="/why-do-hooks-rely-on-call-order/#flaw-4-the-diamond-problem">don't conflict</a>. (Aren’t we all spoiled by how components compose cleanly and don’t break each other?)</p>
</li>
<li>
<p><strong>Debugging:</strong> We want the bugs to be <a href="/the-bug-o-notation/">easy to find</a> as the application grows. One of React's best features is that if you see something wrong rendered, you can walk up the tree until you find which component's prop or state caused the mistake.</p>
</li>
</ol>
<p>These two constraints put together can tell us what can or <em>cannot</em> be a Hook. Let’s try a few examples.</p>
<hr>
<h2>A Real Hook: <code>useState()</code></h2>
<h3>Composition</h3>
<p>Multiple custom Hooks each calling <code>useState()</code> don’t conflict:</p>
<pre   class="language-jsx"><code class="language-jsx">function useMyCustomHook1() {
  const [value, setValue] = useState(0);
  // What happens here, stays here.
}

function useMyCustomHook2() {
  const [value, setValue] = useState(0);
  // What happens here, stays here.
}

function MyComponent() {
  useMyCustomHook1();
  useMyCustomHook2();
  // ...
}
</code></pre><p>Adding a new unconditional <code>useState()</code> call is always safe. You don’t need to know anything about other Hooks used by a component to declare a new state variable. You also can’t break other state variables by updating one of them.</p>
<p><strong>Verdict:</strong> ✅ <code>useState()</code> doesn’t make custom Hooks fragile.</p>
<h3>Debugging</h3>
<p>Hooks are useful because you can pass values <em>between</em> Hooks:</p>
<pre data-line="4,12,14,"  4,12,14="" class="language-jsx"><code 4,12,14="" class="language-jsx">function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  // ...
  return width;
}

function useTheme(isMobile) {
  // ...
}

function Comment() {
  const width = useWindowWidth();
  const isMobile = width &lt; MOBILE_VIEWPORT;
  const theme = useTheme(isMobile);
  return (
    &lt;section className={theme.comment}&gt;
      {/* ... */}
    &lt;/section&gt;
  );
}
</code></pre><p>But what if we make a mistake? What’s the debugging story?</p>
<p>Let's say the CSS class we get from <code>theme.comment</code> is wrong. How would we debug this? We can set a breakpoint or a few logs in the body of our component.</p>
<p>Maybe we’d see that <code>theme</code> is wrong but <code>width</code> and <code>isMobile</code> are correct. That would tell us the problem is inside <code>useTheme()</code>. Or perhaps we'd see that <code>width</code> itself is wrong. That would tell us to look into <code>useWindowWidth()</code>.</p>
<p><strong>A single look at the intermediate values tells us which of the Hooks at the top level contains the bug.</strong> We don't need to look at <em>all</em> of their implementations.</p>
<p>Then we can “zoom in” on the one that has a bug, and repeat.</p>
<p>This becomes more important if the depth of custom Hook nesting increases. Imagine we have 3 levels of custom Hook nesting, each level using 3 different custom Hooks inside. The <a href="/the-bug-o-notation/">difference</a> between looking for a bug in <strong>3 places</strong> versus potentially checking <strong>3 + 3×3 + 3×3×3 = 39 places</strong> is enormous. Luckily, <code>useState()</code> can't magically “influence” other Hooks or components. A buggy value returned by it leaves a trail behind it, just like any variable. 🐛</p>
<p><strong>Verdict:</strong> ✅ <code>useState()</code> doesn’t obscure the cause-effect relationship in our code. We can follow the breadcrumbs directly to the bug.</p>
<hr>
<h2>Not a Hook: <code>useBailout()</code></h2>
<p>As an optimization, components using Hooks can bail out of re-rendering.</p>
<p>One way to do it is to put a <a href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactmemo"><code>React.memo()</code></a> wrapper around the whole component. It bails out of re-rendering if props are shallowly equal to what we had during the last render. This makes it similar to <code>PureComponent</code> in classes.</p>
<p><code>React.memo()</code> takes a component and returns a component:</p>
<pre data-line="4,"  4="" class="language-jsx"><code 4="" class="language-jsx">function Button(props) {
  // ...
}
export default React.memo(Button);
</code></pre><p><strong>But why isn’t it just a Hook?</strong></p>
<p>Whether you call it <code>useShouldComponentUpdate()</code>, <code>usePure()</code>, <code>useSkipRender()</code>, or <code>useBailout()</code>, the proposal tends to look something like this:</p>
<pre   class="language-jsx"><code class="language-jsx">function Button({ color }) {
  // ⚠️ Not a real API
  useBailout(prevColor =&gt; prevColor !== color, color);

  return (
    &lt;button className={'button-' + color}&gt;  
      OK
    &lt;/button&gt;
  )
}
</code></pre><p>There are a few more variations (e.g. a simple <code>usePure()</code> marker) but in broad strokes they have the same flaws.</p>
<h3>Composition</h3>
<p>Let’s say we try to put <code>useBailout()</code> in two custom Hooks:</p>
<pre data-line="4,5,19,20,"  4,5,19,20="" class="language-jsx"><code 4,5,19,20="" class="language-jsx">function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ⚠️ Not a real API
  useBailout(prevIsOnline =&gt; prevIsOnline !== isOnline, isOnline);

  useEffect(() =&gt; {
    const handleStatusChange = status =&gt; setIsOnline(status.isOnline);
    ChatAPI.subscribe(friendID, handleStatusChange);
    return () =&gt; ChatAPI.unsubscribe(friendID, handleStatusChange);
  });

  return isOnline;
}

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  
  // ⚠️ Not a real API
  useBailout(prevWidth =&gt; prevWidth !== width, width);

  useEffect(() =&gt; {
    const handleResize = () =&gt; setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () =&gt; window.removeEventListener('resize', handleResize);
  });

  return width;
}
</code></pre><p>Now what happens if you use them both in the same component?</p>
<pre data-line="2,3,"  2,3="" class="language-jsx"><code 2,3="" class="language-jsx">function ChatThread({ friendID, isTyping }) {
  const width = useWindowWidth();
  const isOnline = useFriendStatus(friendID);
  return (
    &lt;ChatLayout width={width}&gt;
      &lt;FriendStatus isOnline={isOnline} /&gt;
      {isTyping &amp;&amp; 'Typing...'}
    &lt;/ChatLayout&gt;
  );
}
</code></pre><p>When does it re-render?</p>
<p>If every <code>useBailout()</code> call has the power to skip an update, then updates from <code>useWindowWidth()</code> would be blocked by <code>useFriendStatus()</code>, and vice versa. <strong>These Hooks would break each other.</strong></p>
<p>However, if <code>useBailout()</code> was only respected when <em>all</em> calls to it inside a single component “agree” to block an update, our <code>ChatThread</code> would fail to update on changes to the <code>isTyping</code> prop.</p>
<p>Even worse, with these semantics <strong>any newly added Hooks to <code>ChatThread</code> would break if they don’t <em>also</em> call <code>useBailout()</code></strong>. Otherwise, they can’t “vote against” the bailout inside <code>useWindowWidth()</code> and <code>useFriendStatus()</code>.</p>
<p><strong>Verdict:</strong> 🔴 <code>useBailout()</code> breaks composition. Adding it to a Hook breaks state updates in other Hooks. We want the APIs to be <a href="/optimized-for-change/">antifragile</a>, and this behavior is pretty much the opposite.</p>
<h3>Debugging</h3>
<p>How does a Hook like <code>useBailout()</code> affect debugging?</p>
<p>We’ll use the same example:</p>
<pre   class="language-jsx"><code class="language-jsx">function ChatThread({ friendID, isTyping }) {
  const width = useWindowWidth();
  const isOnline = useFriendStatus(friendID);
  return (
    &lt;ChatLayout width={width}&gt;
      &lt;FriendStatus isOnline={isOnline} /&gt;
      {isTyping &amp;&amp; 'Typing...'}
    &lt;/ChatLayout&gt;
  );
}
</code></pre><p>Let’s say the <code>Typing...</code> label doesn’t appear when we expect, even though somewhere many layers above the prop is changing. How do we debug it?</p>
<p><strong>Normally, in React you can confidently answer this question by looking <em>up</em>.</strong> If <code>ChatThread</code> doesn’t get a new <code>isTyping</code> value, we can open the component that renders <code>&lt;ChatThread isTyping={myVar} /&gt;</code> and check <code>myVar</code>, and so on. At one of these levels, we’ll either find a buggy <code>shouldComponentUpdate()</code> bailout, or an incorrect <code>isTyping</code> value being passed down. One look at each component in the chain is usually enough to locate the source of the problem.</p>
<p>However, if this <code>useBailout()</code> Hook was real, you would never know the reason an update was skipped until you checked <em>every single custom Hook</em> (deeply) used by our <code>ChatThread</code> and components in its owner chain. Since every parent component can <em>also</em> use custom Hooks, this <a href="/the-bug-o-notation/">scales</a> terribly.</p>
<p>It’s like if you were looking for a screwdriver in a chest of drawers, and each drawer contained a bunch of smaller chests of drawers, and you don’t know how deep the rabbit hole goes.</p>
<p><strong>Verdict:</strong> 🔴 Not only <code>useBailout()</code> Hook breaks composition, but it also vastly increases the number of debugging steps and cognitive load for finding a buggy bailout — in some cases, exponentially.</p>
<hr>
<p>We just looked at one real Hook, <code>useState()</code>, and a common suggestion that is intentionally <em>not</em> a Hook — <code>useBailout()</code>. We compared them through the prism of Composition and Debugging, and discussed why one of them works and the other one doesn’t.</p>
<p>While there is no “Hook version” of <code>memo()</code> or <code>shouldComponentUpdate()</code>, React <em>does</em> provide a Hook called <a href="https://reactjs.org/docs/hooks-reference.html#usememo"><code>useMemo()</code></a>. It serves a similar purpose, but its semantics are different enough to not run into the pitfalls described above.</p>
<p><code>useBailout()</code> is just one example of something that doesn’t work well as a Hook. But there are a few others — for example, <code>useProvider()</code>, <code>useCatch()</code>, or <code>useSuspense()</code>.</p>
<p>Can you see why?</p>
<p><em>(Whispers: Composition... Debugging...)</em></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[编写有弹性的组件]]></title>
            <link>/post/writing-resilient-components-zh</link>
            <guid>/post/writing-resilient-components-zh</guid>
            <description><![CDATA[指向正确道路的四项基本原则.]]></description>
            <content:encoded><![CDATA[<p>当大家开始学习 React 时，常常问到风格指南。虽然呢，项目中应用一致的规则，是个不错的主意，但是很多规则挺随意的——所以 React 对这些并没有强烈的意见。</p>
<p>你可以使用不同的类型系统，使用函数声明或者箭头函数，也可以对你的属性按字母序或任何你愿意的其他顺序来排序。</p>
<p>这样的灵活性允许在项目中 <a href="https://reactjs.org/docs/add-react-to-a-website.html">整合 React</a> 时，能应用已有的一些约定习惯。不过同时，这也会引发无休止的争论。</p>
<p><strong>_有_一些每个组件都应极力遵守的设计原则。但我不认为风格指南能很好地捕捉这些原则。接下来，我们先谈谈风格指南，然后<a href="#%E7%BC%96%E5%86%99%E6%9C%89%E5%BC%B9%E6%80%A7%E7%9A%84%E7%BB%84%E4%BB%B6">再看看真的有用的设计原则</a>。</strong></p>
<hr>
<h2>别被虚幻的问题分散了注意力</h2>
<p>在我们讨论组件的设计原则前，我想先简单说说风格指南。这不是个流行的观点，但有人得说出来！</p>
<p>在 JavaScript 社区中，有一些由 linter 强制约束的样式指南。我个人的观察是，他们会产比他们价值更多的麻烦。我算不清有多少人向我展示过一些完全有效的代码，然后跟我说 “React 提示这有问题啊！”，但这其实是由他们的 lint 配置产生的！这就导致了三个问题：</p>
<ul>
<li>
<p>人们习惯于将 linter 看作是一个过分热心又吵闹的看门人，而不是一个有用的工具。 有用的警告被风格提示的海洋淹没了。因此，人们在调试时不看 linter 的提示，错过有用的信息。此外，之前不太写 JavaScript 的人群（例如，设计人员）也因此更难使用代码。</p>
</li>
<li>
<p>对于某种模式，大家不太学着<strong>区分有效和无效的用法</strong>。例如，有一条流行的规则是，禁止在 <code>componentDidMount</code> 中调用 <code>setState</code>。但如果这个用法总是 “错的”，那 React 根本不会允许它！这就有一个合法的用例，那就是测量 DOM 节点布局——例如，定位 tooltip。我见过有人添加 <code>setTimeout</code> 来 “解决” 这条规则，这完全搞错了。</p>
</li>
<li>
<p>最终，人们采用 “执法者心态”，对那些<strong>没带来有意义变化</strong>但在代码中易于发现的地方持批评态度。“你用了函数声明，但<em>我们的</em>项目用的是箭头函数。” 每次我有强烈意愿，想要强制执行类似的规则时，仔细想想就会发现，我把个人情绪投入到了这个规则中——然后又努力让这消失。这让我陷入虚假的成就感，而丝毫没有改进我的代码。</p>
</li>
</ul>
<p>我这是在宣扬停止使用 linter 吗？ 不！</p>
<p>**通过良好的配置，linter 是一个很好的工具，它可以在 bug 出现前就能发现它们。**但它对<em>代码风格</em>的关注过多，使其变得会分散注意力。</p>
<hr>
<h2>整理你的 Lint 配置</h2>
<p>这是我建议你在周一要做的事。把你的团队叫到一起花半个小时时间，一条条过一下你们项目中启用的 lint 规则，接着问问自己：<em>“这条规则有帮我找到过 bug 吗?”</em> 如果不是，<em>关掉这条规则</em>。（你也可以用 <a href="https://www.npmjs.com/package/eslint-config-react-app"><code>eslint-config-react-app</code></a> 从头开始创建，里面不含任何代码风格的规则）</p>
<p>至少，你的团队应该有一个流程，会去删除引起干扰的规则项。不要假设一年前你或别人添加到你的 lint 配置中的任何东西，都是“最佳实践”。保持质疑，找到答案。别让任何人告诉你，你不够聪明，不能选择 lint 规则。</p>
<p><strong>那代码格式化呢？</strong> 用 <a href="https://prettier.io/">Prettier</a> 然后忘掉 “风格”。你完全不需要一个工具告诉你得在这加一个空格，如果有别的工具能为你修复它。用 linter 找 <em>bug</em>，而不是做 <em>代 码 美 学</em>。</p>
<p>当然，某些方面来说，编码风格和格式没有直接关系，但在整个项目中存在不一致时还是很恼人。</p>
<p>然而，它们中的许多都太微妙了，无法通过一条 lint 规则捕捉到。这就是为什么说，在团队成员之间<strong>建立信任</strong>，在 wiki 或简短的设计指南里分享有用的知识，是非常重要的事了。</p>
<p>不是一切都值得自动化！从 <em>实际阅读</em> 中获得的见解，这种指南中的理由可能比遵循 &quot;规则&quot; 更有价值。</p>
<p><strong>如果遵循严格的风格指南是一种分心，那到底什么才是重要的呢？</strong></p>
<p>这就是这篇文章的主题。</p>
<hr>
<h2>编写有弹性的组件</h2>
<p>不论多少缩进或按字母序排列，都不能修复糟糕的设计。因此，我不会专注于某些代码<em>看起来如何</em>，而是专注于如何让它<em>工作</em>。这有一些组件设计原则我认为是非常有用：</p>
<ol>
<li><strong><a href="#%E5%8E%9F%E5%88%99-1%EF%BC%9A%E4%B8%8D%E9%98%BB%E6%96%AD%E6%95%B0%E6%8D%AE%E6%B5%81">不阻断数据流</a></strong></li>
<li><strong><a href="#%E5%8E%9F%E5%88%99-2%EF%BC%9A%E6%97%B6%E5%88%BB%E5%87%86%E5%A4%87%E6%B8%B2%E6%9F%93">时刻准备渲染</a></strong></li>
<li><strong><a href="#%E5%8E%9F%E5%88%99-3%EF%BC%9A%E6%B2%A1%E6%9C%89%E5%8D%95%E4%BE%8B%E7%BB%84%E4%BB%B6">没有单例组件</a></strong></li>
<li><strong><a href="#%E5%8E%9F%E5%88%99-4%EF%BC%9A%E9%9A%94%E7%A6%BB%E6%9C%AC%E5%9C%B0%E7%8A%B6%E6%80%81">隔离本地状态</a></strong></li>
</ol>
<p>即使你不使用 React，对于存在单向数据流的任何 UI 组件模型，可能也能通过反复试验发现相同的原则。</p>
<hr>
<h2 id="原则-1：不阻断数据流">原则 1：不阻断数据流</h2>
<h3>渲染中不要阻断数据流</h3>
<p>当别人使用你的组件时，他们的预期是，不论传递属性如何变化, 组件都将反映这些变化：</p>
<pre   class="language-jsx"><code class="language-jsx">// isOk 也许在 state 里，随时会变化
&lt;Button color={isOk ? 'blue' : 'red'} /&gt;
</code></pre><p>通常，这是 React 默认工作的方式。如果你在 <code>Button</code> 组件中使用 <code>color</code>，你会看到从上层为该渲染提供的值：</p>
<pre   class="language-jsx"><code class="language-jsx">function Button({ color, children }) {
  return (
    // ✅ `color` 永远是新的
    &lt;button className={'Button-' + color}&gt;
      {children}
    &lt;/button&gt;
  );
}
</code></pre><p>然而，学习 React 时常见的一个错误是，把 props 复制到 state：</p>
<pre data-line="3,6,"  3,6="" class="language-jsx"><code 3,6="" class="language-jsx">class Button extends React.Component {
  state = {
    color: this.props.color
  };
  render() {
    const { color } = this.state; // 🔴 `color` 不新鲜了！
    return (
      &lt;button className={'Button-' + color}&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>这也许看起来更直观，如果你使用过 React 之外的东西。 <strong>但是，通过将 prop 复制到 state，你忽略了对它的所有更新。</strong></p>
<pre   class="language-jsx"><code class="language-jsx">// 🔴 上面的实现在更新时无法正常工作了
&lt;Button color={isOk ? 'blue' : 'red'} /&gt;
</code></pre><p>很少情况下，这样的行为 <em>是</em> 有意为之的，请确认将这样的属性取名为 <code>initialColor</code> 或 <code>defaultColor</code> 来表明组件会忽略这个属性的改变。</p>
<p>但通常你会想在你的组件中 <strong>直接读取 props</strong>，避免复制 props（或从 props 中计算得到的值) 到 state：</p>
<pre   class="language-jsx"><code class="language-jsx">function Button({ color, children }) {
  return (
    // ✅ `color` 永远是新的!
    &lt;button className={'Button-' + color}&gt;
      {children}
    &lt;/button&gt;
  );
}
</code></pre><hr>
<p>计算值是另一个大家可能会将 props 复制到 state 的场景。举例来说，想象一下 <em>按钮文字</em> 的颜色是根据 <code>color</code> 属性通过昂贵计算得来：</p>
<pre data-line="3,9,"  3,9="" class="language-jsx"><code 3,9="" class="language-jsx">class Button extends React.Component {
  state = {
    textColor: slowlyCalculateTextColor(this.props.color)
  };
  render() {
    return (
      &lt;button className={
        'Button-' + this.props.color +
        ' Button-text-' + this.state.textColor // 🔴 `color` 改变的时候就不新鲜了
      }&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>这个组件有 bug，它在 <code>color</code> 属性改变时无法重新计算 <code>this.state.textColor</code>。最简单的修复是把 <code>textColor</code> 的计算放到 <code>render</code> 方法中，然后把组件改为 <code>PureComponent</code>：</p>
<pre data-line="1,3,"  1,3="" class="language-jsx"><code 1,3="" class="language-jsx">class Button extends React.PureComponent {
  render() {
    const textColor = slowlyCalculateTextColor(this.props.color);
    return (
      &lt;button className={
        'Button-' + this.props.color +
        ' Button-text-' + textColor // ✅ 永远是新的
      }&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>问题解决了！现在当 props 改变时重新计算 <code>textColor</code>，但是在属性不变时，能避免重复进行昂贵计算。</p>
<p>然而，也许我们还能再优化一下。如果 <code>children</code> 改变了呢？很遗憾 <code>textColor</code> 在这种情况下会重复计算。我们第二次尝试可能是通过在 <code>componentDidUpdate</code> 中调用计算。</p>
<pre data-line="5-12,"  5-12="" class="language-jsx"><code 5-12="" class="language-jsx">class Button extends React.Component {
  state = {
    textColor: slowlyCalculateTextColor(this.props.color)
  };
  componentDidUpdate(prevProps) {
    if (prevProps.color !== this.props.color) {
      // 😔 额外的重复渲染
      this.setState({
        textColor: slowlyCalculateTextColor(this.props.color),
      });
    }
  }
  render() {
    return (
      &lt;button className={
        'Button-' + this.props.color +
        ' Button-text-' + this.state.textColor // ✅ 在最后一次渲染后是新的
      }&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>然而，这也意味着我们的组件在每次更新后，都有两次 render 调用。如果我们试图优化它，那也不理想。</p>
<p>你可以使用已不推荐的 <code>componentWillReceiveProps</code> 生命周期函数。然而，大家经常把 side effects 放这。这反过来又往往会给即将到来的并发渲染 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">特性像 Time Slicing 和 Suspense</a> 带来问题。而更 “安全” 的 <code>getDerivedStateFromProps</code> 又有点难用。</p>
<p>让我们退一步。实际上，我们想要 <a href="https://en.wikipedia.org/wiki/Memoization"><em>memoization</em></a>。我们有一些输入，除非输入发生变化，否则我们不想重新计算输出。</p>
<p>使用类，你可以使用<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization">帮助程序</a>完成 memoization。但是，Hooks 更进了一步，提供了一种记忆昂贵计算的内置方法：</p>
<pre data-line="2-5,"  2-5="" class="language-jsx"><code 2-5="" class="language-jsx">function Button({ color, children }) {
  const textColor = useMemo(
    () =&gt; slowlyCalculateTextColor(color),
    [color] // ✅ 除非 `color` 改变，不会重新计算
  );
  return (
    &lt;button className={'Button-' + color + ' Button-text-' + textColor}&gt;
      {children}
    &lt;/button&gt;
  );
}
</code></pre><p>这就是所以你需要的全部代码了！</p>
<p>在 class 组件中，你可以使用帮助程序类似 <a href="https://github.com/alexreardon/memoize-one"><code>memoize-one</code></a>。在函数组件中，<code>useMemo</code> Hook 提供了类似的功能。</p>
<p>现在我们看到<strong>优化昂贵的计算也不是将 props 复制到 state 的好理由</strong>。我们的渲染结果应该响应 props 的变化。</p>
<hr>
<h3>不要在 Side Effects 里阻断数据流</h3>
<p>目前为止，我们讨论了关于如何在属性变化时保持渲染结果的一致。避免复制 props 到 state 是一部分。然而，<strong>side effects（例如获取数据）也是数据流重要的一部分</strong></p>
<p>看看这个 React 组件：</p>
<pre data-line="5-7,"  5-7="" class="language-jsx"><code 5-7="" class="language-jsx">class SearchResults extends React.Component {
  state = {
    data: null
  };
  componentDidMount() {
    this.fetchResults();
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // 获取数据...
  }
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query;
  }
  render() {
    // ...
  }
}
</code></pre><p>很多 React 组件都像这样——但如果看看，会发现这有个 bug。<code>fetchResults</code> 方法使用了 <code>query</code> 属性来做数据获取：</p>
<pre data-line="2,"  2="" class="language-jsx"><code 2="" class="language-jsx">  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query;
  }
</code></pre><p>但如果 <code>query</code> 变了呢？在这个组件中，什么都不会发生。<strong>这意味着组件的 side effects 没有响应它 props 的变化</strong>。这在 React 应用中是常见 bug 的根源。</p>
<p>为了修复这个组件，我们需要：</p>
<ul>
<li>查看 <code>componentDidMount</code> 和它所调用的所有方法
<ul>
<li>在我们的例子中，就是 <code>fetchResults</code> 和 <code>getFetchUrl</code></li>
</ul>
</li>
<li>写下所有被他们使用的 props 和 state
<ul>
<li>在我们的例子中，就是 <code>this.props.query</code></li>
</ul>
</li>
<li>确保不论 props 如何变化，都重新执行 side effect
<ul>
<li>我们可以通过 <code>componentDidUpdate</code> 方法实现</li>
</ul>
</li>
</ul>
<pre data-line="8-12,18,"  8-12,18="" class="language-jsx"><code 8-12,18="" class="language-jsx">class SearchResults extends React.Component {
  state = {
    data: null
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.query !== this.props.query) { // ✅ 重新获取数据
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // 获取数据...
  }
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query; // ✅ 更新也处理好了
  }
  render() {
    // ...
  }
}
</code></pre><p>现在我们的代码能响应所有的 props 变化了，甚至是 side effects。</p>
<p>然而，牢记不要再搞砸了，这真是个挑战。例如，也许又加了 <code>currentPage</code> 到 state，然后在 <code>getFetchUrl</code> 中使用了它：</p>
<pre data-line="4,21,"  4,21="" class="language-jsx"><code 4,21="" class="language-jsx">class SearchResults extends React.Component {
  state = {
    data: null,
    currentPage: 0,
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.query !== this.props.query) {
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // 获取数据...
  }
  getFetchUrl() {
    return (
      'http://myapi/results?query' + this.props.query +
      '&amp;page=' + this.state.currentPage // 🔴 更新被忽略了
    );
  }
  render() {
    // ...
  }
}
</code></pre><p>哎呀，我们的代码又有 bug 了，这是因为 side effect 没有响应 <code>currentPage</code> 的变化。</p>
<p><strong>props 和 state 是 React 数据流的一部分。在这个数据流中，rendering 和 side effects 都应响应它们的变化，而不是忽略它们！</strong></p>
<p>为了修复这个问题，可以重复上面的步骤：</p>
<ul>
<li>查看 <code>componentDidMount</code> 和它所调用的所有方法
<ul>
<li>在我们的例子中，就是 <code>fetchResults</code> 和 <code>getFetchUrl</code></li>
</ul>
</li>
<li>写下所有被他们使用的 props 和 state
<ul>
<li>在我们的例子中，就是 <code>this.props.query</code> <strong>和 <code>this.state.currentPage</code></strong></li>
</ul>
</li>
<li>确保不论 props 如何变化，都重新执行 side effect
<ul>
<li>我们可以通过 <code>componentDidUpdate</code> 方法实现</li>
</ul>
</li>
</ul>
<p>让我们修复我们的组件，用以处理 <code>currentPage</code> 的更新吧：</p>
<pre data-line="11,24,"  11,24="" class="language-jsx"><code 11,24="" class="language-jsx">class SearchResults extends React.Component {
  state = {
    data: null,
    currentPage: 0,
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps, prevState) {
    if (
      prevState.currentPage !== this.state.currentPage || // ✅ 更新后重新获取数据
      prevProps.query !== this.props.query
    ) {
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // 获取数据...
  }
  getFetchUrl() {
    return (
      'http://myapi/results?query' + this.props.query +
      '&amp;page=' + this.state.currentPage // ✅ 更新被处理了
    );
  }
  render() {
    // ...
  }
}
</code></pre><p>**如果我们能够以某种方式自动捕捉到这些错误，那不是很好吗？**难道没有什么 linter 可以帮助我们处理这事吗？</p>
<hr>
<p>遗憾的是，自动检查类组件的一致性太困难了。任何方法都可以调用任何其他方法。静态分析来自 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 的调用充满了误报。</p>
<p>但是，<em>可能</em> 可以设计一个 <em>能</em> 被静态分析的一致性 API。<a href="/a-complete-guide-to-useeffect/">React <code>useEffect</code> Hook</a> 就是这样 API 的一个例子：</p>
<pre data-line="13-14,19,"  13-14,19="" class="language-jsx"><code 13-14,19="" class="language-jsx">function SearchResults({ query }) {
  const [data, setData] = useState(null);
  const [currentPage, setCurrentPage] = useState(0);

  useEffect(() =&gt; {
    function fetchResults() {
      const url = getFetchUrl();
      // 数据获取...
    }

    function getFetchUrl() {
      return (
        'http://myapi/results?query' + query +
        '&amp;page=' + currentPage
      );
    }

    fetchResults();
  }, [currentPage, query]); // ✅ 更新后重新获取

  // ...
}
</code></pre><p>我们将逻辑 <em>放在</em> effect 中，这样可以更容易地看到<em>它从 React 数据流中依赖了哪些值</em>。这些值称为“依赖”，在我们的例子中它们是 <code>[currentPage, query]</code>。</p>
<p>注意这个“effect 依赖”数组并不是一个新概念。在类中，我们必须遍历所有方法调用，来搜索这些“依赖项”。<code>useEffect</code> API 只是显式地使用了相同的概念。</p>
<p>反过来说，这可以让我们自动验证它们：</p>
<p><img src="./useeffect.gif" alt="Demo of exhaustive-deps lint rule"></p>
<p><em>（这个 demo 来自最新推荐的 <code>exhaustive-deps</code> lint 规则，这是 <code>eslint-plugin-react-hooks</code> 其中一部分。它将不久加入到 Create React App 中）</em></p>
<p><strong>注意，无论是将组件编写为类还是函数，都必须为 effect 响应所有 props 和 state 的更新。</strong></p>
<p>使用 class API，你必须自己考虑一致性，并验证对每个相关 prop 或 state 的更改是否该由 <code>componentDidUpdate</code> 处理。否则，组件对 prop 和 state 的更改不具有弹性。这甚至不是专属于 React 的问题。它适用于任何允许你单独处理 “创建” 和 “更新” 事件的 UI 库</p>
<p><strong><code>useEffect</code> API 通过鼓励一致性来翻转默认值。</strong> 这 <a href="/a-complete-guide-to-useeffect/">可能在开始时觉得会不熟悉</a>，但这样的结果是你的组件对逻辑更改更具弹性了。由于 “依赖关系” 现在是显式的，我们可以使用 lint 规则<em>检验</em>是否一致。 我们用 linter 来捕捉 bug！</p>
<hr>
<h3>不要在优化中阻断数据流</h3>
<p>还有一种情况，你可能会意外忽略对 props 的更改。当你手动优化组件时，可能会发生这类错误。</p>
<p>注意，使用浅比较的优化方法（如 <code>PureComponent</code> 和 <code>React.memo</code>）与默认比较是安全的。</p>
<p><strong>但是，如果你尝试通过编写自己的比较方法来 “优化” 组件，你可能会错误地忘记比较函数属性：</strong></p>
<pre data-line="2-5,7,"  2-5,7="" class="language-jsx"><code 2-5,7="" class="language-jsx">class Button extends React.Component {
  shouldComponentUpdate(prevProps) {
    // 🔴 没比较 this.props.onClick
    return this.props.color !== prevProps.color;
  }
  render() {
    const onClick = this.props.onClick; // 🔴 将不响应更新
    const textColor = slowlyCalculateTextColor(this.props.color);
    return (
      &lt;button
        onClick={onClick}
        className={'Button-' + this.props.color + ' Button-text-' + textColor}&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>一开始很容易错过这个错误，因为对于类，你通常会传递一个<em>方法</em>，所以它会有相同的身份：</p>
<pre data-line="2-4,9-11,"  2-4,9-11="" class="language-jsx"><code 2-4,9-11="" class="language-jsx">class MyForm extends React.Component {
  handleClick = () =&gt; { // ✅ 总是同一个函数
    // Do something
  }
  render() {
    return (
      &lt;&gt;
        &lt;h1&gt;Hello!&lt;/h1&gt;
        &lt;Button color='green' onClick={this.handleClick}&gt;
          Press me
        &lt;/Button&gt;
      &lt;/&gt;
    )
  }
}
</code></pre><p>所以我们的优化不会<em>马上</em>被破坏。但是，它将持续 “看到” 旧的 <code>onClick</code> 值，但其他 props 不会这样：</p>
<pre data-line="6,13-15,"  6,13-15="" class="language-jsx"><code 6,13-15="" class="language-jsx">class MyForm extends React.Component {
  state = {
    isEnabled: true
  };
  handleClick = () =&gt; {
    this.setState({ isEnabled: false });
    // Do something
  }
  render() {
    return (
      &lt;&gt;
        &lt;h1&gt;Hello!&lt;/h1&gt;
        &lt;Button color='green' onClick={
          // 🔴 Button 忽略了 onClick 的更新
          this.state.isEnabled ? this.handleClick : null
        }&gt;
          Press me
        &lt;/Button&gt;
      &lt;/&gt;
    )
  }
}
</code></pre><p>在这个例子中，应该禁用按钮点击事件——但这不会发生，因为 <code>Button</code> 组件忽略了对<code>onClick</code> 属性的任何更新。</p>
<p>如果函数标识本身依赖于可能随时间变化的东西，例如本例中的 <code>draft.content</code>，这可能会让人更加困惑：</p>
<pre data-line="6-7,"  6-7="" class="language-jsx"><code 6-7="" class="language-jsx">  drafts.map(draft =&gt;
    &lt;Button
      color='blue'
      key={draft.id}
      onClick={
        // 🔴 Button 忽略了 onClick 的更新
        this.handlePublish.bind(this, draft.content)
      }&gt;
      Publish
    &lt;/Button&gt;
  )
</code></pre><p>虽然 <code>draft.content</code> 可能随着时间的推移而改变，但是我们的 <code>Button</code> 组件忽略了对<code>onClick</code> 属性的改变，所以它继续看到 <code>onClick</code> 绑定方法的 “第一个版本” 与原始的<code>draft.content</code>。</p>
<p><strong>那怎么避免这个问题？</strong></p>
<p>我建议避免手动实现 <code>shouldComponentUpdate</code> ，也要避免在 <code>React.memo()</code> 中使用自定义的比较方法。<code>React.memo</code> 中默认的浅比较会响应函数标识的更新：</p>
<pre data-line="11,"  11="" class="language-jsx"><code 11="" class="language-jsx">function Button({ onClick, color, children }) {
  const textColor = slowlyCalculateTextColor(this.props.color);
  return (
    &lt;button
      onClick={onClick}
      className={'Button-' + color + ' Button-text-' + textColor}&gt;
      {children}
    &lt;/button&gt;
  );
}
export default React.memo(Button); // ✅ 使用浅比较
</code></pre><p>在类中，<code>PureComponent</code> 也有类似的行为.</p>
<p>这确保了传递不同的函数作为 prop，始终能有效工作。</p>
<p>如果你坚持使用自定义的比较，<strong>请确保不跳过函数：</strong></p>
<pre data-line="5,"  5="" class="language-jsx"><code 5="" class="language-jsx">  shouldComponentUpdate(prevProps) {
    // ✅ 比较 this.props.onClick
    return (
      this.props.color !== prevProps.color ||
      this.props.onClick !== prevProps.onClick
    );
  }
</code></pre><p>正如之前提到的，在类组件中很容易错过这个问题，因为方法标识通常是稳定的（但并非总是如此——而这就是 debug 困难的地方）。有了Hooks，情况不同了：</p>
<ol>
<li>function 在<em>每个渲染</em>中都不同，所以你能<a href="https://github.com/facebook/react/issues/14972#issuecomment-468280039">马上</a>发现这个问题</li>
<li>通过 <code>useCallback</code> 和 <code>useContext</code>，你能 <a href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down">避免往下传递函数</a>。这让你优化渲染时不用太担心函数的问题。</li>
</ol>
<hr>
<p>总结一下这部分，<strong>不要阻断数据流！</strong></p>
<p>无论何时使用 props 和 state，请考虑如果它们发生变化会发生什么。在大多数情况下，组件不应以不同方式处理初始渲染和更新流程。这使它能够适应逻辑上的变化。</p>
<p>对于类，在生命周期方法中使用 props 和 state 时很容易忘记更新。Hooks 推动你做正确的事情——但是如果你不习惯于这样做，它会需要一些心理调整。</p>
<hr>
<h2>原则 2：时刻准备渲染</h2>
<p>React 组件使你可以不用花太长时间就能编写渲染代码。你描述了在任何时刻 UI <em>应该</em> 如何，接着 React 去完成。好好利用那个模型！</p>
<p>不要试图在组件行为中，假设任何不必要的时序信息。<strong>你的组件应该随时可以重新渲染。</strong></p>
<p>违背这个原则的方式是什么样的？React 让这没那么容易发生——但你可以使用传统的<code>componentWillReceiveProps</code> 生命周期方法来实现它：</p>
<pre data-line="5-8,"  5-8="" class="language-jsx"><code 5-8="" class="language-jsx">class TextInput extends React.Component {
  state = {
    value: ''
  };
  // 🔴 每次父节点渲染时重置本地状态
  componentWillReceiveProps(nextProps) {
    this.setState({ value: nextProps.value });
  }
  handleChange = (e) =&gt; {
    this.setState({ value: e.target.value });
  };
  render() {
    return (
      &lt;input
        value={this.state.value}
        onChange={this.handleChange}
      /&gt;
    );
  }
}
</code></pre><p>在这个例子中，我们将 <code>value</code> 放在 state 里，但我们 <em>也</em> 从 props 接收 <code>value</code>。每当我们 “接收新 props” 时，就会重置状态中的 <code>value</code>。</p>
<p><strong>这种模式的问题在于它完全依赖于偶然的时间。</strong></p>
<p>也许今天这个组件的父级很少更新，我们的 <code>TextInput</code> 仅在重要事件发生时 “接收 props”，比如保存表单。</p>
<p>但明天你可能会向 <code>TextInput</code> 的父组件加一些动画。如果父组件经常重渲染，它将 <a href="https://codesandbox.io/s/m3w9zn1z8x">“污染”</a> 子组件的状态！你可以在 <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">“你可能不需要派生状态”</a> 中阅读有关此问题的更多信息。</p>
<p><strong>所以该怎么修复呢？</strong></p>
<p>首先，我们得调整一下心理，需要停止将 “接收 props” 视为与 “渲染” 不同的东西。 由父组件引起的重渲染不应与由本地状态更改引起的重渲染不同。<strong>组件应该具有弹性，能适应更少或更频繁地渲染，否则它们与特定父组件存在过多耦合。</strong></p>
<p><em>(<a href="https://codesandbox.io/s/m3w9zn1z8x">这个 demo</a> 给我们展示了重渲染会如何毁坏脆弱的组件)</em></p>
<p>当你真正想从 props 派生 state 时，尽管有一些<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions">不同</a>的<a href="https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops">解决方案</a>，通常你应该使用一个完全受控制的组件：</p>
<pre   class="language-jsx"><code class="language-jsx">// Option 1: Fully controlled component.
function TextInput({ value, onChange }) {
  return (
    &lt;input
      value={value}
      onChange={onChange}
    /&gt;
  );
}
</code></pre><p>或者使用一个不受控的组件，加上 key 来重置它：</p>
<pre   class="language-jsx"><code class="language-jsx">// Option 2: Fully uncontrolled component.
function TextInput() {
  const [value, setValue] = useState('');
  return (
    &lt;input
      value={value}
      onChange={e =&gt; setValue(e.target.value)}
    /&gt;
  );
}

// 之后我们能通过更改 key 来重置内部 state：
&lt;TextInput key={formId} /&gt;
</code></pre><p>本节的内容是，组件不应该因为它或其父组件频繁地重渲染而坏掉。如果想避免使用传统的 <code>componentWillReceiveProps</code> 生命周期方法，React API 的设计，可以轻松实现这个目的。</p>
<p>要对你的组件进行压力测试，可以将这段代码临时添加到它的父组件：</p>
<pre data-line="2,"  2="" class="language-js"><code 2="" class="language-js">componentDidMount() {
  // 之后别忘了删除这行！
  setInterval(() =&gt; this.forceUpdate(), 100);
}
</code></pre><p><strong>可别把这段代码保留在项目里</strong>——这只是用来检查父组件重渲染的频率超出预期时，会发生什么的快速方法。它不应该损坏子组件！</p>
<hr>
<p>你可能会想：“那我在 props 改变时重置 state，再使用 <code>PureComponent</code> 来避免不必要的重渲染”。</p>
<p>这段代码应该能工作，对吧？</p>
<pre data-line="1-2,"  1-2="" class="language-jsx"><code 1-2="" class="language-jsx">// 🤔 应该阻止不必要的重渲染... 对吧?
class TextInput extends React.PureComponent {
  state = {
    value: ''
  };
  // 🔴 在父组件更新时重置本地 state
  componentWillReceiveProps(nextProps) {
    this.setState({ value: nextProps.value });
  }
  handleChange = (e) =&gt; {
    this.setState({ value: e.target.value });
  };
  render() {
    return (
      &lt;input
        value={this.state.value}
        onChange={this.handleChange}
      /&gt;
    );
  }
}
</code></pre><p>乍一看，这个组件似乎解决了父级重渲染时 “污染” state 的问题。毕竟，如果 props 是相同的，我们会跳过更新——所以 <code>componentWillReceiveProps</code> 不会被调用。</p>
<p>但是这都是幻觉。**这个组件对_实际_的 prop 更改仍然不具备弹性。**例如，如果我们添加<em>另一个</em>经常变化的 prop，就像用来做动画的 <code>style</code>，我们还是会 “丢失” 内部状态：</p>
<pre data-line="2,"  2="" class="language-jsx"><code 2="" class="language-jsx">&lt;TextInput
  style={{opacity: someValueFromState}}
  value={
    // 🔴 componentWillReceiveProps in TextInput
    // resets to this value on every animation tick.
    value
  }
/&gt;
</code></pre><p>所以这个方法仍然存在缺陷。我们可以看到各种优化，例如 <code>PureComponent</code>、<code>shouldComponentUpdate</code> 和 <code>React.memo</code>，它们不应该用于控制<em>行为</em>。只有提高<em>性能</em>的场景下，去使用它们。如果删除优化就会_破坏_某个组件，那么它就太脆弱了。</p>
<p>这里的解决方案和之前提到的一样。不要将 “接受 props” 视作特殊的事件。避免 “同步” props 和 state。大部分情况下，每个值都应该是完全控制的（通过 props），或者完全不受控制的（在本地 state 里）。可以的话，避免<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions">派生 state</a>。<strong>当然，时刻准备渲染！</strong></p>
<hr>
<h2>原则 3：没有单例组件</h2>
<p>有时我们假设某个组件只会显示一次，如导航栏。在一段时间内这也许是对的，然而，这种假设导致的设计问题，常常会在后期显现。</p>
<p>例如，你可能需要在路由变化后，两个 <code>Page</code> 组件切换<em>间</em>实现动画——前一个 <code>Page</code> 和下一个 <code>Page</code>。它们都需要在动画期间被加载。但是，你可能会发现，每个组件都假定它是屏幕上唯一的 <code>Page</code>。</p>
<p>要重现这类问题也很容易，试试渲染你的应用两次：</p>
<pre data-line="3,4,"  3,4="" class="language-jsx"><code 3,4="" class="language-jsx">ReactDOM.render(
  &lt;&gt;
    &lt;MyApp /&gt;
    &lt;MyApp /&gt;
  &lt;/&gt;,
  document.getElementById('root')
);
</code></pre><p>到处点击看看。（你可能需要为这个实验调整一些 CSS 样式）</p>
<p>**你的应用仍然正常运行吗？**或者你是否看到奇怪的崩溃和错误？偶尔对复杂组件进行压力测试是个好主意，可以确保组件存在多个拷贝时不会相互冲突。</p>
<p>我自己写过几次有问题的代码，例如在 <code>componentWillUnmount</code> 中执行全局状态 “清理”：</p>
<pre data-line="2-3,"  2-3="" class="language-jsx"><code 2-3="" class="language-jsx">componentWillUnmount() {
  // 重置 Redux store 里的一些东西
  this.props.resetForm();
}
</code></pre><p>当然，如果页面上有两个这样的组件，卸载其中一个组件可能会破坏另一个组件。在 <em>mount</em> 后重置 “全局” 状态也不好：</p>
<pre data-line="2-3,"  2-3="" class="language-jsx"><code 2-3="" class="language-jsx">componentDidMount() {
  // 重置 Redux store 里的一些东西
  this.props.resetForm();
}
</code></pre><p>在这情况下， <em>挂载</em> 第二个 form 就会破坏前一个。</p>
<p>这些模式是检测组件是否脆弱的好指标。<strong><em>显示</em> 或 <em>隐藏</em> 一颗树，不应该破坏树之外的组件。</strong></p>
<p>无论你是否有计划将这个组件渲染两次，从长远来看，解决这些问题是值得的。它将引导你进行更具弹性的设计。</p>
<hr>
<h2>原则 4：隔离本地状态</h2>
<p>假设有一个 <code>POST</code> 社交组件，它有一个 <code>Comment</code> 列表（可扩展）和一个 <code>NewComment</code> 输入框。</p>
<p>React 组件可能有本地状态。但是哪个状态真的是自己的呢？帖子内容本身是否为本地状态？评论列表呢？或者评论流的记录？或评论框里输入的值？</p>
<p>如果你习惯于将所有内容都放入 “状态管理”，那么可能很难回答这个问题。所以这有一个简单的决定方式。</p>
<p><strong>如果你不确定某个状态是否属于本地，请问自己：“如果此组件呈现两次，交互是否应反映在另一个副本中？” 只要答案为“否”，那你就找到本地状态了。</strong></p>
<p>For example, imagine we rendered the same <code>Post</code> twice. Let’s look at different things inside of it that can change.<br>
例如，假设我们两次渲染相同的 <code>Post</code>。让我们看一下哪些内容会更新。</p>
<ul>
<li>
<p><em>发布内容</em> ：我们希望在一棵树中编辑帖子，在另一棵树中也更新。因此，它可能<strong>不是</strong> <code>Post</code> 组件的本地状态。（相反，帖子内容可能存在于 Apollo、Relay 或 Redux等缓存中）</p>
</li>
<li>
<p><em>评论列表</em> ：这与帖子内容类似。我们希望在一棵树中添加一条新注释，以反映在另一棵树中。理想情况下，我们会为它使用某种缓存，而 <strong>不应该是</strong> 我们 <code>Post</code> 的本地状态。</p>
</li>
<li>
<p><em>被展开的评论</em>：如果在一棵树中展开评论也会在另一棵树中展开，这有点奇怪。在这种情况下，我们与特定的 <code>Comment</code> <em>UI 元素</em> 进行交互，而不是抽象的 “评论实体”。因此，“是否已展开” <strong>应该</strong> 是 <code>Comment</code> 的本地状态。</p>
</li>
<li>
<p><em>输入的新评论的值</em>：如果在一个输入框中输入评论，也会更新到另一个树中的输入框，这也有点奇怪。除非输入框明确地组合在一起，否则通常人们期望它们是独立的。所以输入值 <strong>应该</strong> 是 <code>NewComment</code> 组件的本地状态。</p>
</li>
</ul>
<p>我不建议对这些规则进行教条式的解释。当然，在一个简单的应用程序中，你可能希望使用本地状态来处理所有事情，包括 “缓存”。我只是谈论在<a href="/the-elements-of-ui-engineering/">第一原则</a>下，理想状态的用户体验。</p>
<p><strong>别把该本地的状态全局化了</strong> 这涉及到我们的 “弹性” 主题：组件之间发生的意外同步更少。作为奖励，这<em>也</em>修复了一大类性能问题。当你的 state 在正确的地方时，“过度渲染” 都不成问题了。</p>
<hr>
<h2>回顾</h2>
<p>让我们再一次回顾一下这些原则：</p>
<ol>
<li><strong><a href="#%E5%8E%9F%E5%88%99-1%EF%BC%9A%E4%B8%8D%E9%98%BB%E6%96%AD%E6%95%B0%E6%8D%AE%E6%B5%81">不阻断数据流</a></strong> props 和 state 可能会更新，组件应该处理好这些更新，不论什么时候。</li>
<li><strong><a href="#%E5%8E%9F%E5%88%99-2%EF%BC%9A%E6%97%B6%E5%88%BB%E5%87%86%E5%A4%87%E6%B8%B2%E6%9F%93">时刻准备渲染</a></strong> 一个组件不应该被或多或少的渲染而损坏。</li>
<li><strong><a href="#%E5%8E%9F%E5%88%99-3%EF%BC%9A%E6%B2%A1%E6%9C%89%E5%8D%95%E4%BE%8B%E7%BB%84%E4%BB%B6">没有单例组件</a></strong> 即使组件只渲染一次，但通过设计让它渲染两次也不会被破坏，是更好了。</li>
<li><strong><a href="#%E5%8E%9F%E5%88%99-4%EF%BC%9A%E9%9A%94%E7%A6%BB%E6%9C%AC%E5%9C%B0%E7%8A%B6%E6%80%81">隔离本地状态</a></strong> 想想哪个状态是特定 UI 展示下的本地状态——并且除非必要，不要将该状态提升到更高的地方。</li>
</ol>
<p><strong>这些原则能帮助你编写<a href="/optimized-for-change/">针对更新而优化</a>的组件。这让添加，更改和删除那些组件更容易。</strong></p>
<p>重要的是，一旦我们的组件具有了弹性，那就可以再回过头，到是否应按字母排序的紧迫困境中去了。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Writing Resilient Components]]></title>
            <link>/post/writing-resilient-components</link>
            <guid>/post/writing-resilient-components</guid>
            <description><![CDATA[Four principles to set you on the right path.]]></description>
            <content:encoded><![CDATA[<p>When people start learning React, they often ask for a style guide. While it’s a good idea to have some consistent rules applied across a project, a lot of them are arbitrary — and so React doesn’t have a strong opinion about them.</p>
<p>You can use different type systems, prefer function declarations or arrow functions, sort your props in alphabetical order or in an order you find pleasing.</p>
<p>This flexibility allows <a href="https://reactjs.org/docs/add-react-to-a-website.html">integrating React</a> into projects with existing conventions. But it also invites endless debates.</p>
<p><strong>There <em>are</em> important design principles that every component should strive to follow. But I don’t think style guides capture those principles well. We’ll talk about style guides first, and then <a href="#writing-resilient-components">look at the principles that really <em>are</em> useful</a>.</strong></p>
<hr>
<h2>Don’t Get Distracted by Imaginary Problems</h2>
<p>Before we talk about component design principles, I want to say a few words about style guides. This isn’t a popular opinion but someone needs to say it!</p>
<p>In the JavaScript community, there are a few strict opinionated style guides enforced by a linter. My personal observation is that they tend to create more friction than they’re worth. I can’t count how many times somebody showed me some absolutely valid code and said “React complains about this”, but it was their lint config complaining! This leads to three issues:</p>
<ul>
<li>
<p>People get used to seeing the linter as an <strong>overzealous noisy gatekeeper</strong> rather than a helpful tool. Useful warnings are drowned out by a sea of style nits. As a result, people don’t scan the linter messages while debugging, and miss helpful tips. Additionally, people who are less used to writing JavaScript (for example, designers) have a harder time working with the code.</p>
</li>
<li>
<p>People don’t learn to <strong>differentiate between valid and invalid uses</strong> of a certain pattern. For example, there is a popular rule that forbids calling <code>setState</code> inside <code>componentDidMount</code>. But if it was always “bad”, React simply wouldn’t allow it! There is a legitimate use case for it, and that is to measure the DOM node layout — e.g. to position a tooltip. I’ve seen people “work around” this rule by adding a <code>setTimeout</code> which completely misses the point.</p>
</li>
<li>
<p>Eventually, people adopt the “enforcer mindset” and get opinionated about things that <strong>don’t bring a meaningful difference</strong> but are easy to scan for in the code. “You used a function declaration, but <em>our</em> project uses arrow functions.” Whenever I have a strong feeling about enforcing a rule like this, looking deeper reveals that I invested emotional effort into this rule — and struggle to let it go. It lulls me into a false sense of accomplishment without improving my code.</p>
</li>
</ul>
<p>Am I saying that we should stop linting? Not at all!</p>
<p><strong>With a good config, a linter is a great tool to catch bugs before they happen.</strong> It’s focusing on the <em>style</em> too much that turns it into a distraction.</p>
<hr>
<h2>Marie Kondo Your Lint Config</h2>
<p>Here’s what I suggest you to do on Monday. Gather your team for half an hour, go through every lint rule enabled in your project’s config, and ask yourself: <em>“Has this rule ever helped us catch a bug?”</em> If not, <em>turn it off.</em> (You can also start from a clean slate with <a href="https://www.npmjs.com/package/eslint-config-react-app"><code>eslint-config-react-app</code></a> which has no styling rules.)</p>
<p>At the very least, your team should have a process for removing rules that cause friction. Don’t assume that whatever you or something somebody else added to your lint config a year ago is a “best practice”. Question it and look for answers. Don’t let anyone tell you you’re not smart enough to pick your lint rules.</p>
<p><strong>But what about formatting?</strong> Use <a href="https://prettier.io/">Prettier</a> and forget about the “style nits”. You don’t need a tool to shout at you for putting an extra space if another tool can fix it for you. Use the linter to find <em>bugs</em>, not enforcing the <em>a e s t h e t i c s</em>.</p>
<p>Of course, there are aspects of the coding style that aren’t directly related to formatting but can still be annoying when inconsistent across the project.</p>
<p>However, many of them are too subtle to catch with a lint rule anyway. This is why it’s important to <strong>build trust</strong> between the team members, and to share useful learnings in the form of a wiki page or a short design guide.</p>
<p>Not everything is worth automating! The insights gained from <em>actually reading</em> the rationale in such a guide can be more valuable than following the “rules”.</p>
<p><strong>But if following a strict style guide is a distraction, what’s actually important?</strong></p>
<p>That’s the topic of this post.</p>
<hr>
<h2>Writing Resilient Components</h2>
<p>No amount of indentation or sorting imports alphabetically can fix a broken design. So instead of focusing on how some code <em>looks</em>, I will focus on how it <em>works</em>. There’s a few component design principles that I find very helpful:</p>
<ol>
<li><strong><a href="#principle-1-dont-stop-the-data-flow">Don’t stop the data flow</a></strong></li>
<li><strong><a href="#principle-2-always-be-ready-to-render">Always be ready to render</a></strong></li>
<li><strong><a href="#principle-3-no-component-is-a-singleton">No component is a singleton</a></strong></li>
<li><strong><a href="#principle-4-keep-the-local-state-isolated">Keep the local state isolated</a></strong></li>
</ol>
<p>Even if you don’t use React, you’ll likely discover the same principles by trial and error for any UI component model with unidirectional data flow.</p>
<hr>
<h2>Principle 1: Don’t Stop the Data Flow</h2>
<h3>Don’t Stop the Data Flow in Rendering</h3>
<p>When somebody uses your component, they expect that they can pass different props to it over time, and that the component will reflect those changes:</p>
<pre   class="language-jsx"><code class="language-jsx">// isOk might be driven by state and can change at any time
&lt;Button color={isOk ? 'blue' : 'red'} /&gt;
</code></pre><p>In general, this is how React works by default. If you use a <code>color</code> prop inside a <code>Button</code> component, you’ll see the value provided from above for that render:</p>
<pre   class="language-jsx"><code class="language-jsx">function Button({ color, children }) {
  return (
    // ✅ `color` is always fresh!
    &lt;button className={'Button-' + color}&gt;
      {children}
    &lt;/button&gt;
  );
}
</code></pre><p>However, a common mistake when learning React is to copy props into state:</p>
<pre data-line="3,6,"  3,6="" class="language-jsx"><code 3,6="" class="language-jsx">class Button extends React.Component {
  state = {
    color: this.props.color
  };
  render() {
    const { color } = this.state; // 🔴 `color` is stale!
    return (
      &lt;button className={'Button-' + color}&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>This might seem more intuitive at first if you used classes outside of React. <strong>However, by copying a prop into state you’re ignoring all updates to it.</strong></p>
<pre   class="language-jsx"><code class="language-jsx">// 🔴 No longer works for updates with the above implementation
&lt;Button color={isOk ? 'blue' : 'red'} /&gt;
</code></pre><p>In the rare case that this behavior <em>is</em> intentional, make sure to call that prop <code>initialColor</code> or <code>defaultColor</code> to clarify that changes to it are ignored.</p>
<p>But usually you’ll want to <strong>read the props directly in your component</strong> and avoid copying props (or anything computed from the props) into state:</p>
<pre   class="language-jsx"><code class="language-jsx">function Button({ color, children }) {
  return (
    // ✅ `color` is always fresh!
    &lt;button className={'Button-' + color}&gt;
      {children}
    &lt;/button&gt;
  );
}
</code></pre><hr>
<p>Computed values are another reason people sometimes attempt to copy props into state. For example, imagine that we determined the <em>button text</em> color based on an expensive computation with background <code>color</code> as an argument:</p>
<pre data-line="3,9,"  3,9="" class="language-jsx"><code 3,9="" class="language-jsx">class Button extends React.Component {
  state = {
    textColor: slowlyCalculateTextColor(this.props.color)
  };
  render() {
    return (
      &lt;button className={
        'Button-' + this.props.color +
        ' Button-text-' + this.state.textColor // 🔴 Stale on `color` prop updates
      }&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>This component is buggy because it doesn’t recalculate <code>this.state.textColor</code> on the <code>color</code> prop change. The easiest fix would be to move the <code>textColor</code> calculation into the <code>render</code> method, and make this a <code>PureComponent</code>:</p>
<pre data-line="1,3,"  1,3="" class="language-jsx"><code 1,3="" class="language-jsx">class Button extends React.PureComponent {
  render() {
    const textColor = slowlyCalculateTextColor(this.props.color);
    return (
      &lt;button className={
        'Button-' + this.props.color +
        ' Button-text-' + textColor // ✅ Always fresh
      }&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>Problem solved! Now if props change, we'll recalculate <code>textColor</code>, but we avoid the expensive computation on the same props.</p>
<p>However, we might want to optimize it further. What if it’s the <code>children</code> prop that changed? It seems unfortunate to recalculate the <code>textColor</code> in that case. Our second attempt might be to invoke the calculation in <code>componentDidUpdate</code>:</p>
<pre data-line="5-12,"  5-12="" class="language-jsx"><code 5-12="" class="language-jsx">class Button extends React.Component {
  state = {
    textColor: slowlyCalculateTextColor(this.props.color)
  };
  componentDidUpdate(prevProps) {
    if (prevProps.color !== this.props.color) {
      // 😔 Extra re-render for every update
      this.setState({
        textColor: slowlyCalculateTextColor(this.props.color),
      });
    }
  }
  render() {
    return (
      &lt;button className={
        'Button-' + this.props.color +
        ' Button-text-' + this.state.textColor // ✅ Fresh on final render
      }&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>However, this would mean our component does a second re-render after every change. That’s not ideal either if we’re trying to optimize it.</p>
<p>You could use the legacy <code>componentWillReceiveProps</code> lifecycle for this. However, people often put side effects there too. That, in turn, often causes problems for the upcoming Concurrent Rendering <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">features like Time Slicing and Suspense</a>. And the “safer” <code>getDerivedStateFromProps</code> method is clunky.</p>
<p>Let’s step back for a second. Effectively, we want <a href="https://en.wikipedia.org/wiki/Memoization"><em>memoization</em></a>. We have some inputs, and we don’t want to recalculate the output unless the inputs change.</p>
<p>With a class, you could use a <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization">helper</a> for memoization. However, Hooks take this a step further, giving you a built-in way to memoize expensive computations:</p>
<pre data-line="2-5,"  2-5="" class="language-jsx"><code 2-5="" class="language-jsx">function Button({ color, children }) {
  const textColor = useMemo(
    () =&gt; slowlyCalculateTextColor(color),
    [color] // ✅ Don’t recalculate until `color` changes
  );
  return (
    &lt;button className={'Button-' + color + ' Button-text-' + textColor}&gt;
      {children}
    &lt;/button&gt;
  );
}
</code></pre><p>That’s all the code you need!</p>
<p>In a class component, you can use a helper like <a href="https://github.com/alexreardon/memoize-one"><code>memoize-one</code></a> for that. In a function component, <code>useMemo</code> Hook gives you similar functionality.</p>
<p>Now we see that <strong>even optimizing expensive computations isn’t a good reason to copy props into state.</strong> Our rendering result should respect changes to props.</p>
<hr>
<h3>Don’t Stop the Data Flow in Side Effects</h3>
<p>So far, we’ve talked about how to keep the rendering result consistent with prop changes. Avoiding copying props into state is a part of that. However, it is important that <strong>side effects (e.g. data fetching) are also a part of the data flow</strong>.</p>
<p>Consider this React component:</p>
<pre data-line="5-7,"  5-7="" class="language-jsx"><code 5-7="" class="language-jsx">class SearchResults extends React.Component {
  state = {
    data: null
  };
  componentDidMount() {
    this.fetchResults();
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Do the fetching...
  }
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query;
  }
  render() {
    // ...
  }
}
</code></pre><p>A lot of React components are like this — but if we look a bit closer, we'll notice a bug. The <code>fetchResults</code> method uses the <code>query</code> prop for data fetching:</p>
<pre data-line="2,"  2="" class="language-jsx"><code 2="" class="language-jsx">  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query;
  }
</code></pre><p>But what if the <code>query</code> prop changes? In our component, nothing will happen. <strong>This means our component’s side effects don’t respect changes to its props.</strong> This is a very common source of bugs in React applications.</p>
<p>In order to fix our component, we need to:</p>
<ul>
<li>Look at <code>componentDidMount</code> and every method called from it.
<ul>
<li>In our example, that’s <code>fetchResults</code> and <code>getFetchUrl</code>.</li>
</ul>
</li>
<li>Write down all props and state used by those methods.
<ul>
<li>In our example, that’s <code>this.props.query</code>.</li>
</ul>
</li>
<li>Make sure that whenever those props change, we re-run the side effect.
<ul>
<li>We can do this by adding the <code>componentDidUpdate</code> method.</li>
</ul>
</li>
</ul>
<pre data-line="8-12,18,"  8-12,18="" class="language-jsx"><code 8-12,18="" class="language-jsx">class SearchResults extends React.Component {
  state = {
    data: null
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.query !== this.props.query) { // ✅ Refetch on change
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Do the fetching...
  }
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query; // ✅ Updates are handled
  }
  render() {
    // ...
  }
}
</code></pre><p>Now our code respects all changes to props, even for side effects.</p>
<p>However, it’s challenging to remember not to break it again. For example, we might add <code>currentPage</code> to the local state, and use it in <code>getFetchUrl</code>:</p>
<pre data-line="4,21,"  4,21="" class="language-jsx"><code 4,21="" class="language-jsx">class SearchResults extends React.Component {
  state = {
    data: null,
    currentPage: 0,
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.query !== this.props.query) {
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Do the fetching...
  }
  getFetchUrl() {
    return (
      'http://myapi/results?query' + this.props.query +
      '&amp;page=' + this.state.currentPage // 🔴 Updates are ignored
    );
  }
  render() {
    // ...
  }
}
</code></pre><p>Alas, our code is again buggy because our side effect doesn’t respect changes to <code>currentPage</code>.</p>
<p><strong>Props and state are a part of the React data flow. Both rendering and side effects should reflect changes in that data flow, not ignore them!</strong></p>
<p>To fix our code, we can repeat the steps above:</p>
<ul>
<li>Look at <code>componentDidMount</code> and every method called from it.
<ul>
<li>In our example, that’s <code>fetchResults</code> and <code>getFetchUrl</code>.</li>
</ul>
</li>
<li>Write down all props and state used by those methods.
<ul>
<li>In our example, that’s <code>this.props.query</code> <strong>and <code>this.state.currentPage</code></strong>.</li>
</ul>
</li>
<li>Make sure that whenever those props change, we re-run the side effect.
<ul>
<li>We can do this by changing the <code>componentDidUpdate</code> method.</li>
</ul>
</li>
</ul>
<p>Let’s fix our component to handle updates to the <code>currentPage</code> state:</p>
<pre data-line="11,24,"  11,24="" class="language-jsx"><code 11,24="" class="language-jsx">class SearchResults extends React.Component {
  state = {
    data: null,
    currentPage: 0,
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps, prevState) {
    if (
      prevState.currentPage !== this.state.currentPage || // ✅ Refetch on change
      prevProps.query !== this.props.query
    ) {
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Do the fetching...
  }
  getFetchUrl() {
    return (
      'http://myapi/results?query' + this.props.query +
      '&amp;page=' + this.state.currentPage // ✅ Updates are handled
    );
  }
  render() {
    // ...
  }
}
</code></pre><p><strong>Wouldn’t it be nice if we could somehow automatically catch these mistakes?</strong> Isn’t that something a linter could help us with?</p>
<hr>
<p>Unfortunately, automatically checking a class component for consistency is too difficult. Any method can call any other method. Statically analyzing calls from <code>componentDidMount</code> and <code>componentDidUpdate</code> is fraught with false positives.</p>
<p>However, one <em>could</em> design an API that <em>can</em> be statically analyzed for consistency. The <a href="/a-complete-guide-to-useeffect/">React <code>useEffect</code> Hook</a> is an example of such API:</p>
<pre data-line="13-14,19,"  13-14,19="" class="language-jsx"><code 13-14,19="" class="language-jsx">function SearchResults({ query }) {
  const [data, setData] = useState(null);
  const [currentPage, setCurrentPage] = useState(0);

  useEffect(() =&gt; {
    function fetchResults() {
      const url = getFetchUrl();
      // Do the fetching...
    }

    function getFetchUrl() {
      return (
        'http://myapi/results?query' + query +
        '&amp;page=' + currentPage
      );
    }

    fetchResults();
  }, [currentPage, query]); // ✅ Refetch on change

  // ...
}
</code></pre><p>We put the logic <em>inside</em> of the effect, and that makes it easier to see <em>which values from the React data flow</em> it depends on. These values are called “dependencies”, and in our example they are <code>[currentPage, query]</code>.</p>
<p>Note how this array of “effect dependencies” isn’t really a new concept. In a class, we had to search for these “dependencies” through all the method calls. The <code>useEffect</code> API just makes the same concept explicit.</p>
<p>This, in turn, lets us validate them automatically:</p>
<p><img src="./useeffect.gif" alt="Demo of exhaustive-deps lint rule"></p>
<p><em>(This is a demo of the new recommended <code>exhaustive-deps</code> lint rule which is a part of <code>eslint-plugin-react-hooks</code>. It will soon be included in Create React App.)</em></p>
<p><strong>Note that it is important to respect all prop and state updates for effects regardless of whether you’re writing component as a  class or a function.</strong></p>
<p>With the class API, you have to think about consistency yourself, and verify that changes to every relevant prop or state are handled by <code>componentDidUpdate</code>. Otherwise, your component is not resilient to prop and state changes. This is not even a React-specific problem. It applies to any UI library that lets you handle “creation” and “updates” separately.</p>
<p><strong>The <code>useEffect</code> API flips the default by encouraging consistency.</strong> This <a href="/a-complete-guide-to-useeffect/">might feel unfamiliar at first</a>, but as a result your component becomes more resilient to changes in the logic. And since the “dependencies” are now explicit, we can <em>verify</em> the effect is consistent using a lint rule. We’re using a linter to catch bugs!</p>
<hr>
<h3>Don’t Stop the Data Flow in Optimizations</h3>
<p>There's one more case where you might accidentally ignore changes to props. This mistake can occur when you’re manually optimizing your components.</p>
<p>Note that optimization approaches that use shallow equality like <code>PureComponent</code> and <code>React.memo</code> with the default comparison are safe.</p>
<p><strong>However, if you try to “optimize” a component by writing your own comparison, you may mistakenly forget to compare function props:</strong></p>
<pre data-line="2-5,7,"  2-5,7="" class="language-jsx"><code 2-5,7="" class="language-jsx">class Button extends React.Component {
  shouldComponentUpdate(prevProps) {
    // 🔴 Doesn't compare this.props.onClick 
    return this.props.color !== prevProps.color;
  }
  render() {
    const onClick = this.props.onClick; // 🔴 Doesn't reflect updates
    const textColor = slowlyCalculateTextColor(this.props.color);
    return (
      &lt;button
        onClick={onClick}
        className={'Button-' + this.props.color + ' Button-text-' + textColor}&gt;
        {this.props.children}
      &lt;/button&gt;
    );
  }
}
</code></pre><p>It is easy to miss this mistake at first because with classes, you’d usually pass a <em>method</em> down, and so it would have the same identity anyway:</p>
<pre data-line="2-4,9-11,"  2-4,9-11="" class="language-jsx"><code 2-4,9-11="" class="language-jsx">class MyForm extends React.Component {
  handleClick = () =&gt; { // ✅ Always the same function
    // Do something
  }
  render() {
    return (
      &lt;&gt;
        &lt;h1&gt;Hello!&lt;/h1&gt;
        &lt;Button color='green' onClick={this.handleClick}&gt;
          Press me
        &lt;/Button&gt;
      &lt;/&gt;
    )
  }
}
</code></pre><p>So our optimization doesn’t break <em>immediately</em>. However, it will keep “seeing” the old <code>onClick</code> value if it changes over time but other props don’t:</p>
<pre data-line="6,13-15,"  6,13-15="" class="language-jsx"><code 6,13-15="" class="language-jsx">class MyForm extends React.Component {
  state = {
    isEnabled: true
  };
  handleClick = () =&gt; {
    this.setState({ isEnabled: false });
    // Do something
  }
  render() {
    return (
      &lt;&gt;
        &lt;h1&gt;Hello!&lt;/h1&gt;
        &lt;Button color='green' onClick={
          // 🔴 Button ignores updates to the onClick prop
          this.state.isEnabled ? this.handleClick : null
        }&gt;
          Press me
        &lt;/Button&gt;
      &lt;/&gt;
    )
  }
}
</code></pre><p>In this example, clicking the button should disable it — but this doesn’t happen because the <code>Button</code> component ignores any updates to the <code>onClick</code> prop.</p>
<p>This could get even more confusing if the function identity itself depends on something that could change over time, like <code>draft.content</code> in this example:</p>
<pre data-line="6-7,"  6-7="" class="language-jsx"><code 6-7="" class="language-jsx">  drafts.map(draft =&gt;
    &lt;Button
      color='blue'
      key={draft.id}
      onClick={
        // 🔴 Button ignores updates to the onClick prop
        this.handlePublish.bind(this, draft.content)
      }&gt;
      Publish
    &lt;/Button&gt;
  )
</code></pre><p>While <code>draft.content</code> could change over time, our <code>Button</code> component ignored change to the <code>onClick</code> prop so it continues to see the “first version” of the <code>onClick</code> bound method with the original <code>draft.content</code>.</p>
<p><strong>So how do we avoid this problem?</strong></p>
<p>I recommend to avoid manually implementing <code>shouldComponentUpdate</code> and to avoid specifying a custom comparison to <code>React.memo()</code>. The default shallow comparison in <code>React.memo</code> will respect changing function identity:</p>
<pre data-line="11,"  11="" class="language-jsx"><code 11="" class="language-jsx">function Button({ onClick, color, children }) {
  const textColor = slowlyCalculateTextColor(this.props.color);
  return (
    &lt;button
      onClick={onClick}
      className={'Button-' + color + ' Button-text-' + textColor}&gt;
      {children}
    &lt;/button&gt;
  );
}
export default React.memo(Button); // ✅ Uses shallow comparison
</code></pre><p>In a class, <code>PureComponent</code> has the same behavior.</p>
<p>This ensures that passing a different function as a prop will always work.</p>
<p>If you insist on a custom comparison, <strong>make sure that you don’t skip functions:</strong></p>
<pre data-line="5,"  5="" class="language-jsx"><code 5="" class="language-jsx">  shouldComponentUpdate(prevProps) {
    // ✅ Compares this.props.onClick 
    return (
      this.props.color !== prevProps.color ||
      this.props.onClick !== prevProps.onClick
    );
  }
</code></pre><p>As I mentioned earlier, it’s easy to miss this problem in a class component because method identities are often stable (but not always — and that’s where the bugs become difficult to debug). With Hooks, the situation is a bit different:</p>
<ol>
<li>Functions are different <em>on every render</em> so you discover this problem <a href="https://github.com/facebook/react/issues/14972#issuecomment-468280039">right away</a>.</li>
<li>With <code>useCallback</code> and <code>useContext</code>, you can <a href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down">avoid passing functions deep down altogether</a>. This lets you optimize rendering without worrying about functions.</li>
</ol>
<hr>
<p>To sum up this section, <strong>don’t stop the data flow!</strong></p>
<p>Whenever you use props and state, consider what should happen if they change. In most cases, a component shouldn’t treat the initial render and updates differently. That makes it resilient to changes in the logic.</p>
<p>With classes, it’s easy to forget about updates when using props and state inside the lifecycle methods. Hooks nudge you to do the right thing — but it takes some mental adjustment if you’re not used to already doing it.</p>
<hr>
<h2>Principle 2: Always Be Ready to Render</h2>
<p>React components let you write rendering code without worrying too much about time. You describe how the UI <em>should</em> look at any given moment, and React makes it happen. Take advantage of that model!</p>
<p>Don’t try to introduce unnecessary timing assumptions into your component behavior. <strong>Your component should be ready to re-render at any time.</strong></p>
<p>How can one violate this principle? React doesn’t make it very easy — but you can do it by using the legacy <code>componentWillReceiveProps</code> lifecycle method:</p>
<pre data-line="5-8,"  5-8="" class="language-jsx"><code 5-8="" class="language-jsx">class TextInput extends React.Component {
  state = {
    value: ''
  };
  // 🔴 Resets local state on every parent render
  componentWillReceiveProps(nextProps) {
    this.setState({ value: nextProps.value });
  }
  handleChange = (e) =&gt; {
    this.setState({ value: e.target.value });
  };
  render() {
    return (
      &lt;input
        value={this.state.value}
        onChange={this.handleChange}
      /&gt;
    );
  }
}
</code></pre><p>In this example, we keep <code>value</code> in the local state, but we <em>also</em> receive <code>value</code> from props. Whenever we “receive new props”, we reset the <code>value</code> in state.</p>
<p><strong>The problem with this pattern is that it entirely relies on accidental timing.</strong></p>
<p>Maybe today this component’s parent updates rarely, and so our <code>TextInput</code> only “receives props” when something important happens, like saving a form.</p>
<p>But tomorrow you might add some animation to the parent of <code>TextInput</code>. If its parent re-renders more often, it will keep <a href="https://codesandbox.io/s/m3w9zn1z8x">“blowing away”</a> the child state! You can read more about this problem in <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">“You Probably Don’t Need Derived State”</a>.</p>
<p><strong>So how can we fix this?</strong></p>
<p>First of all, we need to fix our mental model. We need to stop thinking of “receiving props” as something different from just “rendering”. A re-render caused by a parent shouldn’t behave differently from a re-render caused by our own local state change. <strong>Components should be resilient to rendering less or more often because otherwise they’re too coupled to their particular parents.</strong></p>
<p><em>(<a href="https://codesandbox.io/s/m3w9zn1z8x">This demo</a> shows how re-rendering can break fragile components.)</em></p>
<p>While there are a few <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions">different</a> <a href="https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops">solutions</a> for when you <em>truly</em> want to derive state from props, usually you should use either a fully controlled component:</p>
<pre   class="language-jsx"><code class="language-jsx">// Option 1: Fully controlled component.
function TextInput({ value, onChange }) {
  return (
    &lt;input
      value={value}
      onChange={onChange}
    /&gt;
  );
}
</code></pre><p>Or you can use an uncontrolled component with a key to reset it:</p>
<pre   class="language-jsx"><code class="language-jsx">// Option 2: Fully uncontrolled component.
function TextInput() {
  const [value, setValue] = useState('');
  return (
    &lt;input
      value={value}
      onChange={e =&gt; setValue(e.target.value)}
    /&gt;
  );
}

// We can reset its internal state later by changing the key:
&lt;TextInput key={formId} /&gt;
</code></pre><p>The takeaway from this section is that your component shouldn’t break just because it or its parent re-renders more often. The React API design makes it easy if you avoid the legacy <code>componentWillReceiveProps</code> lifecycle method.</p>
<p>To stress-test your component, you can temporarily add this code to its parent:</p>
<pre data-line="2,"  2="" class="language-js"><code 2="" class="language-js">componentDidMount() {
  // Don't forget to remove this immediately!
  setInterval(() =&gt; this.forceUpdate(), 100);
}
</code></pre><p><strong>Don’t leave this code in</strong> — it’s just a quick way to check what happens when a parent re-renders more often than you expected. It shouldn’t break the child!</p>
<hr>
<p>You might be thinking: “I’ll keep resetting state when the props change, but will prevent unnecessary re-renders with <code>PureComponent</code>”.</p>
<p>This code should work, right?</p>
<pre data-line="1-2,"  1-2="" class="language-jsx"><code 1-2="" class="language-jsx">// 🤔 Should prevent unnecessary re-renders... right?
class TextInput extends React.PureComponent {
  state = {
    value: ''
  };
  // 🔴 Resets local state on every parent render
  componentWillReceiveProps(nextProps) {
    this.setState({ value: nextProps.value });
  }
  handleChange = (e) =&gt; {
    this.setState({ value: e.target.value });
  };
  render() {
    return (
      &lt;input
        value={this.state.value}
        onChange={this.handleChange}
      /&gt;
    );
  }
}
</code></pre><p>At first, it might seem like this component solves the problem of “blowing away” the state on parent re-render. After all, if the props are the same, we just skip the update — and so <code>componentWillReceiveProps</code> doesn’t get called.</p>
<p>However, this gives us a false sense of security. <strong>This component is still not resilient to <em>actual</em> prop changes.</strong> For example, if we added <em>another</em> often-changing prop, like an animated <code>style</code>, we would still “lose” the internal state:</p>
<pre data-line="2,"  2="" class="language-jsx"><code 2="" class="language-jsx">&lt;TextInput
  style={{opacity: someValueFromState}}
  value={
    // 🔴 componentWillReceiveProps in TextInput
    // resets to this value on every animation tick.
    value
  }
/&gt;
</code></pre><p>So this approach is still flawed. We can see that various optimizations like <code>PureComponent</code>, <code>shouldComponentUpdate</code>, and <code>React.memo</code> shouldn’t be used for controlling <em>behavior</em>. Only use them to improve <em>performance</em> where it helps. If removing an optimization <em>breaks</em> a component, it was too fragile to begin with.</p>
<p>The solution here is the same as we described earlier. Don’t treat “receiving props” as a special event. Avoid “syncing” props and state. In most cases, every value should either be fully controlled (through props), or fully uncontrolled (in local state). Avoid derived state <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions">when you can</a>. <strong>And always be ready to render!</strong></p>
<hr>
<h2>Principle 3: No Component Is a Singleton</h2>
<p>Sometimes we assume a certain component is only ever displayed once. Such as a navigation bar. This might be true for some time. However, this assumption often causes design problems that only surface much later.</p>
<p>For example, maybe you need to implement an animation <em>between</em> two <code>Page</code> components on a route change — the previous <code>Page</code> and the next <code>Page</code>. Both of them need to be mounted during the animation. However, you might discover that each of those components assumes it’s the only <code>Page</code> on the screen.</p>
<p>It’s easy to check for these problems. Just for fun, try to render your app twice:</p>
<pre data-line="3,4,"  3,4="" class="language-jsx"><code 3,4="" class="language-jsx">ReactDOM.render(
  &lt;&gt;
    &lt;MyApp /&gt;
    &lt;MyApp /&gt;
  &lt;/&gt;,
  document.getElementById('root')
);
</code></pre><p>Click around. (You might need to tweak some CSS for this experiment.)</p>
<p><strong>Does your app still behave as expected?</strong> Or do you see strange crashes and errors? It’s a good idea to do this stress test on complex components once in a while, and ensure that multiple copies of them don’t conflict with one another.</p>
<p>An example of a problematic pattern I’ve written myself a few times is performing global state “cleanup” in <code>componentWillUnmount</code>:</p>
<pre data-line="2-3,"  2-3="" class="language-jsx"><code 2-3="" class="language-jsx">componentWillUnmount() {
  // Resets something in Redux store
  this.props.resetForm();
}
</code></pre><p>Of course, if there are two such components on the page, unmounting one of them can break the other one. Resetting “global” state on <em>mount</em> is no better:</p>
<pre data-line="2-3,"  2-3="" class="language-jsx"><code 2-3="" class="language-jsx">componentDidMount() {
  // Resets something in Redux store
  this.props.resetForm();
}
</code></pre><p>In that case <em>mounting</em> a second form will break the first one.</p>
<p>These patterns are good indicators of where our components are fragile. <strong><em>Showing</em> or <em>hiding</em> a tree shouldn’t break components outside of that tree.</strong></p>
<p>Whether you plan to render this component twice or not, solving these issues pays off in the longer term. It leads you to a more resilient design.</p>
<hr>
<h2>Principle 4: Keep the Local State Isolated</h2>
<p>Consider a social media <code>Post</code> component. It has a list of <code>Comment</code> threads (that can be expanded) and a <code>NewComment</code> input.</p>
<p>React components may have local state. But what state is truly local? Is the post content itself local state or not? What about the list of comments? Or the record of which comment threads are expanded? Or the value of the comment input?</p>
<p>If you’re used to putting everything into a “state manager”, answering this question can be challenging. So here’s a simple way to decide.</p>
<p><strong>If you’re not sure whether some state is local, ask yourself: “If this component was rendered twice, should this interaction reflect in the other copy?” Whenever the answer is “no”, you found some local state.</strong></p>
<p>For example, imagine we rendered the same <code>Post</code> twice. Let’s look at different things inside of it that can change.</p>
<ul>
<li>
<p><em>Post content.</em> We’d want editing the post in one tree to update it in another tree. Therefore, it probably <strong>should not</strong> be the local state of a <code>Post</code> component. (Instead, the post content could live in some cache like Apollo, Relay, or Redux.)</p>
</li>
<li>
<p><em>List of comments.</em> This is similar to post content. We’d want adding a new comment in one tree to be reflected in the other tree too. So ideally we would use some kind of a cache for it, and it <strong>should not</strong> be a local state of our <code>Post</code>.</p>
</li>
<li>
<p><em>Which comments are expanded.</em> It would be weird if expanding a comment in one tree would also expand it in another tree. In this case we’re interacting with a particular <code>Comment</code> <em>UI representation</em> rather than an abstract “comment entity”. Therefore, an “expanded” flag <strong>should</strong> be a local state of the <code>Comment</code>.</p>
</li>
<li>
<p><em>The value of new comment input.</em> It would be odd if typing a comment in one input would also update an input in another tree. Unless inputs are clearly grouped together, usually people expect them to be independent. So the input value <strong>should</strong> be a local state of the <code>NewComment</code> component.</p>
</li>
</ul>
<p>I don’t suggest a dogmatic interpretation of these rules. Of course, in a simpler app you might want to use local state for everything, including those “caches”. I’m only talking about the ideal user experience <a href="/the-elements-of-ui-engineering/">from the first principles</a>.</p>
<p><strong>Avoid making truly local state global.</strong> This plays into our topic of “resilience”: there’s fewer surprising synchronization happening between components. As a bonus, this <em>also</em> fixes a large class of performance issues. “Over-rendering” is much less of an issue when your state is in the right place.</p>
<hr>
<h2>Recap</h2>
<p>Let’s recap these principles one more time:</p>
<ol>
<li><strong><a href="#principle-1-dont-stop-the-data-flow">Don’t stop the data flow.</a></strong> Props and state can change, and components should handle those changes whenever they happen.</li>
<li><strong><a href="#principle-2-always-be-ready-to-render">Always be ready to render.</a></strong> A component shouldn’t break because it’s rendered more or less often.</li>
<li><strong><a href="#principle-3-no-component-is-a-singleton">No component is a singleton.</a></strong> Even if a component is rendered just once, your design will improve if rendering twice doesn’t break it.</li>
<li><strong><a href="#principle-4-keep-the-local-state-isolated">Keep the local state isolated.</a></strong> Think about which state is local to a particular UI representation — and don’t hoist that state higher than necessary.</li>
</ol>
<p><strong>These principles help you write components that are <a href="/optimized-for-change/">optimized for change</a>. It’s easy to add, change them, and delete them.</strong></p>
<p>And most importantly, once our components are resilient, we can come back to the pressing dilemma of whether or not props should be sorted by alphabet.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[应变而优]]></title>
            <link>/post/optimized-for-change-zh</link>
            <guid>/post/optimized-for-change-zh</guid>
            <description><![CDATA[什么造就了一个优秀的API?]]></description>
            <content:encoded><![CDATA[<p>什么造就了一个优秀的 API ？</p>
<p><em>优秀</em> 的 API 设计是既好记又明确的。它能促进代码的可读性、准确性和高效性，也能帮助开发者进入<a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/">成功之坑</a>。</p>
<p>我称这些设计层面为「第一级」，因为这些是一个库开发者需要关注的首要事项。你可能需要在它们中的某些上做妥协和权衡，但至少这些都是你的考虑点。</p>
<p>然而，除非你要将一个漫游者发往火星，不然你的代码很有可能随着时间而改变。同样，你 API 使用者的代码也是如此。</p>
<p>我所知道的最好的API设计者们不会停留于这些「第一级」层面，比如可读性。他们将尽可能多的努力花在那些我称为「第二级」的 API 设计层面上：<strong>使用此 API 的代码如何随时间的推移而发展。</strong></p>
<p>微小的需求变化可以使最优雅的代码支离破碎。</p>
<p><em>优秀</em> 的 API 对这一点是有预期的。它们预料到你可能想移动一些代码、复制粘贴一部分、重命名、将一些特殊例子整合成一个通用且可复用的辅助函数、将一个抽象解构成一些具体实例、加一个 hack、优化一个瓶颈、抛弃一部分代码重写、犯了一个错误、在起因和结果间游走、修复一个 bug、审阅一个代码修复。</p>
<p>优秀的 API 不仅仅让你进入成功之坑里，而且能帮你 <em>驻留</em> 在那里。</p>
<p>它们应变而优。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Optimized for Change]]></title>
            <link>/post/optimized-for-change</link>
            <guid>/post/optimized-for-change</guid>
            <description><![CDATA[What makes a great API?]]></description>
            <content:encoded><![CDATA[<p>What makes a great API?</p>
<p><em>Good</em> API design is memorable and unambiguous. It encourages readable, correct and performant code, and helps developers fall into <a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/">the pit of success</a>.</p>
<p>I call these design aspects “first order” because they are the first things a library developer tends to focus on. You might have to compromise on some of them and make tradeoffs but at least they’re always on your mind.</p>
<p>However, unless you’re sending a rover to Mars, your code will probably change over time. And so will the code of your API consumers.</p>
<p>The best API designers I know don’t stop at the “first order” aspects like readability. They dedicate just as much, if not more, effort to what I call the “second order” API design: <strong>how code using this API would evolve over time.</strong></p>
<p>A slight change in requirements can make the most elegant code fall apart.</p>
<p><em>Great</em> APIs anticipate that. They anticipate that you’ll want to move some code. Copy and paste some part. Rename it. Unify special cases into a generic reusable helper. Unwind an abstraction back into specific cases. Add a hack. Optimize a bottleneck. Throw away a part and start it anew. Make a mistake. Navigate between the cause and the effect. Fix a bug. Review the fix.</p>
<p>Great APIs not only let you fall into a pit of success, but help you <em>stay</em> there.</p>
<p>They’re optimized for change.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[做好技术分享，第一章：驱动]]></title>
            <link>/post/preparing-for-tech-talk-part-1-motivation-zh</link>
            <guid>/post/preparing-for-tech-talk-part-1-motivation-zh</guid>
            <description><![CDATA[这是我对美妙分享灵感的秘方]]></description>
            <content:encoded><![CDATA[<p>我做过一些我认为非常不错的<a href="https://www.youtube.com/watch?v=xsSnOQynTHs">技</a><a href="https://www.youtube.com/watch?v=nLF0n9SACd4">术</a><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">分享</a>。</p>
<p>有时人们问我如何准备好一个分享。对于每个人来说，答案都是不同的，下面我分享的是对于我有用的部分。</p>
<p><strong>本文是这个系列分享的第一部分</strong>，本文中我阐述了如何准备一个技术分享--从产生一个想法到现场分享。</p>
<ul>
<li><strong>做好技术分享，第一章：驱动</strong></li>
<li><strong><a href="/preparing-for-tech-talk-part-2-what-why-and-how/">做好技术分享，第二章：内容，原因和方法</a></strong></li>
<li>未完待续</li>
</ul>
<p />
<hr>
<p><strong>本文中，我只会关注第一步：我是为什么并且如何挑选话题的。</strong> 这并不会提供很多实践建议，但是可以让你关注一些正确的点。</p>
<hr>
<p>是什么<em>激励</em>你，让你来做技术分享？</p>
<p>可能分享就是你现在工作的一部分，可能你希望以此在公司中获得更多认同，来获得一份更好的工作，或者晋升。可能你仅仅是希望大家更了解你的兴趣或工作项目。</p>
<p>我们称这些驱动是<em>外在</em>的，它们关系到别人如何评价你以及你的工作。但如果你已经拥有了你想要的声望和金钱，你仍然会做一个技术分享吗？为什么？</p>
<p>也许你享受传道受业；也许你享受学习，而做分享正是一个追根究底的好方式；也许你希望引起一个话题的讨论；也可能你只想对一个观点衡短论长。</p>
<p>这些<em>内在</em>驱动并不只是代表希望获得专业认可，这些东西对你来说有固有的价值。不同的人有不同的内在驱动，了解你自己的内在驱动是有意义的，你可以通过他们追本溯源，更清楚地认识自己。</p>
<p>例如，以下是我的内在驱动：</p>
<ul>
<li>
<p><strong>我乐于分享灵感性的想法。</strong> 有时，一个想法能改变我的思考方式，能打开新世界的大门。大部分情况下，一个人思考是闭门造车，我希望其他人来和我交流，能让我茅塞顿开。对我来说，一次分享，是一个集思广益的过程。（在我年轻时，虽然我的音乐品味并不突出，但我喜欢制作磁带。而现在，我却喜欢分享，生活总是会带给你惊喜。）</p>
</li>
<li>
<p><strong>我乐于以简单的方式解释事物。</strong> 当我理解一个想法时，我会获得比吃甜食更大的愉悦感。学习对我来说不是易事，所以当我搞清楚某事时，我希望能通过我的方式点醒被它困扰的人。我尝试记住在我恍然大悟之前我的观点是如何的，这样能帮助别人在接受我的分享时获得同样的过程。（我小时候经常让别人问我问题，这让人难以忍受，而做分享则是一个更有成效的让别人提问的方式。）</p>
</li>
</ul>
<hr>
<p>把这两个内在驱动结合起来，我就有了一个让我满意的分享的秘方：<strong>以简单的方式解释一个灵感性的想法。</strong></p>
<hr>
<p>这是我的准则，一千个人眼中就有一千个哈姆雷特，好好想想什么分享让你感到特别，他们之间有何形式上的类似吗？（本系列接下来会更多地讨论分享形式）</p>
<p><img src="./patronus.jpg" alt="Luna Lovegood invoking a Patronus Charm. Image © 2007 Warner Bros. Ent"></p>
<p>做一个和你驱动一致的分享对你在以下方面是有帮助的：</p>
<ol>
<li>
<p><strong>话题变得更容易挑选。</strong> 我的准则是「解释一个灵感性的想法，以及你为何需要关注它」。在我学会的有趣的概念上，通过实施这一准则我可以搞定我的分享提案。只要持续地和聪明人交流，听取他们值得发扬光大的想法，我就总可以有一些值得讨论的话题。而你可以挖掘更多可能的准则！</p>
</li>
<li>
<p><strong>讲台上你不会觉得胆怯。</strong> 在分享前的三十秒，我会觉得恐惧，不过一旦我开始演讲，这就是我的舞台了。分享一个灵感性想法的驱动力战胜了被批评或者做错事的恐惧。（当然，以上都是只有你做好了准备才有效，我们会在接下来的文章中讨论）</p>
</li>
<li>
<p><strong>你会变得更让人信服。</strong> <a href="https://mobile.twitter.com/sophiebits/status/1077723835481284608">Sophie</a> 在这方面表达得比我好：如果你对一个话题充满了热忱，观众也会被你感染，也会对此感兴趣。激情并不只代表挥着手或者大声说话，即使你很冷静，人们同样可以感受到背后的信念。（这就是为何我们就算听不懂<a href="https://www.youtube.com/watch?v=6SWIwW9mg8s">歌词</a>，也可以感受一首歌）</p>
</li>
</ol>
<hr>
<p>当你对某个话题感到非常兴奋时，还有一个原因会激励你--你会感觉自己是宏伟事业的一部分，这会让人充满信心。</p>
<p>其实我的分享是关于一个想法，并不是关于我，而我只是一个信使。那些上万的观众，他们评判的不是我（即使他们是如此认为），他们只是来听取我的想法。我的只是把想法传递给其他人。把这些想法植入内心后，来自分享的精神压力就会消失。</p>
<hr>
<p>寻找契合你驱动的准则可以帮助你确定你的话语。但是，你如何找到可以应用这个准则的特定话题呢？</p>
<p><strong>根据我的经验，良好的谈话始于对话。</strong> 有人向我解释了一个想法，然后我试着向别人解释，我和十几个人讨论它，最后我能找到「普适」的解释。想法有时会被忽视或误解，我会试图让不同人以不同的眼光看待它。</p>
<p>对我来说，分享只是一种概括这些对话并使它们成为一对多而非一对一的方式。它就像一个「库」，是你从许多面对面和社交媒体讨论的「应用程序代码」中提取出来。</p>
<p>因此，如果你想进行一次精彩的分享，与人交谈是一个很好的开始。</p>
<p><img src="https://overreacted.io/static/7c324114478c65f71622e8f823dceee3/f8fb9/cauldron.jpg" alt="Hermione Granger making a potion. Vials have text imposed on top: &quot;motivations&quot; and &quot;conversations&quot;. Cauldron is a metaphor for your talk. Image © 2001 Warner Bros. Ent"></p>
<p>在这篇文章中，我描述了我认为有助于分享的套路。我重申下，我只是分享对我有用的东西--很多<a href="https://mobile.twitter.com/jackiehluo/status/1077717283026411520">情况</a>下，你的看法可能大相径庭。</p>
<p>在本系列的下一篇文章中，我将讨论准备分享大纲，幻灯片，预演以及我在分享当天所做的工作。</p>
<p>本系列的下一篇：<strong><a href="/preparing-for-tech-talk-part-2-what-why-and-how/">做好技术分享，第2部分：内容，原因和方法</a></strong> 。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Preparing for a Tech Talk, Part 1: Motivation]]></title>
            <link>/post/preparing-for-tech-talk-part-1-motivation</link>
            <guid>/post/preparing-for-tech-talk-part-1-motivation</guid>
            <description><![CDATA[Here’s my recipe for a good talk idea.]]></description>
            <content:encoded><![CDATA[<p>I’ve done a <a href="https://www.youtube.com/watch?v=xsSnOQynTHs">few</a> <a href="https://www.youtube.com/watch?v=nLF0n9SACd4">tech</a> <a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">talks</a> that I think went well.</p>
<p>Sometimes people ask me how I prepare for a talk. For every speaker, the answer is very personal. I’m just sharing what works for me.</p>
<p><strong>This is the first post in a series</strong> where I explain my process preparing for a tech talk — from conceiving the idea to the actual day of the presentation:</p>
<ul>
<li><strong>Preparing for a Tech Talk, Part 1: Motivation (<em>this post</em>)</strong></li>
<li><strong><a href="/preparing-for-tech-talk-part-2-what-why-and-how/">Preparing for a Tech Talk, Part 2: What, Why, and How</a></strong></li>
<li><strong><a href="/preparing-for-tech-talk-part-3-content/">Preparing for a Tech Talk, Part 3: Content</a></strong></li>
<li>To be continued</li>
</ul>
<p />
<hr>
<p><strong>In this post, I will only focus on the first step: why and how I pick a topic.</strong> It’s not rich in practical tips but might help you ask yourself the right questions.</p>
<hr>
<p>What motivates <em>you</em> to give a talk?</p>
<p>Maybe giving talks is a part of your current job. Maybe you want to gain more recognition in the industry so you can land a better job or get a raise. Maybe you’re out there to bring more attention to your hobby or work project.</p>
<p>We’ll call these motivations <em>external</em>. They are about what other people think of you and your work. But if you already had all the respect and money that you wanted, would you still choose to give a talk? Why?</p>
<p>Maybe you find it rewarding to teach people. Maybe you enjoy learning, and giving a talk is a nice excuse to dig deeper. Maybe you want to start or change the conversation about a topic. Maybe you want to amplify or critique an idea.</p>
<p>Such <em>internal</em> motivations aren’t a proxy for another desire like professional recognition. These are the things that have intrinsic value to you. Different people are driven by different internal motivations. It’s helpful to be aware of yours. You can sometimes trace them all the way back to your childhood.</p>
<p>For example, here’s mine:</p>
<ul>
<li>
<p><strong>I enjoy sharing ideas that inspire me.</strong> Sometimes, an idea transforms the way I think. It opens many doors that I didn’t even know existed. But it’s lonely behind those doors. I want others to join me so that they can show me even more interesting doors inside. For me, a talk is a way to collect, curate, and amplify ideas that I find tasteful. (As a teenager I made mixtapes for crushes with no interest in my music taste. Now I do talks! Life, uh, finds a way.)</p>
</li>
<li>
<p><strong>I enjoy re-explaining things in a simpler way.</strong> When I understand an idea, I get a very pleasant feeling — better than eating sweets. But learning doesn’t come easy to me. So when I finally “get” something, I want to share that feeling with the people who are still struggling. I try to remember what it was like <em>before</em> the a-ha moment to help others “make the jump” while watching my talks. (I was also insufferable as a child because I insisted that everyone asks me questions. A talk is a more productive way to channel that energy.)</p>
</li>
</ul>
<hr>
<p>Combining these two internal motivations gives me a recipe for a personally satisfying talk: <strong>share an inspiring idea by re-explaining it in a simpler way</strong>.</p>
<hr>
<p>That is my formula. Yours might be different — think about it! Which talks made you feel in a special way? What are the structural similarities between them? (We’ll discuss the talk structure more in the next posts in this series.)</p>
<p><img src="./patronus.jpg" alt="Luna Lovegood invoking a Patronus Charm. Image © 2007 Warner Bros. Ent"></p>
<p>Giving a talk that’s aligned with your motivations is helpful in several ways:</p>
<ol>
<li>
<p><strong>It’s easier to pick a topic.</strong> My formula is “explain an inspiring idea and why you should care about it”. I can create talk proposals by applying this formula to any interesting concept that I learned. I’ll always have something to talk about as long as I’m listening to smart people with good ideas that deserve more exposure. There are many other possible formulas — find yours.</p>
</li>
<li>
<p><strong>It’s less scary on stage.</strong> I get terrified 30 seconds before the talk but <em>the moment I start talking, I’m in my element</em>. The drive to share an inspiring idea overtakes the fear of being judged or doing something wrong. (Of course, this only works with good preparation which we’ll talk about in the next posts.)</p>
</li>
<li>
<p><strong>It’s more convincing.</strong> I can’t phrase it better than <a href="https://mobile.twitter.com/sophiebits/status/1077723835481284608">Sophie did</a>: if you’re enthusiastic about a topic, you can get the audience to care too. Enthusiasm doesn’t necessarily mean being loud or waving hands. Even if you’re calm, people can feel when there’s an emotional conviction behind a talk. (This is also why we can vibe to a <a href="https://www.youtube.com/watch?v=6SWIwW9mg8s">song</a> even if we don’t understand the words.)</p>
</li>
</ol>
<hr>
<p>There’s one more reason it helps when you’re genuinely excited about a topic. Feeling that you’re a part of something bigger does wonders for confidence.</p>
<p>My talks aren’t about <em>me</em> — they’re about an idea, and I’m just a messenger. Thousands of people on the livestream and in the audience aren’t really there to judge me (even if they think so). They came to experience the idea that I brought to share. My role is just to be a conduit from one mind to another. A lot of nerves and pressure from the talks disappeared after internalizing this.</p>
<hr>
<p>Finding a formula that’s consistent with your motivations helps you establish your own voice. But how do you find a <em>specific</em> topic to which you can apply it?</p>
<p><strong>In my experience, good talks start as conversations.</strong> Somebody explains an idea to me, and then I try to explain it to someone else. I talk about it to a dozen people, and eventually I find explanations that “click”. Sometimes there’s a thought that seems neglected or misunderstood, and I try to get individual people to see it in a different light.</p>
<p>For me, a talk is just a way to generalize those conversations and make them one-to-many rather than one-to-one. It’s like a “library” you extract out of the “application code” of many in-person and social media conversations.</p>
<p>So if you want to give a great talk, <em>talking</em> to people is a good way to start.</p>
<p><img src="./cauldron.jpg" alt="Hermione Granger making a potion. Vials have text imposed on top: &quot;motivations&quot; and &quot;conversations&quot;. Cauldron is a metaphor for your talk. Image © 2001 Warner Bros. Ent"></p>
<hr>
<p>In this post, I described the framework that I find helpful for thinking about talk ideas. Again, I want to emphasize I’m just sharing what works for me — there are <a href="https://mobile.twitter.com/jackiehluo/status/1077717283026411520">many kinds of talks</a> and your outlook on this may be very different.</p>
<p>In the next posts in this series, I will talk about preparing the talk outline, slides, rehearsing the talks, and what I do on the day of the presentation.</p>
<p><strong>Next in this series: <a href="/preparing-for-tech-talk-part-2-what-why-and-how/">Preparing for a Tech Talk, Part 2: What, Why, and How</a></strong>.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[準備一場技術分享 - 第二篇： 什麼、為何、怎麼做]]></title>
            <link>/post/preparing-for-tech-talk-part-2-what-why-and-how-zh</link>
            <guid>/post/preparing-for-tech-talk-part-2-what-why-and-how-zh</guid>
            <description><![CDATA[我們必須更深入的了解]]></description>
            <content:encoded><![CDATA[<p>我給過<a href="https://www.youtube.com/watch?v=xsSnOQynTHs">一些</a>我覺得還不錯的<a href="https://www.youtube.com/watch?v=nLF0n9SACd4">技術</a><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">分享</a>。</p>
<p>有時候大家問我怎麼準備一場技術分享。這個答案對每個講者來說都是非常個人的。我只是分享一些我認為對我來說有用的技巧。</p>
<p><strong>這是系列文的第二篇</strong> 我會分享我準備一場技術分享的過程 -- 從構思想法到實際發表的那天：</p>
<ul>
<li><strong><a href="/preparing-for-tech-talk-part-1-motivation/">準備一場技術分享 - 第一篇：動機</a></strong></li>
<li><strong>準備一場技術分享 - 第二篇： 什麼、為何、怎麼做 (<em>本篇</em>)</strong></li>
<li>待續</li>
</ul>
<p />
<hr>
<p><strong>在本篇文章，我會注重在尋找我的技術分享的什麼、為何、以及怎麼做。</strong> 及早做這些事情將幫助我免除後面階段令人頭痛的事。</p>
<hr>
<p>如果你還沒看過<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E9%9D%A2%E5%95%9F%E5%8B%95">「全面啟動」</a>，今天快去看。<br>
他是個包含著離奇古怪的視覺效果以及刺激的情節的有趣成功電影。不過就如同 <a href="https://mobile.twitter.com/ryanflorence">Ryan Florence</a> 教我的，這部電影也包含著關於如何創造一個令人印象深刻的演說的好建議。</p>
<p>那部電影是關於如何把你的想法在某人熟睡的時候放進他的腦袋裡。這聽起來或許有點侵入性（而且在電影裡是犯法的），但如果你報名成為一場技術分享的講者，它就是一個對於你將面對的挑戰的非常精準的描述。</p>
<hr>
<p><strong>什麼是你想要讓你的聽眾從你的演講裡獲得的？</strong> 我嘗試著及早將它建構成一個句子。這個概念不該多於十幾個字。人們會忘記你大部分的內容，所以你需要小心地選擇<em>什麼</em>是你該著重的東西。這是你想要種在他們腦海裡的種子。</p>
<p><img src="./totem.jpg" alt="「全面啟動」裡的陀螺"></p>
<p>舉例來說，以下是一些我的技術分享裡的核心概念。</p>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=xsSnOQynTHs">即時重載 (Hot Reloading)</a>: 「函式的原則改善了開發的流程。」</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=nLF0n9SACd4">Beyond React 16</a>: 「等待 CPU 和 IO 有了統一的解法。」</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">介紹 Hooks</a>: 「Hooks 讓狀態邏輯 (stateful logic) 能夠重複使用。」</p>
</li>
</ul>
<p>我並不會每次都特別<em>說出</em>我的中心思想或把它寫在我的投影片裡，但它永遠是我技術分享裡的智慧骨幹。任何我說的或我展示的東西，最終都是用來支持這個中心思想。我想要向你證明它。</p>
<hr>
<p>想法是我的技術分享裡的 <strong>「什麼」</strong>。但還有 <strong>「怎麼做」</strong> 和 <strong>「為何」</strong>：</p>
<p><img src="./how-what-why.png" alt="金字塔：「怎麼做」在「什麼」的上面。「什麼」在「為何」的上面。"></p>
<p><strong>「怎麼做」</strong> 是我將想法傳遞給觀眾的方式。以我而已，我喜歡現場示範，但仍有很多其他有用的方式。我會在之後的系列文章裡面提到更多的「怎麼做」。</p>
<p>我們已經討論了 <strong>「什麼」</strong> 是演講裡的核心思想。它是我想要種在你腦海裡的想法，也是我想要你帶走的領悟。它是我想要大家聽完後分享給朋友或同事的東西。</p>
<p>這帶我們來到了 <strong>「為何」</strong>。</p>
<hr>
<p>為了解釋 <strong>「為何」</strong>，我將節錄「全面啟動」裡的對話：</p>
<p><strong>（警告： 以下有劇情雷！）</strong></p>
<blockquote>
<p><strong>Cobb:</strong> 「我會分裂我爸的帝國。」現在，這個明顯是 Robert 會拒絕的提案。這就是為什麼我們必須將它深深種植在 Robert 的潛意識裡。潛意識是被情感給驅動的，對吧？不是理由。我們必須找到一種可以將這個概念種植在他的情感概念裡的方法。</p>
<p><strong>Arthur:</strong> 你要怎麼把商業策略轉換成情感？</p>
<p><strong>Cobb:</strong> 這就是為什麼我們需要在這裡釐清這件事。最少我們知道，現在 Robert 跟他爸的關係很緊張。</p>
<p><strong>Eames:</strong> 我們可以試著利用它？我們可以建議他藉由「搞砸」那個老人來將它分離出他爸的公司。</p>
<p><strong>Cobb:</strong> 不，我覺得正向情感永遠都比負面的情感有效。我們都期待和解、情感宣洩。我們需要 Robert Fischer 能夠以正向的情感反應來面對這些。</p>
<p><strong>Eames:</strong> 好的，不如試試這個？「我的爸爸希望我可以自己建立我的未來，不要跟隨他的腳步。」</p>
<p><strong>Cobb:</strong> 這個可能行得通。</p>
</blockquote>
<p>現在，我並不是要建議你跟你的演講分解帝國。</p>
<p>但這裡必須有個你走出來跟成千上萬的人技術分享的<a href="/preparing-for-tech-talk-part-1-motivation/">原因</a>。你<em>相信</em>某些事情 -- 而且你想要分享這些感受。 <strong>這就是「為何」-- 你演說裡的情感核心。</strong></p>
<hr>
<p>以下是一些我演講裡「什麼」、「為何」、「怎麼做」的例子。</p>
<p><a href="https://www.youtube.com/watch?v=xsSnOQynTHs" target="_blank"><img src="how-what-why-hot-reloading.png" alt="怎麼做：「現場示範」。什麼：「函式的原則改善了開發的流程」。為何：「做一個讓寫程式變得有趣的自己的工具」。"></a></p>
<p><em>(上面是關於 <a href="https://www.youtube.com/watch?v=xsSnOQynTHs">Hot reloading with time travel</a> 的金字塔)</em></p>
<p><a href="https://www.youtube.com/watch?v=nLF0n9SACd4" target="_blank"><img src="how-what-why-beyond-react-16.png" alt="怎麼做：「現場示範」。什麼：「等待 CPU 和 IO 有了統一的解法」。為何：「React 在乎使用者以及開發者」。"></a></p>
<p><em>(上面是關於 <a href="https://www.youtube.com/watch?v=nLF0n9SACd4">Beyond React 16</a> 的金字塔)</em></p>
<p><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM" target="_blank"><img src="how-what-why-introducing-hooks.png" alt="怎麼做：「現場示範」。什麼：「Hooks 讓狀態邏輯 (stateful logic) 能夠重複使用」。為何：「Hooks 揭露了 React 的真正自然生態」。"></a></p>
<p><em>(上面是關於 <a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">Introducing Hooks</a> 的金字塔)</em></p>
<p>一個令人印象深刻的演說需要簡潔的想法、讓觀眾在乎它、以及清楚且有說服力的執行。這就是「什麼」、「為何」、「怎麼做」。</p>
<hr>
<p>在這篇文章，我描述了我如何架構我演說的核心思想。再一次，我想要強調我只是分享對我來說有用的方法 -- 還有很多<a href="https://mobile.twitter.com/jackiehluo/status/1077717283026411520">其他形式的演說</a>，你對於它的觀點可能非常不同。</p>
<p>在未來的系列文章中，我將會提到如何準備演說的大綱、投影片、演說的預演，以及我在演說當天所做的事。</p>
<p><strong>本系列先前的文章: <a href="/preparing-for-tech-talk-part-1-motivation/">準備一場技術分享 - 第一篇：動機</a></strong>。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Preparing for a Tech Talk, Part 2: What, Why, and How]]></title>
            <link>/post/preparing-for-tech-talk-part-2-what-why-and-how</link>
            <guid>/post/preparing-for-tech-talk-part-2-what-why-and-how</guid>
            <description><![CDATA[We need to go deeper.]]></description>
            <content:encoded><![CDATA[<p>I’ve done a <a href="https://www.youtube.com/watch?v=xsSnOQynTHs">few</a> <a href="https://www.youtube.com/watch?v=nLF0n9SACd4">tech</a> <a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">talks</a> that I think went well.</p>
<p>Sometimes people ask me how I prepare for a talk. For every speaker, the answer is very personal. I’m just sharing what works for me.</p>
<p><strong>This is the second post in a series</strong> where I explain my process preparing for a tech talk — from conceiving the idea to the actual day of the presentation:</p>
<ul>
<li><strong><a href="/preparing-for-tech-talk-part-1-motivation/">Preparing for a Tech Talk, Part 1: Motivation</a></strong></li>
<li><strong>Preparing for a Tech Talk, Part 2: What, Why, and How (<em>this post</em>)</strong></li>
<li><strong><a href="/preparing-for-tech-talk-part-3-content/">Preparing for a Tech Talk, Part 3: Content</a></strong></li>
<li>To be continued</li>
</ul>
<p />
<hr>
<p><strong>In this post, I will focus on finding the What, Why, and How of my talk.</strong> Doing this early helps me avoid a lot of headache at a later stage.</p>
<hr>
<p>If you haven’t seen <a href="https://en.wikipedia.org/wiki/Inception">Inception</a>, watch it today. It’s an enjoyable blockbuster with mindbending visuals and a stimulating plot. But as <a href="https://mobile.twitter.com/ryanflorence">Ryan Florence</a> taught me, it also contains good advice for creating a memorable talk.</p>
<p>That movie is about putting ideas into other people’s heads while they sleep. This might sound a bit invasive (and is illegal in the movie). But if you signed up to give a tech talk, that’s a pretty accurate description of your challenge.</p>
<hr>
<p><strong>What is the one thing that you want people to take away from your talk?</strong> I try to formulate it as a sentence early on. This idea shouldn’t be longer than a dozen words. People will forget most of what you say so you need to pick carefully <em>what</em> you want to stick. It’s the seed you want to plant in their heads.</p>
<p><img src="./totem.jpg" alt="Spinning top from the Inception movie"></p>
<p>For example, here’s the core ideas of my talks.</p>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=xsSnOQynTHs">Hot Reloading</a>: “Functional principles improve the development workflow.”</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=nLF0n9SACd4">Beyond React 16</a>: “Waiting for CPU and IO has a unified solution.”</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">Introducing Hooks</a>: “Hooks make stateful logic reusable.”</p>
</li>
</ul>
<p>I don’t always explicitly <em>say</em> the central idea out loud or write it on a slide, but it is always the intellectual backbone of my talk. Everything I say and show must ultimately work towards supporting this idea. I want to prove it to you.</p>
<hr>
<p>An idea is the <strong>“What”</strong> of my talk. But there is also <strong>“How”</strong> and <strong>“Why”</strong>:</p>
<p><img src="./how-what-why.png" alt="Pyramid: “How” is on top of “What”. “What” is on top of “Why”."></p>
<p><strong>“How”</strong> is my method for delivering the idea to the audience. Personally, I prefer live demos, but there are many things that can work. I will talk more about “How” in the later blog posts in this series.</p>
<p>We’ve just discussed <strong>“What”</strong> which is the core idea of the talk. It’s the thought I want to plant in your head and the insight I want you to walk away with. It’s what I want people to share with their friends and colleagues.</p>
<p>Which brings us to <strong>“Why”</strong>.</p>
<hr>
<p>To explain <strong>“Why”</strong>, I’ll quote this dialog from the Inception movie:</p>
<p><strong>(warning: spoilers!)</strong></p>
<blockquote>
<p><strong>Cobb:</strong> &quot;I will split up my father's empire.&quot; Now, this is obviously an idea that Robert himself will choose to reject. Which is why we need to plant it deep in his subconscious. The subconscious is motivated by emotion, right? Not reason. We need to find a way to translate this into an emotional concept.</p>
<p><strong>Arthur:</strong> How do you translate a business strategy into an emotion?</p>
<p><strong>Cobb:</strong> That's what we're here to figure out, right. Now Robert's relationship with his father is stressed, to say the least.</p>
<p><strong>Eames:</strong> Well can we run with that? We could suggest him breaking up his fathers company as a &quot;screw you&quot; to the old man.</p>
<p><strong>Cobb:</strong> No, cause I think positive emotion trumps negative emotion every time. We all yearn for reconciliation, for catharsis. We need Robert Fischer to have a positive emotional reaction to all this.</p>
<p><strong>Eames:</strong> Alright, well, try this? &quot;My father accepts that I want to create for myself, not follow in his footsteps.&quot;</p>
<p><strong>Cobb:</strong> That might work.</p>
</blockquote>
<p>Now, I’m not suggesting that you break up empires with your talk.</p>
<p>But there must be a <a href="/preparing-for-tech-talk-part-1-motivation/">reason</a> you get out in front of thousands of people to speak about something. You <em>believe</em> in something — and you want others to share that feeling. <strong>This is the “Why” — the emotional core of your talk.</strong></p>
<hr>
<p>Here’s the example “What”, “Why”, and “How” from my talks.</p>
<p><a href="https://www.youtube.com/watch?v=xsSnOQynTHs" target="_blank"><img src="how-what-why-hot-reloading.png" alt="How: “Live demo”. What: “Functional principles improve the developer experience”. Why: “Create your own tools to make programming fun”."></a></p>
<p><em>(The above pyramid is for <a href="https://www.youtube.com/watch?v=xsSnOQynTHs">Hot reloading with time travel</a>)</em></p>
<p><a href="https://www.youtube.com/watch?v=nLF0n9SACd4" target="_blank"><img src="how-what-why-beyond-react-16.png" alt="How: “Live demo”. What: “Waiting for CPU and IO has a unified solution”. Why: “React cares about both user and developer experience”."></a></p>
<p><em>(The above pyramid is for <a href="https://www.youtube.com/watch?v=nLF0n9SACd4">Beyond React 16</a>)</em></p>
<p><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM" target="_blank"><img src="how-what-why-introducing-hooks.png" alt="How: “Live demo”. What: “Hooks make stateful logic reusable. Why: “Hooks reveal the true nature of React”."></a></p>
<p><em>(The above pyramid is for <a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">Introducing Hooks</a>)</em></p>
<p>A memorable talk takes a concise idea, makes the audience care about it, and has a clear and convincing execution. That’s the “What”, “Why”, and “How”.</p>
<hr>
<p>In this post, I described how I organize the core ideas of my talks. Again, I want to emphasize I’m just sharing what works for me — there are <a href="https://mobile.twitter.com/jackiehluo/status/1077717283026411520">many kinds of talks</a> and your outlook on this may be very different.</p>
<p>In the next posts in this series, I will talk about preparing the talk outline, slides, rehearsing the talks, and what I do on the day of the presentation.</p>
<p><strong>Next in this series: <a href="/preparing-for-tech-talk-part-3-content/">Preparing for a Tech Talk, Part 3: Content</a></strong>.</p>
<p><strong>Previous in this series: <a href="/preparing-for-tech-talk-part-1-motivation/">Preparing for a Tech Talk, Part 1: Motivation</a></strong>.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[将 React 作为 UI 运行时]]></title>
            <link>/post/react-as-a-ui-runtime-zh</link>
            <guid>/post/react-as-a-ui-runtime-zh</guid>
            <description><![CDATA[深入理解 React 编程模型]]></description>
            <content:encoded><![CDATA[<p>大多数教程把 React 称作是一个 UI 库。这是有道理的，因为 React 就是一个 UI 库。正如官网上的标语所说的那样。</p>
<p><img src="./react.png" alt="React homepage screenshot: &quot;A JavaScript library for building user interfaces&quot;"></p>
<p>我曾经写过关于构建<a href="/the-elements-of-ui-engineering/">用户界面</a>会遇到的难题一文。但是本篇文章将以一种不同的方式来讲述 React — 因为它更像是一种<a href="https://en.wikipedia.org/wiki/Runtime_system">编程运行时</a>。</p>
<p><strong>本篇文章不会教你任何有关如何创建用户界面的技巧。</strong> 但是它可能会帮助你更深入地理解 React 编程模型。</p>
<hr>
<p><strong>注意：如果你还在学习 React ，请移步到<a href="https://reactjs.org/docs/getting-started.html#learn-react">官方文档</a>进行学习</strong></p>
<p><font size="60">⚠️</font></p>
<p><strong>本篇文章将会非常深入 — 所以并不适合初学者阅读。</strong> 在本篇文章中，我会从最佳原则的角度尽可能地阐述 React 编程模型。我不会解释如何使用它 — 而是讲解它的原理。</p>
<p>文章面向有经验的程序员和那些使用过其他 UI 库但在项目中权衡利弊后最终选择了 React 的人，我希望它会对你有所帮助！</p>
<p><strong>许多人成功使用了 React 多年却从未考虑过下面我将要讲述的主题。</strong> 这肯定是从程序员的角度来看待 React ，而不是以<a href="http://mrmrs.cc/writing/2016/04/21/developing-ui/">设计者</a>的角度。但我并不认为站在两个不同的角度来重新认识 React 会有什么坏处。</p>
<p>话不多说，让我们开始深入理解 React 吧！</p>
<hr>
<h2>宿主树</h2>
<p>一些程序输出数字。另一些程序输出诗词。不同的语言和它们的运行时通常会对特定的一组用例进行优化，而 React 也不例外。</p>
<p>React 程序通常会输出<strong>一棵会随时间变化的树。</strong> 它有可能是一棵 <a href="https://www.npmjs.com/package/react-dom">DOM 树</a> ，<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/Devpedia-CocoaApp/View%20Hierarchy.html">iOS 视图层</a> ，<a href="https://react-pdf.org/">PDF 原语</a> ，又或是 <a href="https://reactjs.org/docs/test-renderer.html">JSON 对象</a> 。然而，通常我们希望用它来展示 UI 。我们称它为“宿主树”，因为它往往是 React 之外宿主环境中的一部分 — 就像 DOM 或 iOS 。宿主树通常有<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild">它</a><a href="https://developer.apple.com/documentation/uikit/uiview/1622616-addsubview">自己</a>的命令式 API 。而 React 就是它上面的那一层。</p>
<p>所以到底 React 有什么用呢？非常抽象地，它可以帮助你编写可预测的，并且能够操控复杂的宿主树进而响应像用户交互、网络响应、定时器等外部事件的应用程序。</p>
<p>当专业的工具可以施加特定的约束且能从中获益时，它比一般的工具要好。React 就是这样的典范，并且它坚持两个原则：</p>
<ul>
<li><strong>稳定性。</strong> 宿主树是相对稳定的，大多数情况的更新并不会从根本上改变其整体结构。如果应用程序每秒都会将其所有可交互的元素重新排列为完全不同的组合，那将会变得难以使用。那个按钮去哪了？为什么我的屏幕在跳舞？</li>
<li><strong>通用性。</strong> 宿主树可以被拆分为外观和行为一致的 UI 模式（例如按钮、列表和头像）而不是随机的形状。</li>
</ul>
<p><strong>这些原则恰好适用于大多数 UI 。</strong> 然而，当输出没有稳定的“模式”时 React 并不适用。例如，React 也许可以帮助你编写一个 Twitter 客户端，但对于一个 <a href="https://www.youtube.com/watch?v=Uzx9ArZ7MUU">3D 管道屏幕保护程序</a> 并不会起太大作用。</p>
<h2>宿主实例</h2>
<p>宿主树由节点组成，我们称之为“宿主实例”。</p>
<p>在 DOM 环境中，宿主实例就是我们通常所说的 DOM 节点 — 就像当你调用 <code>document.createElement('div')</code> 时获得的对象。在 iOS 中，宿主实例可以是从 JavaScript 到原生视图唯一标识的值。</p>
<p>宿主实例有它们自己的属性（例如 <code>domNode.className</code> 或者 <code>view.tintColor</code> ）。它们也有可能将其他的宿主实例作为子项。</p>
<p>（这和 React 没有任何联系 — 因为我在讲述宿主环境。）</p>
<p>通常会有原生的 API 用于操控这些宿主实例。例如，在 DOM 环境中会提供像 <code>appendChild</code>、<code>removeChild</code>、<code>setAttribute</code> 等一系列的 API 。在 React 应用中，通常你不会调用这些 API ，因为那是 React 的工作。</p>
<h2>渲染器</h2>
<p>渲染器教会 React 如何与特定的宿主环境通信以及如何管理它的宿主实例。React DOM、React Native 甚至 <a href="https://mobile.twitter.com/vadimdemedes/status/1089344289102942211">Ink</a> 都可以称作 React 渲染器。你也可以<a href="https://github.com/facebook/react/tree/master/packages/react-reconciler">创建自己的 React 渲染器</a> 。</p>
<p>React 渲染器能以下面两种模式之一进行工作。</p>
<p>绝大多数渲染器都被用作“突变”模式。这种模式正是 DOM 的工作方式：我们可以创建一个节点，设置它的属性，在之后往里面增加或者删除子节点。宿主实例是完全可变的。</p>
<p>但 React 也能以”不变“模式工作。这种模式适用于那些并不提供像 <code>appendChild</code> 的 API 而是克隆双亲树并始终替换掉顶级子树的宿主环境。在宿主树级别上的不可变性使得多线程变得更加容易。<a href="https://facebook.github.io/react-native/blog/2018/06/14/state-of-react-native-2018">React Fabric</a> 就利用了这一模式。</p>
<p>作为 React 的使用者，你永远不需要考虑这些模式。我只想强调 React 不仅仅只是从一种模式转换到另一种模式的适配器。它的用处在于以一种更好的方式操控宿主实例而不用在意那些低级视图 API 范例。</p>
<h2>React 元素</h2>
<p>在宿主环境中，一个宿主实例（例如 DOM 节点）是最小的构建单元。而在 React 中，最小的构建单元是 React 元素。</p>
<p>React 元素是一个普通的 JavaScript 对象。它用来描述一个宿主实例。</p>
<pre   class="language-jsx"><code class="language-jsx">// JSX 是用来描述这些对象的语法糖。
// &lt;button className=&quot;blue&quot; /&gt;
{
  type: 'button',
  props: { className: 'blue' }
}
</code></pre><p>React 元素是轻量级的因为没有宿主实例与它绑定在一起。同样的，它只是对你想要在屏幕上看到的内容的描述。</p>
<p>就像宿主实例一样，React 元素也能形成一棵树：</p>
<pre   class="language-jsx"><code class="language-jsx">// JSX 是用来描述这些对象的语法糖。
// &lt;dialog&gt;
//   &lt;button className=&quot;blue&quot; /&gt;
//   &lt;button className=&quot;red&quot; /&gt;
// &lt;/dialog&gt;
{
  type: 'dialog',
  props: {
    children: [{
      type: 'button',
      props: { className: 'blue' }
    }, {
      type: 'button',
      props: { className: 'red' }
    }]
  }
}
</code></pre><p><em>(注意：我省略了一些对此解释不重要的<a href="/why-do-react-elements-have-typeof-property/">属性</a>)</em></p>
<p>但是，请记住 <strong>React 元素并不是永远存在的</strong> 。它们总是在重建和删除之间不断循环着。</p>
<p>React 元素具有不可变性。例如，你不能改变 React 元素中的子元素或者属性。如果你想要在稍后渲染一些不同的东西，你需要从头创建新的 React 元素树来描述它。</p>
<p>我喜欢将 React 元素比作电影中放映的每一帧。它们捕捉 UI 在特定的时间点应该是什么样子。它们永远不会再改变。</p>
<h2>入口</h2>
<p>每一个 React 渲染器都有一个“入口”。正是那个特定的 API 让我们告诉 React ，将特定的 React 元素树渲染到真正的宿主实例中去。</p>
<p>例如，React DOM 的入口就是 <code>ReactDOM.render</code> ：</p>
<pre   class="language-jsx"><code class="language-jsx">ReactDOM.render(
  // { type: 'button', props: { className: 'blue' } }
  &lt;button className=&quot;blue&quot; /&gt;,
  document.getElementById('container')
);
</code></pre><p>当我们调用 <code>ReactDOM.render(reactElement, domContainer)</code> 时，我们的意思是：<strong>“亲爱的 React ，将我的 <code>reactElement</code> 映射到 <code>domContaienr</code> 的宿主树上去吧。“</strong></p>
<p>React 会查看 <code>reactElement.type</code> （在我们的例子中是 <code>button</code> ）然后告诉 React DOM 渲染器创建对应的宿主实例并设置正确的属性：</p>
<pre data-line="3,4,"  3,4="" class="language-jsx"><code 3,4="" class="language-jsx">// 在 ReactDOM 渲染器内部（简化版）
function createHostInstance(reactElement) {
  let domNode = document.createElement(reactElement.type);
  domNode.className = reactElement.props.className;
  return domNode;
}
</code></pre><p>在我们的例子中，React 会这样做：</p>
<pre data-line="1,2,"  1,2="" class="language-jsx"><code 1,2="" class="language-jsx">let domNode = document.createElement('button');
domNode.className = 'blue';

domContainer.appendChild(domNode);
</code></pre><p>如果 React 元素在 <code>reactElement.props.children</code> 中含有子元素，React 会在第一次渲染中递归地为它们创建宿主实例。</p>
<h2>协调</h2>
<p>如果我们用同一个 container 调用 <code>ReactDOM.render()</code> 两次会发生什么呢？</p>
<pre data-line="2,11,"  2,11="" class="language-jsx"><code 2,11="" class="language-jsx">ReactDOM.render(
  &lt;button className=&quot;blue&quot; /&gt;,
  document.getElementById('container')
);

// ... 之后 ...

// 应该替换掉 button 宿主实例吗？
// 还是在已有的 button 上更新属性？
ReactDOM.render(
  &lt;button className=&quot;red&quot; /&gt;,
  document.getElementById('container')
);
</code></pre><p>同样的，React 的工作是将 React 元素树映射到宿主树上去。确定该对宿主实例做什么来响应新的信息有时候叫做<a href="https://reactjs.org/docs/reconciliation.html">协调</a> 。</p>
<p>有两种方法可以解决它。简化版的 React 会丢弃已经存在的树然后从头开始创建它：</p>
<pre   class="language-jsx"><code class="language-jsx">let domContainer = document.getElementById('container');
// 清除掉原来的树
domContainer.innerHTML = '';
// 创建新的宿主实例树
let domNode = document.createElement('button');
domNode.className = 'red';
domContainer.appendChild(domNode);
</code></pre><p>但是在 DOM 环境下，这样的做法效率低下而且会丢失像 focus、selection、scroll 等许多状态。相反，我们希望 React 这样做：</p>
<pre   class="language-jsx"><code class="language-jsx">let domNode = domContainer.firstChild;
// 更新已有的宿主实例
domNode.className = 'red';
</code></pre><p>换句话说，React 需要决定何时更新一个已有的宿主实例来匹配新的 React 元素，何时该重新创建新的宿主实例。</p>
<p>这就引出了一个识别问题。React 元素可能每次都不相同，到底什么时候才该从概念上引用同一个宿主实例呢？</p>
<p>在我们的例子中，它很简单。我们之前渲染了 <code>&lt;button&gt;</code> 作为第一个（也是唯一）的子元素，接下来我们想要在同一个地方再次渲染 <code>&lt;button&gt;</code> 。在宿主实例中我们已经有了一个 <code>&lt;button&gt;</code> 为什么还要重新创建呢？让我们重用它。</p>
<p>这与 React 如何思考并解决这类问题已经很接近了。</p>
<p><strong>如果相同的元素类型在同一个地方先后出现两次，React 会重用已有的宿主实例。</strong></p>
<p>这里有一个例子，其中的注释大致解释了 React 是如何工作的：</p>
<pre data-line="9,10,16,26,27,"  9,10,16,26,27="" class="language-jsx"><code 9,10,16,26,27="" class="language-jsx">// let domNode = document.createElement('button');
// domNode.className = 'blue';
// domContainer.appendChild(domNode);
ReactDOM.render(
  &lt;button className=&quot;blue&quot; /&gt;,
  document.getElementById('container')
);

// 能重用宿主实例吗？能！(button → button)
// domNode.className = 'red';
ReactDOM.render(
  &lt;button className=&quot;red&quot; /&gt;,
  document.getElementById('container')
);

// 能重用宿主实例吗？不能！(button → p)
// domContainer.removeChild(domNode);
// domNode = document.createElement('p');
// domNode.textContent = 'Hello';
// domContainer.appendChild(domNode);
ReactDOM.render(
  &lt;p&gt;Hello&lt;/p&gt;,
  document.getElementById('container')
);

// 能重用宿主实例吗？能！(p → p)
// domNode.textContent = 'Goodbye';
ReactDOM.render(
  &lt;p&gt;Goodbye&lt;/p&gt;,
  document.getElementById('container')
);
</code></pre><p>同样的启发式方法也适用于子树。例如，当我们在 <code>&lt;dialog&gt;</code> 中新增两个 <code>&lt;button&gt;</code> ，React 会先决定是否要重用 <code>&lt;dialog&gt;</code> ，然后为每一个子元素重复这个决定步骤。</p>
<h2>条件</h2>
<p>如果 React 在渲染更新前后只重用那些元素类型匹配的宿主实例，那当遇到包含条件语句的内容时又该如何渲染呢？</p>
<p>假设我们只想首先展示一个输入框，但之后要在它之前渲染一条信息：</p>
<pre data-line="12,"  12="" class="language-jsx"><code 12="" class="language-jsx">// 第一次渲染
ReactDOM.render(
  &lt;dialog&gt;
    &lt;input /&gt;
  &lt;/dialog&gt;,
  domContainer
);

// 下一次渲染
ReactDOM.render(
  &lt;dialog&gt;
    &lt;p&gt;I was just added here!&lt;/p&gt;
    &lt;input /&gt;
  &lt;/dialog&gt;,
  domContainer
);
</code></pre><p>在这个例子中，<code>&lt;input&gt;</code> 宿主实例会被重新创建。React 会遍历整个元素树，并将其与先前的版本进行比较：</p>
<ul>
<li><code>dialog → dialog</code> ：能重用宿主实例吗？<strong>能 — 因为类型是匹配的。</strong>
<ul>
<li><code>input → p</code> ：能重用宿主实例吗？<strong>不能，类型改变了！</strong> 需要删除已有的 <code>input</code> 然后重新创建一个 <code>p</code> 宿主实例。</li>
<li><code>(nothing) → input</code> ：需要重新创建一个 <code>input</code> 宿主实例。</li>
</ul>
</li>
</ul>
<p>因此，React 会像这样执行更新：</p>
<pre data-line="1,2,8,9,"  1,2,8,9="" class="language-jsx"><code 1,2,8,9="" class="language-jsx">let oldInputNode = dialogNode.firstChild;
dialogNode.removeChild(oldInputNode);

let pNode = document.createElement('p');
pNode.textContent = 'I was just added here!';
dialogNode.appendChild(pNode);

let newInputNode = document.createElement('input');
dialogNode.appendChild(newInputNode);
</code></pre><p>这样的做法并不科学因为事实上 <code>&lt;input&gt;</code> 并没有被 <code>&lt;p&gt;</code> 所替代 — 它只是移动了位置而已。我们不希望因为重建 DOM 而丢失了 selection、focus 等状态以及其中的内容。</p>
<p>虽然这个问题很容易解决（在下面我会马上讲到），但这个问题在 React 应用中并不常见。而当我们探讨为什么会这样时却很有意思。</p>
<p>事实上，你很少会直接调用 <code>ReactDOM.render</code> 。相反，在 React 应用中程序往往会被拆分成这样的函数：</p>
<pre   class="language-jsx"><code class="language-jsx">function Form({ showMessage }) {
  let message = null;
  if (showMessage) {
    message = &lt;p&gt;I was just added here!&lt;/p&gt;;
  }
  return (
    &lt;dialog&gt;
      {message}
      &lt;input /&gt;
    &lt;/dialog&gt;
  );
}
</code></pre><p>这个例子并不会遇到刚刚我们所描述的问题。让我们用对象注释而不是 JSX 也许可以更好地理解其中的原因。来看一下 <code>dialog</code> 中的子元素树：</p>
<pre data-line="12-15,"  12-15="" class="language-jsx"><code 12-15="" class="language-jsx">function Form({ showMessage }) {
  let message = null;
  if (showMessage) {
    message = {
      type: 'p',
      props: { children: 'I was just added here!' }
    };
  }
  return {
    type: 'dialog',
    props: {
      children: [
        message,
        { type: 'input', props: {} }
      ]
    }
  };
}
</code></pre><p><strong>不管 <code>showMessage</code> 是 <code>true</code> 还是 <code>false</code> ，在渲染的过程中 <code>&lt;input&gt;</code> 总是在第二个孩子的位置且不会改变。</strong></p>
<p>如果 <code>showMessage</code> 从 <code>false</code> 改变为 <code>true</code> ，React 会遍历整个元素树，并与之前的版本进行比较：</p>
<ul>
<li><code>dialog → dialog</code> ：能够重用宿主实例吗？<strong>能 — 因为类型匹配。</strong>
<ul>
<li><code>(null) → p</code> ：需要插入一个新的 <code>p</code> 宿主实例。</li>
<li><code>input → input</code> ：能够重用宿主实例吗？<strong>能 — 因为类型匹配。</strong></li>
</ul>
</li>
</ul>
<p>之后 React 大致会像这样执行代码：</p>
<pre   class="language-jsx"><code class="language-jsx">let inputNode = dialogNode.firstChild;
let pNode = document.createElement('p');
pNode.textContent = 'I was just added here!';
dialogNode.insertBefore(pNode, inputNode);
</code></pre><p>这样一来输入框中的状态就不会丢失了。</p>
<h2>列表</h2>
<p>比较树中同一位置的元素类型对于是否该重用还是重建相应的宿主实例往往已经足够。</p>
<p>但这只适用于当子元素是静止的并且不会重排序的情况。在上面的例子中，即使 <code>message</code> 不存在，我们仍然知道输入框在消息之后，并且再没有其他的子元素。</p>
<p>而当遇到动态列表时，我们不能确定其中的顺序总是一成不变的。</p>
<pre   class="language-jsx"><code class="language-jsx">function ShoppingList({ list }) {
  return (
    &lt;form&gt;
      {list.map(item =&gt; (
        &lt;p&gt;
          You bought {item.name}
          &lt;br /&gt;
          Enter how many do you want: &lt;input /&gt;
        &lt;/p&gt;
      ))}
    &lt;/form&gt;
  )
}
</code></pre><p>如果我们的商品列表被重新排序了，React 只会看到所有的 <code>p</code> 以及里面的 <code>input</code> 拥有相同的类型，并不知道该如何移动它们。（在 React 看来，虽然这些商品本身改变了，但是它们的顺序并没有改变。）</p>
<p>所以 React 会对这十个商品进行类似如下的重排序：</p>
<pre   class="language-jsx"><code class="language-jsx">for (let i = 0; i &lt; 10; i++) {
  let pNode = formNode.childNodes[i];
  let textNode = pNode.firstChild;
  textNode.textContent = 'You bought ' + items[i].name;
}
</code></pre><p>React 只会对其中的每个元素进行更新而不是将其重新排序。这样做会造成性能上的问题和潜在的 bug 。例如，当商品列表的顺序改变时，原本在第一个输入框的内容仍然会存在于现在的第一个输入框中 — 尽管事实上在商品列表里它应该代表着其他的商品！</p>
<p><strong>这就是为什么每次当输出中包含元素数组时，React 都会让你指定一个叫做 <code>key</code> 的属性：</strong></p>
<pre data-line="5,"  5="" class="language-jsx"><code 5="" class="language-jsx">function ShoppingList({ list }) {
  return (
    &lt;form&gt;
      {list.map(item =&gt; (
        &lt;p key={item.productId}&gt;
          You bought {item.name}
          &lt;br /&gt;
          Enter how many do you want: &lt;input /&gt;
        &lt;/p&gt;
      ))}
    &lt;/form&gt;
  )
}
</code></pre><p><code>key</code> 给予 React 判断子元素是否真正相同的能力，即使在渲染前后它在父元素中的位置不是相同的。</p>
<p>当 React 在 <code>&lt;form&gt;</code> 中发现 <code>&lt;p key=&quot;42&quot;&gt;</code> ，它就会检查之前版本中的 <code>&lt;form&gt;</code> 是否同样含有 <code>&lt;p key=&quot;42&quot;&gt;</code> 。即使 <code>&lt;form&gt;</code> 中的子元素们改变位置后，这个方法同样有效。在渲染前后当 key 仍然相同时，React 会重用先前的宿主实例，然后重新排序其兄弟元素。</p>
<p>需要注意的是 <code>key</code> 只与特定的父亲 React 元素相关联，比如 <code>&lt;form&gt;</code> 。React 并不会去匹配父元素不同但 key 相同的子元素。（React 并没有惯用的支持对在不重新创建元素的情况下让宿主实例在不同的父元素之间移动。）</p>
<p>给 <code>key</code> 赋予什么值最好呢？最好的答案就是：<strong>什么时候你会说一个元素不会改变即使它在父元素中的顺序被改变？</strong> 例如，在我们的商品列表中，商品本身的 ID 是区别于其他商品的唯一标识，那么它就最适合作为 <code>key</code> 。</p>
<h2>组件</h2>
<p>我们已经知道函数会返回 React 元素：</p>
<pre   class="language-jsx"><code class="language-jsx">function Form({ showMessage }) {
  let message = null;
  if (showMessage) {
    message = &lt;p&gt;I was just added here!&lt;/p&gt;;
  }
  return (
    &lt;dialog&gt;
      {message}
      &lt;input /&gt;
    &lt;/dialog&gt;
  );
}
</code></pre><p>这些函数被叫做组件。它们让我们可以打造自己的“工具箱”，例如按钮、头像、评论框等等。组件就像 React 的面包和黄油。</p>
<p>组件接受一个参数 — 对象哈希。它包含“props”（“属性”的简称）。在这里 <code>showMessage</code> 就是一个 prop 。它们就像是具名参数一样。</p>
<h2>纯净</h2>
<p>React 组件中对于 props 应该是纯净的。</p>
<pre   class="language-jsx"><code class="language-jsx">function Button(props) {
  // 🔴 没有作用
  props.isActive = true;
}
</code></pre><p>通常来说，突变在 React 中不是惯用的。（我们会在之后讲解如何用更惯用的方式来更新 UI 以响应事件。）</p>
<p>不过，局部的突变是绝对允许的：</p>
<pre data-line="2,5,"  2,5="" class="language-jsx"><code 2,5="" class="language-jsx">function FriendList({ friends }) {
  let items = [];
  for (let i = 0; i &lt; friends.length; i++) {
    let friend = friends[i];
    items.push(
      &lt;Friend key={friend.id} friend={friend} /&gt;
    );
  }
  return &lt;section&gt;{items}&lt;/section&gt;;
}
</code></pre><p>当我们在函数组件内部创建 <code>items</code> 时不管怎样改变它都行，只要这些突变发生在将其作为最后的渲染结果之前。所以并不需要重写你的代码来避免局部突变。</p>
<p>同样地，惰性初始化是被允许的即使它不是完全“纯净”的：</p>
<pre   class="language-jsx"><code class="language-jsx">function ExpenseForm() {
  // 只要不影响其他组件这是被允许的：
  SuperCalculator.initializeIfNotReady();

  // 继续渲染......
}
</code></pre><p>只要调用组件多次是安全的，并且不会影响其他组件的渲染，React 并不关心你的代码是否像严格的函数式编程一样百分百纯净。在 React 中，<a href="https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation">幂等性</a>比纯净性更加重要。</p>
<p>也就是说，在 React 组件中不允许有用户可以直接看到的副作用。换句话说，仅调用函数式组件时不应该在屏幕上产生任何变化。</p>
<h2>递归</h2>
<p>我们该如何在组件中使用组件？组件属于函数因此我们可以直接进行调用：</p>
<pre   class="language-jsx"><code class="language-jsx">let reactElement = Form({ showMessage: true });
ReactDOM.render(reactElement, domContainer);
</code></pre><p>然而，在 React 运行时中这并不是惯用的使用组件的方式。</p>
<p>相反，使用组件惯用的方式与我们已经了解的机制相同 — 即 React 元素。<strong>这意味着不需要你直接调用组件函数，React 会在之后为你做这件事情：</strong></p>
<pre   class="language-jsx"><code class="language-jsx">// { type: Form, props: { showMessage: true } }
let reactElement = &lt;Form showMessage={true} /&gt;;
ReactDOM.render(reactElement, domContainer);
</code></pre><p>然后在 React 内部，你的组件会这样被调用：</p>
<pre   class="language-jsx"><code class="language-jsx">// React 内部的某个地方
let type = reactElement.type; // Form
let props = reactElement.props; // { showMessage: true }
let result = type(props); // 无论 Form 会返回什么
</code></pre><p>组件函数名称按照规定需要大写。当 JSX 转换时看见 <code>&lt;Form&gt;</code> 而不是 <code>&lt;form&gt;</code> ，它让对象 <code>type</code> 本身成为标识符而不是字符串：</p>
<pre   class="language-jsx"><code class="language-jsx">console.log(&lt;form /&gt;.type); // 'form' 字符串
console.log(&lt;Form /&gt;.type); // Form 函数
</code></pre><p>我们并没有全局的注册机制 — 字面上当我们输入 <code>&lt;Form&gt;</code> 时代表着 <code>Form</code> 。如果 <code>Form</code> 在局部作用域中并不存在，你会发现一个 JavaScript 错误，就像平常你使用错误的变量名称一样。</p>
<p><strong>因此，当元素类型是一个函数的时候 React 会做什么呢？它会调用你的组件，然后询问组件想要渲染什么元素。</strong></p>
<p>这个步骤会递归式地执行下去，更详细的描述在<a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html">这里</a> 。总的来说，它会像这样执行：</p>
<ul>
<li><strong>你：</strong> <code>ReactDOM.render(&lt;App /&gt;, domContainer)</code></li>
<li><strong>React：</strong> <code>App</code> ，你想要渲染什么？
<ul>
<li><code>App</code> ：我要渲染包含 <code>&lt;Content&gt;</code> 的 <code>&lt;Layout&gt;</code> 。</li>
</ul>
</li>
<li><strong>React：</strong> <code>&lt;Layout&gt;</code> ，你要渲染什么？
<ul>
<li><code>Layout</code> ：我要在 <code>&lt;div&gt;</code> 中渲染我的子元素。我的子元素是 <code>&lt;Content&gt;</code> 所以我猜它应该渲染到 <code>&lt;div&gt;</code> 中去。</li>
</ul>
</li>
<li><strong>React：</strong> <code>&lt;Content&gt;</code> ，你要渲染什么？
<ul>
<li><code>&lt;Content&gt;</code> ：我要在 <code>&lt;article&gt;</code> 中渲染一些文本和 <code>&lt;Footer&gt;</code> 。</li>
</ul>
</li>
<li><strong>React：</strong> <code>&lt;Footer&gt;</code> ，你要渲染什么？
<ul>
<li><code>&lt;Footer&gt;</code> ：我要渲染含有文本的 <code>&lt;footer&gt;</code> 。</li>
</ul>
</li>
<li><strong>React：</strong> 好的，让我们开始吧：</li>
</ul>
<pre   class="language-jsx"><code class="language-jsx">// 最终的 DOM 结构
&lt;div&gt;
  &lt;article&gt;
    Some text
    &lt;footer&gt;some more text&lt;/footer&gt;
  &lt;/article&gt;
&lt;/div&gt;
</code></pre><p>这就是为什么我们说协调是递归式的。当 React 遍历整个元素树时，可能会遇到元素的 <code>type</code> 是一个组件。React 会调用它然后继续沿着返回的 React 元素下行。最终我们会调用完所有的组件，然后 React 就会知道该如何改变宿主树。</p>
<p>在之前已经讨论过的相同的协调准则，在这一样适用。如果在同一位置的 <code>type</code> 改变了（由索引和可选的 <code>key</code> 决定），React 会删除其中的宿主实例并将其重建。</p>
<h2>控制反转</h2>
<p>你也许会好奇：为什么我们不直接调用组件？为什么要编写 <code>&lt;Form /&gt;</code> 而不是 <code>Form()</code> ？</p>
<p><strong>React 能够做的更好如果它“知晓”你的组件而不是在你递归调用它们之后生成的 React 元素树。</strong></p>
<pre   class="language-jsx"><code class="language-jsx">// 🔴 React 并不知道 Layout 和 Article 的存在。
// 因为你在调用它们。
ReactDOM.render(
  Layout({ children: Article() }),
  domContainer
)

// ✅ React知道 Layout 和 Article 的存在。
// React 来调用它们。
ReactDOM.render(
  &lt;Layout&gt;&lt;Article /&gt;&lt;/Layout&gt;,
  domContainer
)
</code></pre><p>这是一个关于<a href="https://en.wikipedia.org/wiki/Inversion_of_control">控制反转</a>的经典案例。通过让 React 调用我们的组件，我们会获得一些有趣的属性：</p>
<ul>
<li><strong>组件不仅仅只是函数。</strong> React 能够用在树中与组件本身紧密相连的局部状态等特性来增强组件功能。优秀的运行时提供了与当前问题相匹配的基本抽象。就像我们已经提到过的，React 专门针对于那些渲染 UI 树并且能够响应交互的应用。如果你直接调用了组件，你就只能自己来构建这些特性了。</li>
<li><strong>组件类型参与协调。</strong> 通过 React 来调用你的组件，能让它了解更多关于元素树的结构。例如，当你从渲染 <code>&lt;Feed&gt;</code> 页面转到 <code>Profile</code> 页面，React 不会尝试重用其中的宿主实例 — 就像你用 <code>&lt;p&gt;</code> 替换掉 <code>&lt;button&gt;</code> 一样。所有的状态都会丢失 — 对于渲染完全不同的视图时，通常来说这是一件好事。你不会想要在 <code>&lt;PasswordForm&gt;</code> 和  <code>&lt;MessengerChat&gt;</code> 之间保留输入框的状态尽管 <code>&lt;input&gt;</code> 的位置意外地“排列”在它们之间。</li>
<li><strong>React 能够推迟协调。</strong> 如果让 React 控制调用你的组件，它能做很多有趣的事情。例如，它可以让浏览器在组件调用之间做一些工作，这样重渲染大体量的组件树时就<a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">不会阻塞主线程</a>。想要手动编排这个过程而不依赖 React 的话将会十分困难。</li>
<li><strong>更好的可调试性。</strong> 如果组件是库中所重视的一等公民，我们就可以构建<a href="https://github.com/facebook/react-devtools">丰富的开发者工具</a>，用于开发中的自省。</li>
</ul>
<p>让 React 调用你的组件函数还有最后一个好处就是惰性求值。让我们看看它是什么意思。</p>
<h2>惰性求值</h2>
<p>当我们在 JavaScript 中调用函数时，参数往往在函数调用之前被执行。</p>
<pre   class="language-jsx"><code class="language-jsx">// (2) 它会作为第二个计算
eat(
  // (1) 它会首先计算
  prepareMeal()
);
</code></pre><p>这通常是 JavaScript 开发者所期望的因为 JavaScript 函数可能有隐含的副作用。如果我们调用了一个函数，但直到它的结果不知怎地被“使用”后该函数仍没有执行，这会让我们感到十分诧异。</p>
<p>但是，React 组件是<a href="#%E7%BA%AF%E5%87%80">相对</a>纯净的。如果我们知道它的结果不会在屏幕上出现，则完全没有必要执行它。</p>
<p>考虑下面这个含有 <code>&lt;Comments&gt;</code> 的 <code>&lt;Page&gt;</code> 组件：</p>
<pre data-line="11,"  11="" class="language-jsx"><code 11="" class="language-jsx">function Story({ currentUser }) {
  // return {
  //   type: Page,
  //   props: {
  //     user: currentUser,
  //     children: { type: Comments, props: {} }
  //   }
  // }
  return (
    &lt;Page user={currentUser}&gt;
      &lt;Comments /&gt;
    &lt;/Page&gt;
  );
}
</code></pre><p><code>&lt;Page&gt;</code> 组件能够在 <code>&lt;Layout&gt;</code> 中渲染传递给它的子项：</p>
<pre data-line="4,"  4="" class="language-jsx"><code 4="" class="language-jsx">function Page({ currentUser, children }) {
  return (
    &lt;Layout&gt;
      {children}
    &lt;/Layout&gt;
  );
}
</code></pre><p><em>(在 JSX 中 <code>&lt;A&gt;&lt;B /&gt;&lt;/A&gt;</code> 和 <code>&lt;A children={&lt;B /&gt;} /&gt;</code>相同。)</em></p>
<p>但是要是存在提前返回的情况呢？</p>
<pre data-line="2-4,"  2-4="" class="language-jsx"><code 2-4="" class="language-jsx">function Page({ currentUser, children }) {
  if (!currentUser.isLoggedIn) {
    return &lt;h1&gt;Please login&lt;/h1&gt;;
  }
  return (
    &lt;Layout&gt;
      {children}
    &lt;/Layout&gt;
  );
}
</code></pre><p>如果我们像函数一样调用 <code>Comments()</code> ，不管 <code>Page</code> 是否想渲染它们都会被立即执行：</p>
<pre data-line="4,8,"  4,8="" class="language-jsx"><code 4,8="" class="language-jsx">// {
//   type: Page,
//   props: {
//     children: Comments() // 总是调用！
//   }
// }
&lt;Page&gt;
  {Comments()}
&lt;/Page&gt;
</code></pre><p>但是如果我们传递的是一个 React 元素，我们不需要自己执行 <code>Comments</code> ：</p>
<pre data-line="4,8,"  4,8="" class="language-jsx"><code 4,8="" class="language-jsx">// {
//   type: Page,
//   props: {
//     children: { type: Comments }
//   }
// }
&lt;Page&gt;
  &lt;Comments /&gt;
&lt;/Page&gt;
</code></pre><p>让 React 来决定何时以及是否调用组件。如果我们的的 <code>Page</code> 组件忽略自身的 <code>children</code> prop 且相反地渲染了 <code>&lt;h1&gt;Please login&lt;/h1&gt;</code> ，React 不会尝试去调用 <code>Comments</code> 函数。重点是什么？</p>
<p>这很好，因为它既可以让我们避免不必要的渲染也能使我们的代码变得不那么脆弱。（当用户退出登录时，我们并不在乎 <code>Comments</code> 是否被丢弃 — 因为它从没有被调用过。）</p>
<h2>状态</h2>
<p>我们先前提到过关于<a href="#%E5%8D%8F%E8%B0%83">协调</a>和在树中元素概念上的“位置”是如何让 React 知晓是该重用宿主实例还是该重建它。宿主实例能够拥有所有相关的局部状态：focus、selection、input 等等。我们想要在渲染更新概念上相同的 UI 时保留这些状态。我们也想可预测性地摧毁它们，当我们在概念上渲染的是完全不同的东西时（例如从 <code>&lt;SignupForm&gt;</code> 转换到 <code>&lt;MessengerChat&gt;</code>）。</p>
<p><strong>局部状态是如此有用，以至于 React 让你的组件也能拥有它。</strong> 组件仍然是函数但是 React 用对构建 UI 有好处的许多特性增强了它。在树中每个组件所绑定的局部状态就是这些特性之一。</p>
<p>我们把这些特性叫做 Hooks 。例如，<code>useState</code> 就是一个 Hook 。</p>
<pre data-line="2,6,7,"  2,6,7="" class="language-jsx"><code 2,6,7="" class="language-jsx">function Example() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>它返回一对值：当前的状态和更新该状态的函数。</p>
<p>数组的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring">解构语法</a>让我们可以给状态变量自定义名称。例如，我在这里称它们为 <code>count</code> 和 <code>setCount</code> ，但是它们也可以被称作 <code>banana</code> 和 <code>setBanana</code> 。在这些文字之下，我们会用 <code>setState</code> 来替代第二个值无论它在具体的例子中被称作什么。</p>
<p><em>(你能在 <a href="https://reactjs.org/docs/hooks-intro.html">React 文档</a> 中学习到更多关于 <code>useState</code> 和 其他 Hooks 的知识。)</em></p>
<h2>一致性</h2>
<p>即使我们想将协调过程本身分割成<a href="https://www.youtube.com/watch?v=mDdgfyRB5kg">非阻塞</a>的工作块，我们仍然需要在同步的循环中对真实的宿主实例进行操作。这样我们才能保证用户不会看见半更新状态的 UI ，浏览器也不会对用户不应看到的中间状态进行不必要的布局和样式的重新计算。</p>
<p>这也是为什么 React 将所有的工作分成了”渲染阶段“和”提交阶段“的原因。<em>渲染阶段</em> 是当 React 调用你的组件然后进行协调的时段。在此阶段进行干涉是安全的且在<a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">未来</a>这个阶段将会变成异步的。<em>提交阶段</em> 就是 React 操作宿主树的时候。而这个阶段永远是同步的。</p>
<h2>缓存</h2>
<p>当父组件通过 <code>setState</code> 准备更新时，React 默认会协调整个子树。因为 React 并不知道在父组件中的更新是否会影响到其子代，所以 React 默认保持一致性。这听起来会有很大的性能消耗但事实上对于小型和中型的子树来说，这并不是问题。</p>
<p>当树的深度和广度达到一定程度时，你可以让 React 去<a href="https://en.wikipedia.org/wiki/Memoization">缓存</a>子树并且重用先前的渲染结果当 prop 在浅比较之后是相同时：</p>
<pre data-line="5,"  5="" class="language-jsx"><code 5="" class="language-jsx">function Row({ item }) {
  // ...
}

export default React.memo(Row);
</code></pre><p>现在，在父组件 <code>&lt;Table&gt;</code> 中调用 <code>setState</code> 时如果 <code>&lt;Row&gt;</code> 中的 <code>item</code> 与先前渲染的结果是相同的，React 就会直接跳过协调的过程。</p>
<p>你可以通过 <a href="https://reactjs.org/docs/hooks-reference.html#usememo"><code>useMemo()</code> Hook</a> 获得单个表达式级别的细粒度缓存。该缓存于其相关的组件紧密联系在一起，并且将与局部状态一起被销毁。它只会保留最后一次计算的结果。</p>
<p>默认情况下，React 不会故意缓存组件。许多组件在更新的过程中总是会接收到不同的 props ，所以对它们进行缓存只会造成净亏损。</p>
<h2>原始模型</h2>
<p>令人讽刺地是，React 并没有使用“反应式”的系统来支持细粒度的更新。换句话说，任何在顶层的更新只会触发协调而不是局部更新那些受影响的组件。</p>
<p>这样的设计是有意而为之的。对于 web 应用来说<a href="https://calibreapp.com/blog/time-to-interactive/">交互时间</a>是一个关键指标，而通过遍历整个模型去设置细粒度的监听器只会浪费宝贵的时间。此外，在很多应用中交互往往会导致或小（按钮悬停）或大（页面转换）的更新，因此细粒度的订阅只会浪费内存资源。</p>
<p>React 的设计原则之一就是它可以处理原始数据。如果你拥有从网络请求中获得的一组 JavaScript 对象，你可以将其直接交给组件而无需进行预处理。没有关于可以访问哪些属性的问题，或者当结构有所变化时造成的意外的性能缺损。React 渲染是 O(<em>视图大小</em>) 而不是 O(<em>模型大小</em>) ，并且你可以通过 <a href="https://react-window.now.sh/#/examples/list/fixed-size">windowing</a> 显著地减少视图大小。</p>
<p>有那么一些应用细粒度订阅对它们来说是有用的 — 例如股票代码。这是一个极少见的例子，因为“所有的东西都需要在同一时间内持续更新”。虽然命令式的方法能够优化此类代码，但 React 并不适用于这种情况。同样的，如果你想要解决该问题，你就得在 React 之上自己实现细粒度的订阅。</p>
<p><strong>注意，即使细粒度订阅和“反应式”系统也无法解决一些常见的性能问题。</strong> 例如，渲染一棵很深的树（在每次页面转换的时候发生）而不阻塞浏览器。改变跟踪并不会让它变得更快 — 这样只会让其变得更慢因为我们执行了额外的订阅工作。另一个问题是我们需要等待返回的数据在渲染视图之前。在 React 中，我们用<a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">并发渲染</a>来解决这些问题。</p>
<h2>批量更新</h2>
<p>一些组件也许想要更新状态来响应同一事件。下面这个例子是假设的，但是却说明了一个常见的模式：</p>
<pre data-line="4,14,"  4,14="" class="language-jsx"><code 4,14="" class="language-jsx">function Parent() {
  let [count, setCount] = useState(0);
  return (
    &lt;div onClick={() =&gt; setCount(count + 1)}&gt;
      Parent clicked {count} times
      &lt;Child /&gt;
    &lt;/div&gt;
  );
}

function Child() {
  let [count, setCount] = useState(0);
  return (
    &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
      Child clicked {count} times
    &lt;/button&gt;
  );
}
</code></pre><p>当事件被触发时，子组件的 <code>onClick</code> 首先被触发（同时触发了它的 <code>setState</code> ）。然后父组件在它自己的 <code>onClick</code> 中调用 <code>setState</code> 。</p>
<p>如果 React 立即重渲染组件以响应 <code>setState</code> 调用，最终我们会重渲染子组件两次：</p>
<pre data-line="4,8,"  4,8="" class="language-jsx"><code 4,8="" class="language-jsx">*** 进入 React 浏览器 click 事件处理过程 ***
Child (onClick)
  - setState
  - re-render Child // 😞 不必要的重渲染
Parent (onClick)
  - setState
  - re-render Parent
  - re-render Child
*** 结束 React 浏览器 click 事件处理过程 ***
</code></pre><p>第一次 <code>Child</code> 组件渲染是浪费的。并且我们也不会让 React 跳过 <code>Child</code> 的第二次渲染因为 <code>Parent</code> 可能会传递不同的数据由于其自身的状态更新。</p>
<p><strong>这就是为什么 React 会在组件内所有事件触发完成后再进行批量更新的原因：</strong></p>
<pre   class="language-jsx"><code class="language-jsx">*** 进入 React 浏览器 click 事件处理过程 ***
Child (onClick)
  - setState
Parent (onClick)
  - setState
*** Processing state updates                     ***
  - re-render Parent
  - re-render Child
*** 结束 React 浏览器 click 事件处理过程  ***
</code></pre><p>组件内调用 <code>setState</code> 并不会立即执行重渲染。相反，React 会先触发所有的事件处理器，然后再触发一次重渲染以进行所谓的批量更新。</p>
<p>批量更新虽然有用但可能会让你感到惊讶如果你的代码这样写：</p>
<pre   class="language-jsx"><code class="language-jsx">  const [count, setCounter] = useState(0);

  function increment() {
    setCounter(count + 1);
  }

  function handleClick() {
    increment();
    increment();
    increment();
  }
</code></pre><p>如果我们将 <code>count</code> 初始值设为 <code>0</code> ，上面的代码只会代表三次  <code>setCount(1)</code> 调用。为了解决这个问题，我们给 <code>setState</code> 提供了一个 “updater” 函数作为参数：</p>
<pre   class="language-jsx"><code class="language-jsx">  const [count, setCounter] = useState(0);

  function increment() {
    setCounter(c =&gt; c + 1);
  }

  function handleClick() {
    increment();
    increment();
    increment();
  }
</code></pre><p>React 会将 updater 函数放入队列中，并在之后按顺序执行它们，最终 <code>count</code> 会被设置成 <code>3</code> 并作为一次重渲染的结果。</p>
<p>当状态逻辑变得更加复杂而不仅仅只是少数的 <code>setState</code> 调用时，我建议你使用 <a href="https://reactjs.org/docs/hooks-reference.html#usereducer"><code>useReducer</code> Hook</a> 来描述你的局部状态。它就像 “updater” 的升级模式在这里你可以给每一次更新命名：</p>
<pre   class="language-jsx"><code class="language-jsx">  const [counter, dispatch] = useReducer((state, action) =&gt; {
    if (action === 'increment') {
      return state + 1;
    } else {
      return state;
    }
  }, 0);

  function handleClick() {
    dispatch('increment');
    dispatch('increment');
    dispatch('increment');
  }
</code></pre><p><code>action</code> 字段可以是任意值，尽管对象是常用的选择。</p>
<h2>调用树</h2>
<p>编程语言的运行时往往有<a href="https://medium.freecodecamp.org/understanding-the-javascript-call-stack-861e41ae61d4">调用栈</a> 。当函数 <code>a()</code> 调用 <code>b()</code> ，<code>b()</code> 又调用 <code>c()</code> 时，在 JavaScript 引擎中会有像 <code>[a, b, c]</code> 这样的数据结构来“跟踪”当前的位置以及接下来要执行的代码。一旦 <code>c</code> 函数执行完毕，它的调用栈帧就消失了！因为它不再被需要了。我们返回到函数 <code>b</code> 中。当我们结束函数 <code>a</code> 的执行时，调用栈就被清空。</p>
<p>当然，React 以 JavaScript 运行当然也遵循 JavaScript 的规则。但是我们可以想象在 React 内部有自己的调用栈用来记忆我们当前正在渲染的组件，例如 <code>[App, Page, Layout, Article /* 此刻的位置 */]</code> 。</p>
<p>React 与通常意义上的编程语言进行时不同因为它针对于渲染 UI 树，这些树需要保持“活性”，这样才能使我们与其进行交互。在第一次 <code>ReactDOM.render()</code> 出现之前，DOM 操作并不会执行。</p>
<p>这也许是对隐喻的延伸，但我喜欢把 React 组件当作 “调用树” 而不是 “调用栈” 。当我们调用完 <code>Article</code> 组件，它的 React “调用树” 帧并没有被摧毁。我们需要将局部状态保存以便映射到宿主实例的<a href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7">某个地方</a>。</p>
<p>这些“调用树”帧会随它们的局部状态和宿主实例一起被摧毁，但是只会在<a href="#%E5%8D%8F%E8%B0%83">协调</a>规则认为这是必要的时候执行。如果你曾经读过 React 源码，你就会知道这些帧其实就是 <a href="https://en.wikipedia.org/wiki/Fiber_(computer_science)">Fibers</a> 。</p>
<p>Fibers 是局部状态真正存在的地方。当状态被更新后，React 将其下面的 Fibers 标记为需要进行协调，之后便会调用这些组件。</p>
<h2>上下文</h2>
<p>在 React 中，我们将数据作为 props 传递给其他组件。有些时候，大多数组件需要相同的东西 — 例如，当前选中的可视主题。将它一层层地传递会变得十分麻烦。</p>
<p>在 React 中，我们通过 <a href="https://reactjs.org/docs/context.html">Context</a> 解决这个问题。它就像组件的<a href="http://wiki.c2.com/?DynamicScoping">动态范围</a> ，能让你从顶层传递数据，并让每个子组件在底部能够读取该值，当值变化时还能够进行重新渲染：</p>
<pre   class="language-jsx"><code class="language-jsx">const ThemeContext = React.createContext(
  'light' // 默认值作为后备
);

function DarkApp() {
  return (
    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;
      &lt;MyComponents /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

function SomeDeeplyNestedChild() {
  // 取决于其子组件在哪里被渲染
  const theme = useContext(ThemeContext);
  // ...
}
</code></pre><p>当 <code>SomeDeeplyNestedChild</code> 渲染时， <code>useContext(ThemeContext)</code> 会寻找树中最近的 <code>&lt;ThemeContext.Provider&gt;</code> ，并且使用它的 <code>value</code> 。</p>
<p>(事实上，React 维护了一个上下文栈当其渲染时。)</p>
<p>如果没有 <code>ThemeContext.Provider</code> 存在，<code>useContext(ThemeContext)</code> 调用的结果就会被调用 <code>createContext()</code> 时传递的默认值所取代。在上面的例子中，这个值为 <code>'light'</code> 。</p>
<h2>副作用</h2>
<p>我们在之前提到过 React 组件在渲染过程中不应该有可观察到的副作用。但是有些时候副作用确实必要的。我们也许需要进行管理 focus 状态、用 canvas 画图、订阅数据源等操作。</p>
<p>在 React 中，这些都可以通过声明 effect 来完成：</p>
<pre data-line="4-6,"  4-6="" class="language-jsx"><code 4-6="" class="language-jsx">function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>如果可能，React 会推迟执行 effect 直到浏览器重新绘制屏幕。这是有好处的因为像订阅数据源这样的代码并不会影响<a href="https://calibreapp.com/blog/time-to-interactive/">交互时间</a>和<a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint">首次绘制时间</a> 。</p>
<p>（有一个<a href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect">极少使用</a>的 Hook 能够让你选择退出这种行为并进行一些同步的工作。请尽量避免使用它。）</p>
<p>effect 不只执行一次。当组件第一次展示给用户以及之后的每次更新时它都会被执行。在 effect 中能触及当前的 props 和 state，例如上文例子中的 <code>count</code> 。</p>
<p>effect 可能需要被清理，例如订阅数据源的例子。在订阅之后将其清理，effect 能够返回一个函数：</p>
<pre   class="language-jsx"><code class="language-jsx">  useEffect(() =&gt; {
    DataSource.addSubscription(handleChange);
    return () =&gt; DataSource.removeSubscription(handleChange);
  });
</code></pre><p>React 会在下次调用该 effect 之前执行这个返回的函数，当然是在组件被摧毁之前。</p>
<p>有些时候，在每次渲染中都重新调用 effect 是不符合实际需要的。 你可以告诉 React 如果相应的变量不会改变则跳过此次调用：</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  }, [count]);
</code></pre><p>但是，这往往会成为过早地优化并会造成一些问题如果你不熟悉 JavaScript 中的闭包是如何工作的话。</p>
<p>例如，下面的这段代码是有 bug 的：</p>
<pre   class="language-jsx"><code class="language-jsx">  useEffect(() =&gt; {
    DataSource.addSubscription(handleChange);
    return () =&gt; DataSource.removeSubscription(handleChange);
  }, []);
</code></pre><p>它含有 bug 因为 <code>[]</code> 代表着“不再重新执行这个 effect 。”但是这个 effect 中的 <code>handleChange</code> 是被定义在外面的。<code>handleChange</code> 也许会引用任何的 props 或 state ：</p>
<pre   class="language-jsx"><code class="language-jsx">  function handleChange() {
    console.log(count);
  }
</code></pre><p>如果我们不再让这个 effect 重新调用，<code>handleChange</code> 始终会是第一次渲染时的版本，而其中的 <code>count</code> 也永远只会是 <code>0</code> 。</p>
<p>为了解决这个问题，请保证你声明了特定的依赖数组，它包含<strong>所有</strong>可以改变的东西，即使是函数也不例外：</p>
<pre data-line="4,"  4="" class="language-jsx"><code 4="" class="language-jsx">  useEffect(() =&gt; {
    DataSource.addSubscription(handleChange);
    return () =&gt; DataSource.removeSubscription(handleChange);
  }, [handleChange]);
</code></pre><p>取决于你的代码，在每次渲染后 <code>handleChange</code> 都会不同因此你可能仍然会看到不必要的重订阅。 <a href="https://reactjs.org/docs/hooks-reference.html#usecallback"><code>useCallback</code></a> 能够帮你解决这个问题。或者，你可以直接让它重订阅。例如浏览器中的 <code>addEventListener</code> API 非常快，但为了在组件中避免使用它可能会带来更多的问题而不是其真正的价值。</p>
<p><em>(你能在 <a href="https://reactjs.org/docs/hooks-effect.html">React 文档</a> 中学到更多关于 <code>useEffect</code> 和其他 Hooks 的知识。)</em></p>
<h2>自定义钩子</h2>
<p>由于 <code>useState</code> 和 <code>useEffect</code> 是函数调用，因此我们可以将其组合成自己的 Hooks ：</p>
<pre data-line="2,8,"  2,8="" class="language-jsx"><code 2,8="" class="language-jsx">function MyResponsiveComponent() {
  const width = useWindowWidth(); // 我们自己的 Hook
  return (
    &lt;p&gt;Window width is {width}&lt;/p&gt;
  );
}

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () =&gt; {
      window.removeEventListener('resize', handleResize);
    };
  });
  return width;
}
</code></pre><p>自定义 Hooks 让不同的组件共享可重用的状态逻辑。注意状态本身是不共享的。每次调用 Hook 都只声明了其自身的独立状态。</p>
<p><em>(你能在 <a href="https://reactjs.org/docs/hooks-custom.html">React 文档</a> 中学习更多关于构建自己的 Hooks 的内容。)</em></p>
<h2>静态使用顺序</h2>
<p>你可以把 <code>useState</code> 想象成一个可以定义“React 状态变量”的语法。它并不是真正的语法，当然，我们仍在用 JavaScript 编写应用。但是我们将 React 作为一个运行时环境来看待，因为 React 用 JavaScript 来描绘整个 UI 树，它的特性往往更接近于语言层面。</p>
<p>假设 <code>use</code> 是语法，将其使用在组件函数顶层也就说得通了：</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">// 😉 注意：并不是真的语法
component Example(props) {
  const [count, setCount] = use State(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>当它被放在条件语句中或者组件外时又代表什么呢？</p>
<pre   class="language-jsx"><code class="language-jsx">// 😉 注意：并不是真的语法

// 它是谁的...局部状态？
const [count, setCount] = use State(0);

component Example() {
  if (condition) {
    // 要是 condition 是 false 时会发生什么呢？
    const [count, setCount] = use State(0);
  }

  function handleClick() {
    // 要是离开了组件函数会发生什么？
    // 这和一般的变量又有什么区别呢？
    const [count, setCount] = use State(0);
  }
</code></pre><p>React 状态和在树中与其相关的组件紧密联系在一起。如果 <code>use</code> 是真正的语法当它在组件函数的顶层调用时也能说的通：</p>
<pre   class="language-jsx"><code class="language-jsx">// 😉 注意：并不是真的语法
component Example(props) {
  // 只在这里有效
  const [count, setCount] = use State(0);

  if (condition) {
    // 这会是一个语法错误
    const [count, setCount] = use State(0);
  }
</code></pre><p>这和 <code>import</code> 声明只在模块顶层有用是一样的道理。</p>
<p><strong>当然，<code>use</code> 并不是真正的语法。</strong> （它不会带来很多好处，并且会带来很多摩擦。）</p>
<p>然而，React 的确期望所有的 Hooks 调用只发生在组件的顶部并且不在条件语句中。这些 Hooks 的<a href="https://reactjs.org/docs/hooks-rules.html">规则</a>能够被 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">linter plugin</a> 所规范。有很多关于这种设计选择的激烈争论，但在实践中我并没有看到它让人困惑。我还写了关于为什么通常提出的替代方案<a href="https://overreacted.io/why-do-hooks-rely-on-call-order/">不起作用</a>的文章。</p>
<p>Hooks 的内部实现其实是<a href="https://dev.to/aspittel/thank-u-next-an-introduction-to-linked-lists-4pph">链表</a> 。当你调用 <code>useState</code> 的时候，我们将指针移到下一项。当我们退出组件的<a href="#%E8%B0%83%E7%94%A8%E6%A0%91">“调用树”帧</a>时，会缓存该结果的列表直到下次渲染开始。</p>
<p><a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">这篇文章</a>简要介绍了 Hooks 内部是如何工作的。数组也许是比链表更好解释其原理的模型：</p>
<pre   class="language-jsx"><code class="language-jsx">// 伪代码
let hooks, i;
function useState() {
  i++;
  if (hooks[i]) {
    // 再次渲染时
    return hooks[i];
  }
  // 第一次渲染
  hooks.push(...);
}

// 准备渲染
i = -1;
hooks = fiber.hooks || [];
// 调用组件
YourComponent();
// 缓存 Hooks 的状态
fiber.hooks = hooks;
</code></pre><p><em>(如果你对它感兴趣，真正的代码在<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js">这里</a> 。)</em></p>
<p>这大致就是每个 <code>useState()</code> 如何获得正确状态的方式。就像我们<a href="#%E5%8D%8F%E8%B0%83">之前</a>所知道的，“匹配”对 React 来说并不是什么新的知识 — 这与协调依赖于在渲染前后元素是否匹配是同样的道理。</p>
<h2>未提及的知识</h2>
<p>我们已经触及到 React 运行时环境中几乎所有重要的方面。如果你读完了本篇文章，你可能已经比 90% 的开发者更了解 React ！这一点也没有错！</p>
<p>当然有一些地方我并没有提及到 — 主要是因为我们对它们也不太清楚。React 目前对多道渲染并没有太好的支持，即当父组件的渲染需要子组件提供信息时。<a href="https://reactjs.org/docs/error-boundaries.html">错误处理 API</a> 目前也还没有 Hooks 的版本。这两个问题可能会被一起解决。并发模式在目前看来并不稳定，也有很多关于 Suspense 该如何适应当前版本的有趣问题。也许我会在它们要完成的时候再来讨论，并且 Suspense 已经准备好比 <a href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactlazy-code-splitting-with-suspense">lazy loading</a> 能够做的更多。</p>
<p><strong>我认为 React API 的成功之处在于，即使在没有考虑过上面这些大多数主题的情况下，你也能轻松使用它并且可以走的很远。</strong> 在大多数情况下，像协调这样好的默认特性启发式地为我们做了正确的事情。在你忘记添加 <code>key</code> 这样的属性时，React 能够好心提醒你。</p>
<p>如果你是痴迷于 UI 库的书呆子，我希望这篇文章对你来说会很有趣并且是深入阐明了 React 是如何工作的。又或许你会觉得 React 太过于复杂为此你不会再去深入理解它。不管怎样，我都很乐意在 Twitter 上收到你的消息！谢谢你的阅读。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React as a UI Runtime]]></title>
            <link>/post/react-as-a-ui-runtime</link>
            <guid>/post/react-as-a-ui-runtime</guid>
            <description><![CDATA[An in-depth description of the React programming model.]]></description>
            <content:encoded><![CDATA[<p>Most tutorials introduce React as a UI library. This makes sense because React <em>is</em> a UI library. That’s literally what the tagline says!</p>
<p><img src="./react.png" alt="React homepage screenshot: &quot;A JavaScript library for building user interfaces&quot;"></p>
<p>I’ve written about the challenges of creating <a href="/the-elements-of-ui-engineering/">user interfaces</a> before. But this post talks about React in a different way — more as a <a href="https://en.wikipedia.org/wiki/Runtime_system">programming runtime</a>.</p>
<p><strong>This post won’t teach you anything about creating user interfaces.</strong> But it might help you understand the React programming model in more depth.</p>
<hr>
<p><strong>Note: If you’re <em>learning</em> React, check out <a href="https://reactjs.org/docs/getting-started.html#learn-react">the docs</a> instead.</strong></p>
<p><font size="60">⚠️</font></p>
<p><strong>This is a deep dive — THIS IS NOT a beginner-friendly post.</strong> In this post, I’m describing most of the React programming model from first principles. I don’t explain how to use it — just how it works.</p>
<p>It’s aimed at experienced programmers and folks working on other UI libraries who asked about some tradeoffs chosen in React. I hope you’ll find it useful!</p>
<p><strong>Many people successfully use React for years without thinking about most of these topics.</strong> This is definitely a programmer-centric view of React rather than, say, a <a href="http://mrmrs.cc/writing/2016/04/21/developing-ui/">designer-centric one</a>. But I don’t think it hurts to have resources for both.</p>
<p>With that disclaimer out of the way, let’s go!</p>
<hr>
<h2>Host Tree</h2>
<p>Some programs output numbers. Other programs output poems. Different languages and their runtimes are often optimized for a particular set of use cases, and React is no exception to that.</p>
<p>React programs usually output <strong>a tree that may change over time</strong>. It might be a <a href="https://www.npmjs.com/package/react-dom">DOM tree</a>, an <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/Devpedia-CocoaApp/View%20Hierarchy.html">iOS hierarchy</a>, a tree of <a href="https://react-pdf.org/">PDF primitives</a>, or even of <a href="https://reactjs.org/docs/test-renderer.html">JSON objects</a>. However, usually, we want to represent some UI with it. We’ll call it a “<em>host</em> tree” because it is a part of the <em>host environment</em> outside of React — like DOM or iOS. The host tree usually has <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild">its</a> <a href="https://developer.apple.com/documentation/uikit/uiview/1622616-addsubview">own</a> imperative API. React is a layer on top of it.</p>
<p>So what is React useful for? Very abstractly, it helps you write a program that predictably manipulates a complex host tree in response to external events like interactions, network responses, timers, and so on.</p>
<p>A specialized tool works better than a generic one when it can impose and benefit from particular constraints. React makes a bet on two principles:</p>
<ul>
<li>
<p><strong>Stability.</strong> The host tree is relatively stable and most updates don’t radically change its overall structure. If an app rearranged all its interactive elements into a completely different combination every second, it would be difficult to use. Where did that button go? Why is my screen dancing?</p>
</li>
<li>
<p><strong>Regularity.</strong> The host tree can be broken down into UI patterns that look and behave consistently (such as buttons, lists, avatars) rather than random shapes.</p>
</li>
</ul>
<p><strong>These principles happen to be true for most UIs.</strong> However, React is ill-suited when there are no stable “patterns” in the output. For example, React may help you write a Twitter client but won’t be very useful for a <a href="https://www.youtube.com/watch?v=Uzx9ArZ7MUU">3D pipes screensaver</a>.</p>
<h2>Host Instances</h2>
<p>The host tree consists of nodes. We’ll call them “host instances”.</p>
<p>In the DOM environment, host instances are regular DOM nodes — like the objects you get when you call <code>document.createElement('div')</code>. On iOS, host instances could be values uniquely identifying a native view from JavaScript.</p>
<p>Host instances have their own properties (e.g. <code>domNode.className</code> or <code>view.tintColor</code>). They may also contain other host instances as children.</p>
<p>(This has nothing to do with React — I’m describing the host environments.)</p>
<p>There is usually an API to manipulate host instances. For example, the DOM provides APIs like <code>appendChild</code>, <code>removeChild</code>, <code>setAttribute</code>, and so on. In React apps, you usually don’t call these APIs. That’s the job of React.</p>
<h2>Renderers</h2>
<p>A <em>renderer</em> teaches React to talk to a specific host environment and manage its host instances. React DOM, React Native, and even <a href="https://mobile.twitter.com/vadimdemedes/status/1089344289102942211">Ink</a> are React renderers. You can also <a href="https://github.com/facebook/react/tree/master/packages/react-reconciler">create your own React renderer</a>.</p>
<p>React renderers can work in one of two modes.</p>
<p>The vast majority of renderers are written to use the “mutating” mode. This mode is how the DOM works: we can create a node, set its properties, and later add or remove children from it. The host instances are completely mutable.</p>
<p>React can also work in a <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">“persistent”</a> mode. This mode is for host environments that don’t provide methods like <code>appendChild()</code> but instead clone the parent tree and always replace the top-level child. Immutability on the host tree level makes multi-threading easier. <a href="https://facebook.github.io/react-native/blog/2018/06/14/state-of-react-native-2018">React Fabric</a> takes advantage of that.</p>
<p>As a React user, you never need to think about these modes. I only want to highlight that React isn’t just an adapter from one mode to another. Its usefulness is orthogonal to the target low-level view API paradigm.</p>
<h2>React Elements</h2>
<p>In the host environment, a host instance (like a DOM node) is the smallest building block. In React, the smallest building block is a <em>React element</em>.</p>
<p>A React element is a plain JavaScript object. It can <em>describe</em> a host instance.</p>
<pre   class="language-jsx"><code class="language-jsx">// JSX is a syntax sugar for these objects.
// &lt;button className=&quot;blue&quot; /&gt;
{
  type: 'button',
  props: { className: 'blue' }
}
</code></pre><p>A React element is lightweight and has no host instance tied to it. Again, it is merely a <em>description</em> of what you want to see on the screen.</p>
<p>Like host instances, React elements can form a tree:</p>
<pre   class="language-jsx"><code class="language-jsx">// JSX is a syntax sugar for these objects.
// &lt;dialog&gt;
//   &lt;button className=&quot;blue&quot; /&gt;
//   &lt;button className=&quot;red&quot; /&gt;
// &lt;/dialog&gt;
{
  type: 'dialog',
  props: {
    children: [{
      type: 'button',
      props: { className: 'blue' }
    }, {
      type: 'button',
      props: { className: 'red' }
    }]
  }
}
</code></pre><p><em>(Note: I omitted <a href="/why-do-react-elements-have-typeof-property/">some properties</a> that aren’t important to this explanation.)</em></p>
<p>However, remember that <strong>React elements don’t have their own persistent identity.</strong> They’re meant to be re-created and thrown away all the time.</p>
<p>React elements are immutable. For example, you can’t change the children or a property of a React element. If you want to render something different later, you will <em>describe</em> it with a new React element tree created from scratch.</p>
<p>I like to think of React elements as being like frames in a movie. They capture what the UI should look like at a specific point in time. They don’t change.</p>
<h2>Entry Point</h2>
<p>Each React renderer has an “entry point”. It’s the API that lets us tell React to render a particular React element tree inside a container host instance.</p>
<p>For example, React DOM entry point is <code>ReactDOM.render</code>:</p>
<pre   class="language-jsx"><code class="language-jsx">ReactDOM.render(
  // { type: 'button', props: { className: 'blue' } }
  &lt;button className=&quot;blue&quot; /&gt;,
  document.getElementById('container')
);
</code></pre><p>When we say <code>ReactDOM.render(reactElement, domContainer)</code>, we mean: <strong>“Dear React, make the <code>domContainer</code> host tree match my <code>reactElement</code>.”</strong></p>
<p>React will look at the <code>reactElement.type</code> (in our example, <code>'button'</code>) and ask the React DOM renderer to create a host instance for it and set the properties:</p>
<pre data-line="3,4,"  3,4="" class="language-jsx"><code 3,4="" class="language-jsx">// Somewhere in the ReactDOM renderer (simplified)
function createHostInstance(reactElement) {
  let domNode = document.createElement(reactElement.type);
  domNode.className = reactElement.props.className;
  return domNode;
}
</code></pre><p>In our example, effectively React will do this:</p>
<pre data-line="1,2,"  1,2="" class="language-jsx"><code 1,2="" class="language-jsx">let domNode = document.createElement('button');
domNode.className = 'blue';

domContainer.appendChild(domNode);
</code></pre><p>If the React element has child elements in <code>reactElement.props.children</code>, React will recursively create host instances for them too on the first render.</p>
<h2>Reconciliation</h2>
<p>What happens if we call <code>ReactDOM.render()</code> twice with the same container?</p>
<pre data-line="2,11,"  2,11="" class="language-jsx"><code 2,11="" class="language-jsx">ReactDOM.render(
  &lt;button className=&quot;blue&quot; /&gt;,
  document.getElementById('container')
);

// ... later ...

// Should this *replace* the button host instance
// or merely update a property on an existing one?
ReactDOM.render(
  &lt;button className=&quot;red&quot; /&gt;,
  document.getElementById('container')
);
</code></pre><p>Again, React’s job is to <em>make the host tree match the provided React element tree</em>. The process of figuring out <em>what</em> to do to the host instance tree in response to new information is sometimes called <a href="https://reactjs.org/docs/reconciliation.html">reconciliation</a>.</p>
<p>There are two ways to go about it. A simplified version of React could blow away the existing tree and re-create it from scratch:</p>
<pre   class="language-jsx"><code class="language-jsx">let domContainer = document.getElementById('container');
// Clear the tree
domContainer.innerHTML = '';
// Create the new host instance tree
let domNode = document.createElement('button');
domNode.className = 'red';
domContainer.appendChild(domNode);
</code></pre><p>But in DOM, this is slow and loses important information like focus, selection, scroll state, and so on. Instead, we want React to do something like this:</p>
<pre   class="language-jsx"><code class="language-jsx">let domNode = domContainer.firstChild;
// Update existing host instance
domNode.className = 'red';
</code></pre><p>In other words, React needs to decide when to <em>update</em> an existing host instance to match a new React element, and when to create a <em>new</em> one.</p>
<p>This raises a question of <em>identity</em>. The React element may be different every time, but when does it refer to the same host instance conceptually?</p>
<p>In our example, it’s simple. We used to render a <code>&lt;button&gt;</code> as a first (and only) child, and we want to render a <code>&lt;button&gt;</code> in the same place again. We already have a <code>&lt;button&gt;</code> host instance there so why re-create it? Let’s just reuse it.</p>
<p>This is pretty close to how React thinks about it.</p>
<p><strong>If an element type in the same place in the tree “matches up” between the previous and the next renders, React reuses the existing host instance.</strong></p>
<p>Here is an example with comments showing roughly what React does:</p>
<pre data-line="9,10,16,26,27,"  9,10,16,26,27="" class="language-jsx"><code 9,10,16,26,27="" class="language-jsx">// let domNode = document.createElement('button');
// domNode.className = 'blue';
// domContainer.appendChild(domNode);
ReactDOM.render(
  &lt;button className=&quot;blue&quot; /&gt;,
  document.getElementById('container')
);

// Can reuse host instance? Yes! (button → button)
// domNode.className = 'red';
ReactDOM.render(
  &lt;button className=&quot;red&quot; /&gt;,
  document.getElementById('container')
);

// Can reuse host instance? No! (button → p)
// domContainer.removeChild(domNode);
// domNode = document.createElement('p');
// domNode.textContent = 'Hello';
// domContainer.appendChild(domNode);
ReactDOM.render(
  &lt;p&gt;Hello&lt;/p&gt;,
  document.getElementById('container')
);

// Can reuse host instance? Yes! (p → p)
// domNode.textContent = 'Goodbye';
ReactDOM.render(
  &lt;p&gt;Goodbye&lt;/p&gt;,
  document.getElementById('container')
);
</code></pre><p>The same heuristic is used for child trees. For example, when we update a <code>&lt;dialog&gt;</code> with two <code>&lt;button&gt;</code>s inside, React first decides whether to re-use the <code>&lt;dialog&gt;</code>, and then repeats this decision procedure for each child.</p>
<h2>Conditions</h2>
<p>If React only reuses host instances when the element types “match up” between updates, how can we render conditional content?</p>
<p>Say we want to first show only an input, but later render a message before it:</p>
<pre data-line="12,"  12="" class="language-jsx"><code 12="" class="language-jsx">// First render
ReactDOM.render(
  &lt;dialog&gt;
    &lt;input /&gt;
  &lt;/dialog&gt;,
  domContainer
);

// Next render
ReactDOM.render(
  &lt;dialog&gt;
    &lt;p&gt;I was just added here!&lt;/p&gt;
    &lt;input /&gt;
  &lt;/dialog&gt;,
  domContainer
);
</code></pre><p>In this example, the <code>&lt;input&gt;</code> host instance would get re-created. React would walk the element tree, comparing it with the previous version:</p>
<ul>
<li><code>dialog → dialog</code>: Can reuse the host instance? <strong>Yes — the type matches.</strong>
<ul>
<li><code>input → p</code>: Can reuse the host instance? <strong>No, the type has changed!</strong> Need to remove the existing <code>input</code> and create a new <code>p</code> host instance.</li>
<li><code>(nothing) → input</code>: Need to create a new <code>input</code> host instance.</li>
</ul>
</li>
</ul>
<p>So effectively the update code executed by React would be like:</p>
<pre data-line="1,2,8,9,"  1,2,8,9="" class="language-jsx"><code 1,2,8,9="" class="language-jsx">let oldInputNode = dialogNode.firstChild;
dialogNode.removeChild(oldInputNode);

let pNode = document.createElement('p');
pNode.textContent = 'I was just added here!';
dialogNode.appendChild(pNode);

let newInputNode = document.createElement('input');
dialogNode.appendChild(newInputNode);
</code></pre><p>This is not great because <em>conceptually</em> the <code>&lt;input&gt;</code> hasn’t been <em>replaced</em> with <code>&lt;p&gt;</code> — it just moved. We don’t want to lose its selection, focus state, and content due to re-creating the DOM.</p>
<p>While this problem has an easy fix (which we’ll get to in a minute), it doesn’t occur often in React applications. It’s interesting to see why.</p>
<p>In practice, you would rarely call <code>ReactDOM.render</code> directly. Instead, React apps tend to be broken down into functions like this:</p>
<pre   class="language-jsx"><code class="language-jsx">function Form({ showMessage }) {
  let message = null;
  if (showMessage) {
    message = &lt;p&gt;I was just added here!&lt;/p&gt;;
  }
  return (
    &lt;dialog&gt;
      {message}
      &lt;input /&gt;
    &lt;/dialog&gt;
  );
}
</code></pre><p>This example doesn’t suffer from the problem we just described. It might be easier to see why if we use object notation instead of JSX. Look at the <code>dialog</code> child element tree:</p>
<pre data-line="12-15,"  12-15="" class="language-jsx"><code 12-15="" class="language-jsx">function Form({ showMessage }) {
  let message = null;
  if (showMessage) {
    message = {
      type: 'p',
      props: { children: 'I was just added here!' }
    };
  }
  return {
    type: 'dialog',
    props: {
      children: [
        message,
        { type: 'input', props: {} }
      ]
    }
  };
}
</code></pre><p><strong>Regardless of whether <code>showMessage</code> is <code>true</code> or <code>false</code>, the <code>&lt;input&gt;</code> is the second child and doesn’t change its tree position between renders.</strong></p>
<p>If <code>showMessage</code> changes from <code>false</code> to <code>true</code>, React would walk the element tree, comparing it with the previous version:</p>
<ul>
<li><code>dialog → dialog</code>: Can reuse the host instance? <strong>Yes — the type matches.</strong>
<ul>
<li><code>(null) → p</code>: Need to insert a new <code>p</code> host instance.</li>
<li><code>input → input</code>: Can reuse the host instance? <strong>Yes — the type matches.</strong></li>
</ul>
</li>
</ul>
<p>And the code executed by React would be similar to this:</p>
<pre   class="language-jsx"><code class="language-jsx">let inputNode = dialogNode.firstChild;
let pNode = document.createElement('p');
pNode.textContent = 'I was just added here!';
dialogNode.insertBefore(pNode, inputNode);
</code></pre><p>No input state is lost now.</p>
<h2>Lists</h2>
<p>Comparing the element type at the same position in the tree is usually enough to decide whether to reuse or re-create the corresponding host instance.</p>
<p>But this only works well if child positions are static and don’t re-order. In our example above, even though <code>message</code> could be a “hole”, we still knew that the input goes after the message, and there are no other children.</p>
<p>With dynamic lists, we can’t be sure the order is ever the same:</p>
<pre   class="language-jsx"><code class="language-jsx">function ShoppingList({ list }) {
  return (
    &lt;form&gt;
      {list.map(item =&gt; (
        &lt;p&gt;
          You bought {item.name}
          &lt;br /&gt;
          Enter how many do you want: &lt;input /&gt;
        &lt;/p&gt;
      ))}
    &lt;/form&gt;
  )
}
</code></pre><p>If the <code>list</code> of our shopping items is ever re-ordered, React will see that all <code>p</code> and <code>input</code> elements inside have the same type, and won’t know to move them. (From React’s point of view, the <em>items themselves</em> changed, not their order.)</p>
<p>The code executed by React to re-order 10 items would be something like:</p>
<pre   class="language-jsx"><code class="language-jsx">for (let i = 0; i &lt; 10; i++) {
  let pNode = formNode.childNodes[i];
  let textNode = pNode.firstChild;
  textNode.textContent = 'You bought ' + items[i].name;
}
</code></pre><p>So instead of <em>re-ordering</em> them, React would effectively <em>update</em> each of them. This can create performance issues and possible bugs. For example, the content of the first input would stay reflected in first input <em>after</em> the sort — even though conceptually they might refer to different products in your shopping list!</p>
<p><strong>This is why React nags you to specify a special property called <code>key</code> every time you include an array of elements in your output:</strong></p>
<pre data-line="5,"  5="" class="language-jsx"><code 5="" class="language-jsx">function ShoppingList({ list }) {
  return (
    &lt;form&gt;
      {list.map(item =&gt; (
        &lt;p key={item.productId}&gt;
          You bought {item.name}
          &lt;br /&gt;
          Enter how many do you want: &lt;input /&gt;
        &lt;/p&gt;
      ))}
    &lt;/form&gt;
  )
}
</code></pre><p>A <code>key</code> tells React that it should consider an item to be <em>conceptually</em> the same even if it has different <em>positions</em> inside its parent element between renders.</p>
<p>When React sees <code>&lt;p key=&quot;42&quot;&gt;</code> inside a <code>&lt;form&gt;</code>, it will check if the previous render also contained <code>&lt;p key=&quot;42&quot;&gt;</code> inside the same <code>&lt;form&gt;</code>. This works even if <code>&lt;form&gt;</code> children changed their order. React will reuse the previous host instance with the same key if it exists, and re-order the siblings accordingly.</p>
<p>Note that the <code>key</code> is only relevant within a particular parent React element, such as a <code>&lt;form&gt;</code>. React won’t try to “match up” elements with the same keys between different parents. (React doesn’t have idiomatic support for moving a host instance between different parents without re-creating it.)</p>
<p>What’s a good value for a <code>key</code>? An easy way to answer this is to ask: <strong>when would <em>you</em> say an item is the “same” even if the order changed?</strong> For example, in our shopping list, the product ID uniquely identifies it between siblings.</p>
<h2>Components</h2>
<p>We’ve already seen functions that return React elements:</p>
<pre   class="language-jsx"><code class="language-jsx">function Form({ showMessage }) {
  let message = null;
  if (showMessage) {
    message = &lt;p&gt;I was just added here!&lt;/p&gt;;
  }
  return (
    &lt;dialog&gt;
      {message}
      &lt;input /&gt;
    &lt;/dialog&gt;
  );
}
</code></pre><p>They are called <em>components</em>. They let us create our own “toolbox” of buttons, avatars, comments, and so on. Components are the bread and butter of React.</p>
<p>Components take one argument — an object hash. It contains “props” (short for “properties”). Here, <code>showMessage</code> is a prop. They’re like named arguments.</p>
<h2>Purity</h2>
<p>React components are assumed to be pure with respect to their props.</p>
<pre   class="language-jsx"><code class="language-jsx">function Button(props) {
  // 🔴 Doesn't work
  props.isActive = true;
}
</code></pre><p>In general, mutation is not idiomatic in React. (We’ll talk more about the idiomatic way to update the UI in response to events later.)</p>
<p>However, <em>local mutation</em> is absolutely fine:</p>
<pre data-line="2,5,"  2,5="" class="language-jsx"><code 2,5="" class="language-jsx">function FriendList({ friends }) {
  let items = [];
  for (let i = 0; i &lt; friends.length; i++) {
    let friend = friends[i];
    items.push(
      &lt;Friend key={friend.id} friend={friend} /&gt;
    );
  }
  return &lt;section&gt;{items}&lt;/section&gt;;
}
</code></pre><p>We created <code>items</code> <em>while rendering</em> and no other component “saw” it so we can mutate it as much as we like before handing it off as part of the render result. There is no need to contort your code to avoid local mutation.</p>
<p>Similarly, lazy initialization is fine despite not being fully “pure”:</p>
<pre   class="language-jsx"><code class="language-jsx">function ExpenseForm() {
  // Fine if it doesn't affect other components:
  SuperCalculator.initializeIfNotReady();

  // Continue rendering...
}
</code></pre><p>As long as calling a component multiple times is safe and doesn’t affect the rendering of other components, React doesn’t care if it’s 100% pure in the strict FP sense of the word. <a href="https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation">Idempotence</a> is more important to React than purity.</p>
<p>That said, side effects that are directly visible to the user are not allowed in React components. In other words, merely <em>calling</em> a component function shouldn’t by itself produce a change on the screen.</p>
<h2>Recursion</h2>
<p>How do we <em>use</em> components from other components? Components are functions so we <em>could</em> call them:</p>
<pre   class="language-jsx"><code class="language-jsx">let reactElement = Form({ showMessage: true });
ReactDOM.render(reactElement, domContainer);
</code></pre><p>However, this is <em>not</em> the idiomatic way to use components in the React runtime.</p>
<p>Instead, the idiomatic way to use a component is with the same mechanism we’ve already seen before — React elements. <strong>This means that you don’t directly call the component function, but instead let React later do it for you</strong>:</p>
<pre   class="language-jsx"><code class="language-jsx">// { type: Form, props: { showMessage: true } }
let reactElement = &lt;Form showMessage={true} /&gt;;
ReactDOM.render(reactElement, domContainer);
</code></pre><p>And somewhere inside React, your component will be called:</p>
<pre   class="language-jsx"><code class="language-jsx">// Somewhere inside React
let type = reactElement.type; // Form
let props = reactElement.props; // { showMessage: true }
let result = type(props); // Whatever Form returns
</code></pre><p>Component function names are by convention capitalized. When the JSX transform sees <code>&lt;Form&gt;</code> rather than <code>&lt;form&gt;</code>, it makes the object <code>type</code> itself an identifier rather than a string:</p>
<pre   class="language-jsx"><code class="language-jsx">console.log(&lt;form /&gt;.type); // 'form' string
console.log(&lt;Form /&gt;.type); // Form function
</code></pre><p>There is no global registration mechanism — we literally refer to <code>Form</code> by name when typing <code>&lt;Form /&gt;</code>. If <code>Form</code> doesn’t exist in local scope, you’ll see a JavaScript error just like you normally would with a bad variable name.</p>
<p><strong>Okay, so what does React do when an element type is a function? It calls your component, and asks what element <em>that</em> component wants to render.</strong></p>
<p>This process continues recursively and is described in more detail <a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html">here</a>. In short, it looks like this:</p>
<ul>
<li><strong>You:</strong> <code>ReactDOM.render(&lt;App /&gt;, domContainer)</code></li>
<li><strong>React:</strong> Hey <code>App</code>, what do you render to?
<ul>
<li><code>App</code>: I render <code>&lt;Layout&gt;</code> with <code>&lt;Content&gt;</code> inside.</li>
</ul>
</li>
<li><strong>React:</strong> Hey <code>Layout</code>, what do you render to?
<ul>
<li><code>Layout</code>: I render my children in a <code>&lt;div&gt;</code>. My child was <code>&lt;Content&gt;</code> so I guess that goes into the <code>&lt;div&gt;</code>.</li>
</ul>
</li>
<li><strong>React:</strong> Hey <code>&lt;Content&gt;</code>, what do you render to?
<ul>
<li><code>Content</code>: I render an <code>&lt;article&gt;</code> with some text and a <code>&lt;Footer&gt;</code> inside.</li>
</ul>
</li>
<li><strong>React:</strong> Hey <code>&lt;Footer&gt;</code>, what do you render to?
<ul>
<li><code>Footer</code>: I render a <code>&lt;footer&gt;</code> with some more text.</li>
</ul>
</li>
<li><strong>React:</strong> Okay, here you go:</li>
</ul>
<pre   class="language-jsx"><code class="language-jsx">// Resulting DOM structure
&lt;div&gt;
  &lt;article&gt;
    Some text
    &lt;footer&gt;some more text&lt;/footer&gt;
  &lt;/article&gt;
&lt;/div&gt;
</code></pre><p>This is why we say reconciliation is recursive. When React walks the element tree, it might meet an element whose <code>type</code> is a component. It will call it and keep descending down the tree of returned React elements. Eventually, we’ll run out of components, and React will know what to change in the host tree.</p>
<p>The same reconciliation rules we already discussed apply here too. If the <code>type</code> at the same position (as determined by index and optional <code>key</code>) changes, React will throw away the host instances inside, and re-create them.</p>
<h2>Inversion of Control</h2>
<p>You might be wondering: why don’t we just call components directly? Why write <code>&lt;Form /&gt;</code> rather than <code>Form()</code>?</p>
<p><strong>React can do its job better if it “knows” about your components rather than if it only sees the React element tree after recursively calling them.</strong></p>
<pre   class="language-jsx"><code class="language-jsx">// 🔴 React has no idea Layout and Article exist.
// You're calling them.
ReactDOM.render(
  Layout({ children: Article() }),
  domContainer
)

// ✅ React knows Layout and Article exist.
// React calls them.
ReactDOM.render(
  &lt;Layout&gt;&lt;Article /&gt;&lt;/Layout&gt;,
  domContainer
)
</code></pre><p>This is a classic example of <a href="https://en.wikipedia.org/wiki/Inversion_of_control">inversion of control</a>. There’s a few interesting properties we get by letting React take control of calling our components:</p>
<ul>
<li>
<p><strong>Components become more than functions.</strong> React can augment component functions with features like <em>local state</em> that are tied to the component identity in the tree. A good runtime provides fundamental abstractions that match the problem at hand. As we already mentioned, React is oriented specifically at programs that render UI trees and respond to interactions. If you called components directly, you’d have to build these features yourself.</p>
</li>
<li>
<p><strong>Component types participate in the reconciliation.</strong> By letting React call your components, you also tell it more about the conceptual structure of your tree. For example, when you move from rendering <code>&lt;Feed&gt;</code> to the <code>&lt;Profile&gt;</code> page, React won’t attempt to re-use host instances inside them — just like when you replace <code>&lt;button&gt;</code> with a <code>&lt;p&gt;</code>. All state will be gone — which is usually good when you render a conceptually different view. You wouldn't want to preserve input state between <code>&lt;PasswordForm&gt;</code> and <code>&lt;MessengerChat&gt;</code> even if the <code>&lt;input&gt;</code> position in the tree accidentally “lines up” between them.</p>
</li>
<li>
<p><strong>React can delay the reconciliation.</strong> If React takes control over calling our components, it can do many interesting things. For example, it can let the browser do some work between the component calls so that re-rendering a large component tree <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">doesn’t block the main thread</a>. Orchestrating this manually without reimplementing a large part of React is difficult.</p>
</li>
<li>
<p><strong>A better debugging story.</strong> If components are first-class citizens that the library is aware of, we can build <a href="https://github.com/facebook/react-devtools">rich developer tools</a> for introspection in development.</p>
</li>
</ul>
<p>The last benefit to React calling your component functions is <em>lazy evaluation</em>. Let’s see what this means.</p>
<h2>Lazy Evaluation</h2>
<p>When we call functions in JavaScript, arguments are evaluated before the call:</p>
<pre   class="language-jsx"><code class="language-jsx">// (2) This gets computed second
eat(
  // (1) This gets computed first
  prepareMeal()
);
</code></pre><p>This is usually what JavaScript developers expect because JavaScript functions can have implicit side effects. It would be surprising if we called a function, but it wouldn’t execute until its result gets somehow “used” in JavaScript.</p>
<p>However, React components are <a href="#purity">relatively</a> pure. There is absolutely no need to execute it if we know its result won’t get rendered on the screen.</p>
<p>Consider this component putting <code>&lt;Comments&gt;</code> inside a <code>&lt;Page&gt;</code>:</p>
<pre data-line="11,"  11="" class="language-jsx"><code 11="" class="language-jsx">function Story({ currentUser }) {
  // return {
  //   type: Page,
  //   props: {
  //     user: currentUser,
  //     children: { type: Comments, props: {} }
  //   }
  // }
  return (
    &lt;Page user={currentUser}&gt;
      &lt;Comments /&gt;
    &lt;/Page&gt;
  );
}
</code></pre><p>The <code>Page</code> component can render the children given to it inside some <code>Layout</code>:</p>
<pre data-line="4,"  4="" class="language-jsx"><code 4="" class="language-jsx">function Page({ user, children }) {
  return (
    &lt;Layout&gt;
      {children}
    &lt;/Layout&gt;
  );
}
</code></pre><p><em>(<code>&lt;A&gt;&lt;B /&gt;&lt;/A&gt;</code> in JSX is the same as <code>&lt;A children={&lt;B /&gt;} /&gt;</code>.)</em></p>
<p>But what if it has an early exit condition?</p>
<pre data-line="2-4,"  2-4="" class="language-jsx"><code 2-4="" class="language-jsx">function Page({ user, children }) {
  if (!user.isLoggedIn) {
    return &lt;h1&gt;Please log in&lt;/h1&gt;;
  }
  return (
    &lt;Layout&gt;
      {children}
    &lt;/Layout&gt;
  );
}
</code></pre><p>If we called <code>Comments()</code> as a function, it would execute immediately regardless of whether <code>Page</code> wants to render them or not:</p>
<pre data-line="4,8,"  4,8="" class="language-jsx"><code 4,8="" class="language-jsx">// {
//   type: Page,
//   props: {
//     children: Comments() // Always runs!
//   }
// }
&lt;Page&gt;
  {Comments()}
&lt;/Page&gt;
</code></pre><p>But if we pass a React element, we don’t execute <code>Comments</code> ourselves at all:</p>
<pre data-line="4,8,"  4,8="" class="language-jsx"><code 4,8="" class="language-jsx">// {
//   type: Page,
//   props: {
//     children: { type: Comments }
//   }
// }
&lt;Page&gt;
  &lt;Comments /&gt;
&lt;/Page&gt;
</code></pre><p>This lets React decide when and <em>whether</em> to call it. If our <code>Page</code> component ignores its <code>children</code> prop and renders<br>
<code>&lt;h1&gt;Please log in&lt;/h1&gt;</code> instead, React won’t even attempt to call the <code>Comments</code> function. What’s the point?</p>
<p>This is good because it both lets us avoid unnecessary rendering work that would be thrown away, and makes the code less fragile. (We don’t care if <code>Comments</code> throws or not when the user is logged out — it won’t be called.)</p>
<h2>State</h2>
<p>We talked <a href="#reconciliation">earlier</a> about identity and how an element’s conceptual “position” in the tree tells React whether to re-use a host instance or create a new one. Host instances can have all kinds of local state: focus, selection, input, etc. We want to preserve this state between updates that conceptually render the same UI. We also want to predictably destroy it when we render something conceptually different (such as moving from <code>&lt;SignupForm&gt;</code> to <code>&lt;MessengerChat&gt;</code>).</p>
<p><strong>Local state is so useful that React lets <em>your own</em> components have it too.</strong> Components are still functions but React augments them with features that are useful for UIs. Local state tied to the position in the tree is one of these features.</p>
<p>We call these features <em>Hooks</em>. For example, <code>useState</code> is a Hook.</p>
<pre data-line="2,6,7,"  2,6,7="" class="language-jsx"><code 2,6,7="" class="language-jsx">function Example() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>It returns a pair of values: the current state and a function that updates it.</p>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring">array destructuring</a> syntax lets us give arbitrary names to our state variables. For example, I called this pair <code>count</code> and <code>setCount</code>, but it could’ve been <code>banana</code> and <code>setBanana</code>. In the text below, I will use <code>setState</code> to refer to the second value regardless of its actual name in the specific examples.</p>
<p><em>(You can learn more about <code>useState</code> and other Hooks provided by React <a href="https://reactjs.org/docs/hooks-intro.html">here</a>.)</em></p>
<h2>Consistency</h2>
<p>Even if we want to split the reconciliation process itself into <a href="https://www.youtube.com/watch?v=mDdgfyRB5kg">non-blocking</a> chunks of work, we should still perform the actual host tree operations in a single synchronous swoop. This way we can ensure that the user doesn’t see a half-updated UI, and that the browser doesn’t perform unnecessary layout and style recalculation for intermediate states that the user shouldn’t see.</p>
<p>This is why React splits all work into the “render phase” and the “commit phase”. <em>Render phase</em> is when React calls your components and performs reconciliation. It is safe to interrupt and <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">in the future</a> will be asynchronous. <em>Commit phase</em> is when React touches the host tree. It is always synchronous.</p>
<h2>Memoization</h2>
<p>When a parent schedules an update by calling <code>setState</code>, by default React reconciles its whole child subtree. This is because React can’t know whether an update in the parent would affect the child or not, and by default, React opts to be consistent. This may sound very expensive but in practice, it’s not a problem for small and medium-sized subtrees.</p>
<p>When trees get too deep or wide, you can tell React to <a href="https://en.wikipedia.org/wiki/Memoization">memoize</a> a subtree and reuse previous render results during shallow equal prop changes:</p>
<pre data-line="5,"  5="" class="language-jsx"><code 5="" class="language-jsx">function Row({ item }) {
  // ...
}

export default React.memo(Row);
</code></pre><p>Now <code>setState</code> in a parent <code>&lt;Table&gt;</code> component would skip over reconciling <code>Row</code>s whose <code>item</code> is referentially equal to the <code>item</code> rendered last time.</p>
<p>You can get fine-grained memoization at the level of individual expressions with the <a href="https://reactjs.org/docs/hooks-reference.html#usememo"><code>useMemo()</code> Hook</a>. The cache is local to component tree position and will be destroyed together with its local state. It only holds one last item.</p>
<p>React intentionally doesn’t memoize components by default. Many components always receive different props so memoizing them would be a net loss.</p>
<h2>Raw Models</h2>
<p>Ironically, React doesn’t use a “reactivity” system for fine-grained updates. In other words, any update at the top triggers reconciliation instead of updating just the components affected by changes.</p>
<p>This is an intentional design decision. <a href="https://calibreapp.com/blog/time-to-interactive/">Time to interactive</a> is a crucial metric in consumer web applications, and traversing models to set up fine-grained listeners spends that precious time. Additionally, in many apps, interactions tend to result either in small (button hover) or large (page transition) updates, in which case fine-grained subscriptions are a waste of memory resources.</p>
<p>One of the core design principles of React is that it works with raw data. If you have a bunch of JavaScript objects received from the network, you can pump them directly into your components with no preprocessing. There are no gotchas about which properties you can access, or unexpected performance cliffs when a structure slightly changes. React rendering is O(<em>view size</em>) rather than O(<em>model size</em>), and you can significantly cut the <em>view size</em> with <a href="https://react-window.now.sh/#/examples/list/fixed-size">windowing</a>.</p>
<p>There are some kinds of applications where fine-grained subscriptions are beneficial — such as stock tickers. This is a rare example of “everything constantly updating at the same time”. While imperative escape hatches can help optimize such code, React might not be the best fit for this use case. Still, you can implement your own fine-grained subscription system on top of React.</p>
<p><strong>Note that there are common performance issues that even fine-grained subscriptions and “reactivity” systems can’t solve.</strong> For example, rendering a <em>new</em> deep tree (which happens on every page transition) without blocking the browser. Change tracking doesn’t make it faster — it makes it slower because we have to do more work to set up subscriptions. Another problem is that we have to wait for data before we can start rendering the view. In React, we aim to solve both of these problems with <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Concurrent Rendering</a>.</p>
<h2>Batching</h2>
<p>Several components may want to update state in response to the same event. This example is contrived but it illustrates a common pattern:</p>
<pre data-line="4,14,"  4,14="" class="language-jsx"><code 4,14="" class="language-jsx">function Parent() {
  let [count, setCount] = useState(0);
  return (
    &lt;div onClick={() =&gt; setCount(count + 1)}&gt;
      Parent clicked {count} times
      &lt;Child /&gt;
    &lt;/div&gt;
  );
}

function Child() {
  let [count, setCount] = useState(0);
  return (
    &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
      Child clicked {count} times
    &lt;/button&gt;
  );
}
</code></pre><p>When an event is dispatched, the child’s <code>onClick</code> fires first (triggering its <code>setState</code>). Then the parent calls <code>setState</code> in its own <code>onClick</code> handler.</p>
<p>If React immediately re-rendered components in response to <code>setState</code> calls, we’d end up rendering the child twice:</p>
<pre data-line="4,8,"  4,8="" class="language-jsx"><code 4,8="" class="language-jsx">*** Entering React's browser click event handler ***
Child (onClick)
  - setState
  - re-render Child // 😞 unnecessary
Parent (onClick)
  - setState
  - re-render Parent
  - re-render Child
*** Exiting React's browser click event handler ***
</code></pre><p>The first <code>Child</code> render would be wasted. And we couldn’t make React skip rendering <code>Child</code> for the second time because the <code>Parent</code> might pass some different data to it based on its updated state.</p>
<p><strong>This is why React batches updates inside event handlers:</strong></p>
<pre   class="language-jsx"><code class="language-jsx">*** Entering React's browser click event handler ***
Child (onClick)
  - setState
Parent (onClick)
  - setState
*** Processing state updates                     ***
  - re-render Parent
  - re-render Child
*** Exiting React's browser click event handler  ***
</code></pre><p>The <code>setState</code> calls in components wouldn’t immediately cause a re-render. Instead, React would execute all event handlers first, and then trigger a single re-render batching all of those updates together.</p>
<p>Batching is good for performance but can be surprising if you write code like:</p>
<pre   class="language-jsx"><code class="language-jsx">  const [count, setCount] = useState(0);

  function increment() {
    setCount(count + 1);
  }

  function handleClick() {
    increment();
    increment();
    increment();
  }
</code></pre><p>If we start with <code>count</code> set to <code>0</code>, these would just be three <code>setCount(1)</code> calls. To fix this, <code>setState</code> provides an overload that accepts an “updater” function:</p>
<pre   class="language-jsx"><code class="language-jsx">  const [count, setCount] = useState(0);

  function increment() {
    setCount(c =&gt; c + 1);
  }

  function handleClick() {
    increment();
    increment();
    increment();
  }
</code></pre><p>React would put the updater functions in a queue, and later run them in sequence, resulting in a re-render with <code>count</code> set to <code>3</code>.</p>
<p>When state logic gets more complex than a few <code>setState</code> calls, I recommend expressing it as a local state reducer with the <a href="https://reactjs.org/docs/hooks-reference.html#usereducer"><code>useReducer</code> Hook</a>. It’s like an evolution of this “updater” pattern where each update is given a name:</p>
<pre   class="language-jsx"><code class="language-jsx">  const [counter, dispatch] = useReducer((state, action) =&gt; {
    if (action === 'increment') {
      return state + 1;
    } else {
      return state;
    }
  }, 0);

  function handleClick() {
    dispatch('increment');
    dispatch('increment');
    dispatch('increment');
  }
</code></pre><p>The <code>action</code> argument can be anything, although an object is a common choice.</p>
<h2>Call Tree</h2>
<p>A programming language runtime usually has a <a href="https://medium.freecodecamp.org/understanding-the-javascript-call-stack-861e41ae61d4">call stack</a>. When a function <code>a()</code> calls <code>b()</code> which itself calls <code>c()</code>, somewhere in the JavaScript engine there’s a data structure like <code>[a, b, c]</code> that “keeps track” of where you are and what code to execute next. Once you exit out of <code>c</code>, its call stack frame is gone — poof! It’s not needed anymore. We jump back into <code>b</code>. By the time we exit <code>a</code>, the call stack is empty.</p>
<p>Of course, React itself runs in JavaScript and obeys JavaScript rules. But we can imagine that internally React has some kind of its own call stack to remember which component we are currently rendering, e.g. <code>[App, Page, Layout, Article /* we're here */]</code>.</p>
<p>React is different from a general purpose language runtime because it’s aimed at rendering UI trees. These trees need to “stay alive” for us to interact with them. The DOM doesn’t disappear after our first <code>ReactDOM.render()</code> call.</p>
<p>This may be stretching the metaphor but I like to think of React components as being in a “call tree” rather than just a “call stack”. When we go “out” of the <code>Article</code> component, its React “call tree” frame doesn’t get destroyed. We need to keep the local state and references to the host instances <a href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7">somewhere</a>.</p>
<p>These “call tree” frames <em>are</em> destroyed along with their local state and host instances, but only when the <a href="#reconciliation">reconciliation</a> rules say it’s necessary. If you ever read React source, you might have seen these frames being referred to as <a href="https://en.wikipedia.org/wiki/Fiber_(computer_science)">Fibers</a>.</p>
<p>Fibers are where the local state actually lives. When the state is updated, React marks the Fibers below as needing reconciliation, and calls those components.</p>
<h2>Context</h2>
<p>In React, we pass things down to other components as props. Sometimes, the majority of components need the same thing — for example, the currently chosen visual theme. It gets cumbersome to pass it down through every level.</p>
<p>In React, this is solved by <a href="https://reactjs.org/docs/context.html">Context</a>. It is essentially like <a href="http://wiki.c2.com/?DynamicScoping">dynamic scoping</a> for components. It’s like a wormhole that lets you put something on the top, and have every child at the bottom be able to read it and re-render when it changes.</p>
<pre   class="language-jsx"><code class="language-jsx">const ThemeContext = React.createContext(
  'light' // Default value as a fallback
);

function DarkApp() {
  return (
    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;
      &lt;MyComponents /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

function SomeDeeplyNestedChild() {
  // Depends on where the child is rendered
  const theme = useContext(ThemeContext);
  // ...
}
</code></pre><p>When <code>SomeDeeplyNestedChild</code> renders, <code>useContext(ThemeContext)</code> will look for the closest <code>&lt;ThemeContext.Provider&gt;</code> above it in the tree, and use its <code>value</code>.</p>
<p>(In practice, React maintains a context stack while it renders.)</p>
<p>If there’s no <code>ThemeContext.Provider</code> above, the result of <code>useContext(ThemeContext)</code> call will be the default value specified in the <code>createContext()</code> call. In our example, it is <code>'light'</code>.</p>
<h2>Effects</h2>
<p>We mentioned earlier that React components shouldn’t have observable side effects during rendering. But side effects are sometimes necessary. We may want to manage focus, draw on a canvas, subscribe to a data source, and so on.</p>
<p>In React, this is done by declaring an effect:</p>
<pre data-line="4-6,"  4-6="" class="language-jsx"><code 4-6="" class="language-jsx">function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>When possible, React defers executing effects until after the browser re-paints the screen. This is good because code like data source subscriptions shouldn’t hurt <a href="https://calibreapp.com/blog/time-to-interactive/">time to interactive</a> and <a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint">time to first paint</a>. (There's a <a href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect">rarely used</a> Hook that lets you opt out of that behavior and do things synchronously. Avoid it.)</p>
<p>Effects don’t just run once. They run both after a component is shown to the user for the first time, and after it updates. Effects can close over current props and state, such as with <code>count</code> in the above example.</p>
<p>Effects may require cleanup, such as in case of subscriptions. To clean up after itself, an effect can return a function:</p>
<pre   class="language-jsx"><code class="language-jsx">  useEffect(() =&gt; {
    DataSource.addSubscription(handleChange);
    return () =&gt; DataSource.removeSubscription(handleChange);
  });
</code></pre><p>React will execute the returned function before applying this effect the next time, and also before the component is destroyed.</p>
<p>Sometimes, re-running the effect on every render can be undesirable. You can tell React to <a href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects">skip</a> applying an effect if certain variables didn’t change:</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  }, [count]);
</code></pre><p>However, it is often a premature optimization and can lead to problems if you’re not familiar with how JavaScript closures work.</p>
<p>For example, this code is buggy:</p>
<pre   class="language-jsx"><code class="language-jsx">  useEffect(() =&gt; {
    DataSource.addSubscription(handleChange);
    return () =&gt; DataSource.removeSubscription(handleChange);
  }, []);
</code></pre><p>It is buggy because <code>[]</code> says “don’t ever re-execute this effect”. But the effect closes over <code>handleChange</code> which is defined outside of it. And <code>handleChange</code> might reference any props or state:</p>
<pre   class="language-jsx"><code class="language-jsx">  function handleChange() {
    console.log(count);
  }
</code></pre><p>If we never let the effect re-run, <code>handleChange</code> will keep pointing at the version from the first render, and <code>count</code> will always be <code>0</code> inside of it.</p>
<p>To solve this, make sure that if you specify the dependency array, it includes <strong>all</strong> things that can change, including the functions:</p>
<pre data-line="4,"  4="" class="language-jsx"><code 4="" class="language-jsx">  useEffect(() =&gt; {
    DataSource.addSubscription(handleChange);
    return () =&gt; DataSource.removeSubscription(handleChange);
  }, [handleChange]);
</code></pre><p>Depending on your code, you might still see unnecessary resubscriptions because <code>handleChange</code> itself is different on every render. The <a href="https://reactjs.org/docs/hooks-reference.html#usecallback"><code>useCallback</code></a> Hook can help you with that. Alternatively, you can just let it re-subscribe. For example, browser’s <code>addEventListener</code> API is extremely fast, and jumping through hoops to avoid calling it might cause more problems than it’s worth.</p>
<p><em>(You can learn more about <code>useEffect</code> and other Hooks provided by React <a href="https://reactjs.org/docs/hooks-effect.html">here</a>.)</em></p>
<h2>Custom Hooks</h2>
<p>Since Hooks like <code>useState</code> and <code>useEffect</code> are function calls, we can compose them into our own Hooks:</p>
<pre data-line="2,8,"  2,8="" class="language-jsx"><code 2,8="" class="language-jsx">function MyResponsiveComponent() {
  const width = useWindowWidth(); // Our custom Hook
  return (
    &lt;p&gt;Window width is {width}&lt;/p&gt;
  );
}

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () =&gt; {
      window.removeEventListener('resize', handleResize);
    };
  });
  return width;
}
</code></pre><p>Custom Hooks let different components share reusable stateful logic. Note that the <em>state itself</em> is not shared. Each call to a Hook declares its own isolated state.</p>
<p><em>(You can learn more about writing your own Hooks <a href="https://reactjs.org/docs/hooks-custom.html">here</a>.)</em></p>
<h2>Static Use Order</h2>
<p>You can think of <code>useState</code> as a syntax for defining a “React state variable”. It’s not <em>really</em> a syntax, of course. We’re still writing JavaScript. But we are looking at React as a runtime environment, and because React tailors JavaScript to describing UI trees, its features sometimes live closer to the language space.</p>
<p>If <code>use</code> <em>were</em> a syntax, it would make sense for it to be at the top level:</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">// 😉 Note: not a real syntax
component Example(props) {
  const [count, setCount] = use State(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>What would putting it into a condition or a callback or outside a component even mean?</p>
<pre   class="language-jsx"><code class="language-jsx">// 😉 Note: not a real syntax

// This is local state... of what?
const [count, setCount] = use State(0);

component Example() {
  if (condition) {
    // What happens to it when condition is false?
    const [count, setCount] = use State(0);
  }

  function handleClick() {
    // What happens to it when we leave a function?
    // How is this different from a variable?
    const [count, setCount] = use State(0);
  }
</code></pre><p>React state is local to the <em>component</em> and its identity in the tree. If <code>use</code> were a real syntax it would make sense to scope it to the top-level of a component too:</p>
<pre   class="language-jsx"><code class="language-jsx">// 😉 Note: not a real syntax
component Example(props) {
  // Only valid here
  const [count, setCount] = use State(0);

  if (condition) {
    // This would be a syntax error
    const [count, setCount] = use State(0);
  }
</code></pre><p>This is similar to how <code>import</code> only works at the top level of a module.</p>
<p><strong>Of course, <code>use</code> is not actually a syntax.</strong> (It wouldn’t bring much benefit and would create a lot of friction.)</p>
<p>However, React <em>does</em> expect that all calls to Hooks happen only at the top level of a component and unconditionally. These <a href="https://reactjs.org/docs/hooks-rules.html">Rules of Hooks</a> can be enforced with <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">a linter plugin</a>. There have been heated arguments about this design choice but in practice, I haven’t seen it confusing people. I also wrote about why commonly proposed alternatives <a href="https://overreacted.io/why-do-hooks-rely-on-call-order/">don’t work</a>.</p>
<p>Internally, Hooks are implemented as <a href="https://dev.to/aspittel/thank-u-next-an-introduction-to-linked-lists-4pph">linked lists</a>. When you call <code>useState</code>, we move the pointer to the next item. When we exit the component’s <a href="#call-tree">“call tree” frame</a>, we save the resulting list there until the next render.</p>
<p><a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">This article</a> provides a simplified explanation for how Hooks work internally. Arrays might be an easier mental model than linked lists:</p>
<pre   class="language-jsx"><code class="language-jsx">// Pseudocode
let hooks, i;
function useState() {
  i++;
  if (hooks[i]) {
    // Next renders
    return hooks[i];
  }
  // First render
  hooks.push(...);
}

// Prepare to render
i = -1;
hooks = fiber.hooks || [];
// Call the component
YourComponent();
// Remember the state of Hooks
fiber.hooks = hooks;
</code></pre><p><em>(If you’re curious, the real code is <a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js">here</a>.)</em></p>
<p>This is roughly how each <code>useState()</code> call gets the right state. As we’ve learned <a href="#reconciliation">earlier</a>, “matching things up” isn’t new to React — reconciliation relies on the elements matching up between renders in a similar way.</p>
<h2>What’s Left Out</h2>
<p>We’ve touched on pretty much all important aspects of the React runtime environment. If you finished this page, you probably know React in more detail than 90% of its users. And there’s nothing wrong with that!</p>
<p>There are some parts I left out — mostly because they’re unclear even to us. React doesn’t currently have a good story for multipass rendering, i.e. when the parent render needs information about the children. Also, the <a href="https://reactjs.org/docs/error-boundaries.html">error handling API</a> doesn’t yet have a Hooks version. It’s possible that these two problems can be solved together. Concurrent Mode is not stable yet, and there are interesting questions about how Suspense fits into this picture. Maybe I’ll do a follow-up when they’re fleshed out and Suspense is ready for more than <a href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactlazy-code-splitting-with-suspense">lazy loading</a>.</p>
<p><strong>I think it speaks to the success of React’s API that you can get very far without ever thinking about most of these topics.</strong> Good defaults like the reconciliation heuristics do the right thing in most cases. Warnings, like the <code>key</code> warning, nudge you when you risk shooting yourself in the foot.</p>
<p>If you’re a UI library nerd, I hope this post was somewhat entertaining and clarified how React works in more depth. Or maybe you decided React is too complicated and you’ll never look at it again. In either case, I’d love to hear from you on Twitter! Thank you for reading.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[“Bug-O” 表示法]]></title>
            <link>/post/the-bug-o-notation-zh</link>
            <guid>/post/the-bug-o-notation-zh</guid>
            <description><![CDATA[你的 API 的 🐞(<i>n</i>) 是什么？]]></description>
            <content:encoded><![CDATA[<p>当你在写一些关乎性能的代码时，最好时刻注意它的算法复杂度。算法复杂度通常会用<a href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">大 O 表示法</a>来体现。</p>
<p>大 O 表示法是一种衡量指标：当传入的数据越来越大时，你的代码会变得多慢。举个例子，如果一个排序算法有 O(<i>n<sup>2</sup></i>) 复杂度，对原来量级 50 倍的元素排序，你的代码大约会慢 50<sup>2</sup> = 2,500 倍。大 O 表示法不会给你一个确切的数值，但它能让你更好地理解你的算法的伸缩性。</p>
<p>一些例子：O(<i>n</i>)、O(<i>n</i> log <i>n</i>)、O(<i>n<sup>2</sup></i>) 和 O(<i>n!</i>)。</p>
<p>然而，<strong>这篇文章不是关于算法和性能的</strong>，而是关于 APIs 和调试的。事实证明，设计 API 时也需要考虑类似的事情。</p>
<hr>
<p>我们绝大多数时间都在为我们的代码找 bug 和修 bug。大多数开发者也希望能更快地找到 bug。即便最后 bug 找到了，舒服了，但它也可能消耗了我们一整天的时间，有这个时间都够你完成几个 roadmap 上的事情了。</p>
<p>调试的体验受我们选择的抽象、库和工具的影响。有的 API 和语言设计就能让我们避免一整类的错误，但有的则会制造无尽的麻烦。<strong>但你怎么区分它们呢？</strong></p>
<p>网上许多关于 APIs 的讨论都主要集中在审美上，但那真的<a href="/optimized-for-change/">对实际使用它时的感受没有太大影响</a>。</p>
<p><strong>关于这件事有一个衡量指标，我称它为 <em>Bug-O</em> 表示法:</strong></p>
<p><font size="40">🐞(<i>n</i>)</font></p>
<p>大 O 表示法描述随着数据量增大，你的算法会变得多慢。<em>Bug-O</em> 表示法描述随着代码量的增大，这个 API 会让<strong>你</strong>做一件事变得多慢。</p>
<hr>
<p>来看一个例子，假设下面的代码每次都通过像 <code>node.appendChild()</code> 和 <code>node.removeChild()</code> 这样命令式的操作来手动更新 DOM，并且没有明确的组织结构：</p>
<pre   class="language-jsx"><code class="language-jsx">function trySubmit() {
  // Section 1
  let spinner = createSpinner();
  formStatus.appendChild(spinner);
  submitForm().then(() =&gt; {
  	// Section 2
    formStatus.removeChild(spinner);
    let successMessage = createSuccessMessage();
    formStatus.appendChild(successMessage);
  }).catch(error =&gt; {
  	// Section 3
    formStatus.removeChild(spinner);
    let errorMessage = createErrorMessage(error);
    let retryButton = createRetryButton();
    formStatus.appendChild(errorMessage);
    formStatus.appendChild(retryButton)
    retryButton.addEventListener('click', function() {
      // Section 4
      formStatus.removeChild(errorMessage);
      formStatus.removeChild(retryButton);
      trySubmit();
    });
  })
}
</code></pre><p>问题不在于代码丑不丑，我们暂且不谈代码的美观性。<strong>问题是如果现在这个代码里出现了一个 bug，我都不知道从哪查起。</strong></p>
<p>**取决于回调和事件触发的顺序，整个程序中代码运行的路径组合会非常多，**其中有些能产生正确的结果，有些我可能会看到多个进度条或者什么奇怪的现象，有的时候甚至程序直接就崩溃了。</p>
<p>这个函数有 4 个不同的部分，并且顺序没有保证。根据我粗略的计算，它们的运行顺序大约有 4×3×2×1 = 24 种。如果我们在代码里再添加一些东西，可能会有 8×7×6×5×4×3×2×1 — <em>四万</em>多种组合。你就慢慢调试去吧...</p>
<p><strong>换句话说，它的 Bug-O 是 🐞(<i>n!</i>)</strong>，其中 <em>n</em> 是修改 DOM 的代码片段数。是的，它是阶乘级的。当然，我这里可能不是很严谨。实际情况下不是所有的组合都会发生。不过另一方面，这些代码片段可能会执行多次，whatever... 总之这个代码就是不怎么样，我们可以做得更好。</p>
<hr>
<p>为了改进这个代码的 Bug-O，我们可以限制可能的状态和结果数量。我们不需要使用任何库，只要强化一下代码的结构。比如这样：</p>
<pre   class="language-jsx"><code class="language-jsx">let currentState = {
  step: 'initial', // 'initial' | 'pending' | 'success' | 'error'
};

function trySubmit() {
  if (currentState.step === 'pending') {
    // Don't allow to submit twice
    return;
  }
  setState({ step: 'pending' });
  submitForm().then(() =&gt; {
    setState({ step: 'success' });
  }).catch(error =&gt; {
    setState({ step: 'error', error });
  });
}

function setState(nextState) {
  // Clear all existing children
  formStatus.innerHTML = '';

  currentState = nextState;
  switch (nextState.step) {
    case 'initial':
      break;
    case 'pending':
      formStatus.appendChild(spinner);
      break;
    case 'success':
      let successMessage = createSuccessMessage();
      formStatus.appendChild(successMessage);
      break;
    case 'error':
      let errorMessage = createErrorMessage(nextState.error);
      let retryButton = createRetryButton();
      formStatus.appendChild(errorMessage);
      formStatus.appendChild(retryButton);
      retryButton.addEventListener('click', trySubmit);
      break;
  }
}
</code></pre><p>看起来可能差异不大，甚至更啰嗦了，但是它却戏剧性地让调试变得更简单了。因为这几行：</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">function setState(nextState) {
  // Clear all existing children
  formStatus.innerHTML = '';

  // ... the code adding stuff to formStatus ...
</code></pre><p>通过在做任何操作前清空表单状态，我们保证了所有 DOM 操作都从新开始。这就是为什么我们可以战胜必然发生的<a href="/the-elements-of-ui-engineering/">墒变</a>，通过<em>不让错误积累</em>。这个代码的做法有点像“把它关掉然后再打开”，就是这么神奇。</p>
<p><strong>如果结果有错误，我们只需要往回想一步，看一下上次的 <code>setState</code> 调用。</strong> 调试渲染结果的 Bug-O 是 🐞(<em>n</em>) 其中 <em>n</em> 是渲染相关的代码路径数，在这里即为 4（因为 <code>switch</code> 里有 4 种情况）。</p>
<p>我们可能仍然会在<em>设置</em>状态的时候遇到竞态，但是调试它会比之前更简单，因为每个中间状态都可以被日志记录和检查。我们也可以显式地阻止一些非预期的状态变化：</p>
<pre   class="language-jsx"><code class="language-jsx">function trySubmit() {
  if (currentState.step === 'pending') {
    // Don't allow to submit twice
    return;
  }
</code></pre><p>当然，每次都重置 DOM 也有利有弊。简单地移除然后重建 DOM 会销毁它们的内部状态，让它们失去焦点，在更大型的应用里也会造成严重的性能问题。</p>
<p>这也就是为什么像 React 这样的库会很有帮助了，因为它们只需要让你思考如何从零开始搭建 UI，实际上库的内部却并不是这样做的：</p>
<pre   class="language-jsx"><code class="language-jsx">function FormStatus() {
  let [state, setState] = useState({
    step: 'initial'
  });

  function handleSubmit(e) {
    e.preventDefault();
    if (state.step === 'pending') {
      // Don't allow to submit twice
      return;
    }
    setState({ step: 'pending' });
    submitForm().then(() =&gt; {
      setState({ step: 'success' });
    }).catch(error =&gt; {
      setState({ step: 'error', error });
    });
  }

  let content;
  switch (state.step) {
    case 'pending':
      content = &lt;Spinner /&gt;;
      break;
    case 'success':
      content = &lt;SuccessMessage /&gt;;
      break;
    case 'error':
      content = (
        &lt;&gt;
          &lt;ErrorMessage error={state.error} /&gt;
          &lt;RetryButton onClick={handleSubmit} /&gt;
        &lt;/&gt;
      );
      break;
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      {content}
    &lt;/form&gt;
  );
}
</code></pre><p>代码看起来可能不太一样，但是原则是相同的。组件的抽象强化了指责的边界，因此你不知道其他页面上能影响 DOM 和状态的代码。组件化有助于降低 Bug-O。</p>
<p>事实上，如果一个 React 应用里有任何值在 DOM 上看起来不太对，你都可以跟踪它是从哪里来的，通过一个一个地查看在它之上的组件的代码。不论你的应用有多大，跟踪一个渲染出来的值是 🐞(<em>tree height</em>) 的。</p>
<p><strong>下一次你看到一个有关 API 的讨论，首先考虑：它的常规调试任务的 🐞(<em>n</em>) 是多少？</strong> 现有你十分熟悉的 APIs 和开发原则怎么样？Redux、CSS、继承... 它们都有自己的 Bug-O。</p>
<hr>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The “Bug-O” Notation]]></title>
            <link>/post/the-bug-o-notation</link>
            <guid>/post/the-bug-o-notation</guid>
            <description><![CDATA[What is the 🐞(<i>n</i>) of your API?]]></description>
            <content:encoded><![CDATA[<p>When you write performance-sensitive code, it’s a good idea to keep in mind its algorithmic complexity. It is often expressed with the <a href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">Big-O notation</a>.</p>
<p>Big-O is a measure of <strong>how much slower the code will get as you throw more data at it</strong>. For example, if a sorting algorithm has O(<i>n<sup>2</sup></i>) complexity, sorting ×50 times more items will be roughly 50<sup>2</sup> = 2,500 times slower. Big O doesn’t give you an exact number, but it helps you understand how an algorithm <em>scales</em>.</p>
<p>Some examples: O(<i>n</i>), O(<i>n</i> log <i>n</i>), O(<i>n<sup>2</sup></i>), O(<i>n!</i>).</p>
<p>However, <strong>this post isn’t about algorithms or performance</strong>. It’s about APIs and debugging. It turns out, API design involves very similar considerations.</p>
<hr>
<p>A significant part of our time goes into finding and fixing mistakes in our code. Most developers would like to find bugs faster. As satisfactory as it may be in the end, it sucks to spend the whole day chasing a single bug when you could have implemented something from your roadmap.</p>
<p>Debugging experience influences our choice of abstractions, libraries, and tools. Some API and language designs make a whole class of mistakes impossible. Some create endless problems. <strong>But how can you tell which one is which?</strong></p>
<p>Many online discussions about APIs are primarily concerned with aesthetics. But that <a href="/optimized-for-change/">doesn’t say much</a> about what it feels like to use an API in practice.</p>
<p><strong>I have a metric that helps me think about this. I call it the <em>Bug-O</em> notation:</strong></p>
<p><font size="40">🐞(<i>n</i>)</font></p>
<p>The Big-O describes how much an algorithm slows down as the inputs grow. The <em>Bug-O</em> describes how much an API slows <em>you</em> down as your codebase grows.</p>
<hr>
<p>For example, consider this code that manually updates the DOM over time with imperative operations like <code>node.appendChild()</code> and <code>node.removeChild()</code> and no clear structure:</p>
<pre   class="language-jsx"><code class="language-jsx">function trySubmit() {
  // Section 1
  let spinner = createSpinner();
  formStatus.appendChild(spinner);
  submitForm().then(() =&gt; {
  	// Section 2
    formStatus.removeChild(spinner);
    let successMessage = createSuccessMessage();
    formStatus.appendChild(successMessage);
  }).catch(error =&gt; {
  	// Section 3
    formStatus.removeChild(spinner);
    let errorMessage = createErrorMessage(error);
    let retryButton = createRetryButton();
    formStatus.appendChild(errorMessage);
    formStatus.appendChild(retryButton)
    retryButton.addEventListener('click', function() {
      // Section 4
      formStatus.removeChild(errorMessage);
      formStatus.removeChild(retryButton);
      trySubmit();
    });
  })
}
</code></pre><p>The problem with this code isn’t that it’s “ugly”. We’re not talking about aesthetics. <strong>The problem is that if there is a bug in this code, I don’t know where to start looking.</strong></p>
<p><strong>Depending on the order in which the callbacks and events fire, there is a combinatorial explosion of the number of codepaths this program could take.</strong> In some of them, I’ll see the right messages. In others, I’ll see multiple spinners, failure and error messages together, and possibly crashes.</p>
<p>This function has 4 different sections and no guarantees about their ordering. My very non-scientific calculation tells me there are 4×3×2×1 = 24 different orders in which they could run. If I add four more code segments, it’ll be 8×7×6×5×4×3×2×1 — <em>forty thousand</em> combinations. Good luck debugging that.</p>
<p><strong>In other words, the Bug-O of this approach is 🐞(<i>n!</i>)</strong> where <em>n</em> is the number of code segments touching the DOM. Yeah, that’s a <em>factorial</em>. Of course, I’m not being very scientific here. Not all transitions are possible in practice. But on the other hand, each of these segments can run more than once. <span style="word-break: keep-all">🐞(<em>¯\_(ツ)_/¯</em>)</span> might be more accurate but it’s still pretty bad. We can do better.</p>
<hr>
<p>To improve the Bug-O of this code, we can limit the number of possible states and outcomes. We don't need any library to do this. It’s just a matter of enforcing some structure on our code. Here is one way we could do it:</p>
<pre   class="language-jsx"><code class="language-jsx">let currentState = {
  step: 'initial', // 'initial' | 'pending' | 'success' | 'error'
};

function trySubmit() {
  if (currentState.step === 'pending') {
    // Don't allow to submit twice
    return;
  }
  setState({ step: 'pending' });
  submitForm().then(() =&gt; {
    setState({ step: 'success' });
  }).catch(error =&gt; {
    setState({ step: 'error', error });
  });
}

function setState(nextState) {
  // Clear all existing children
  formStatus.innerHTML = '';

  currentState = nextState;
  switch (nextState.step) {
    case 'initial':
      break;
    case 'pending':
      formStatus.appendChild(spinner);
      break;
    case 'success':
      let successMessage = createSuccessMessage();
      formStatus.appendChild(successMessage);
      break;
    case 'error':
      let errorMessage = createErrorMessage(nextState.error);
      let retryButton = createRetryButton();
      formStatus.appendChild(errorMessage);
      formStatus.appendChild(retryButton);
      retryButton.addEventListener('click', trySubmit);
      break;
  }
}
</code></pre><p>This code might not look too different. It’s even a bit more verbose. But it is <em>dramatically</em> simpler to debug because of this line:</p>
<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">function setState(nextState) {
  // Clear all existing children
  formStatus.innerHTML = '';

  // ... the code adding stuff to formStatus ...
</code></pre><p>By clearing out the form status before doing any manipulations, we ensure that our DOM operations always start from scratch. This is how we can fight the inevitable <a href="/the-elements-of-ui-engineering/">entropy</a> — by <em>not</em> letting the mistakes accumulate. This is the coding equivalent of “turning it off and on again”, and it works amazingly well.</p>
<p><strong>If there is a bug in the output, we only need to think <em>one</em> step back — to the previous <code>setState</code> call.</strong> The Bug-O of debugging a rendering result is 🐞(<em>n</em>) where <em>n</em> is the number of rendering code paths. Here, it’s just four (because we have four cases in a <code>switch</code>).</p>
<p>We might still have race conditions in <em>setting</em> the state, but debugging those is easier because each intermediate state can be logged and inspected. We can also disallow any undesired transitions explicitly:</p>
<pre   class="language-jsx"><code class="language-jsx">function trySubmit() {
  if (currentState.step === 'pending') {
    // Don't allow to submit twice
    return;
  }
</code></pre><p>Of course, always resetting the DOM comes with a tradeoff. Naïvely removing and recreating the DOM every time would destroy its internal state, lose focus, and cause terrible performance problems in larger applications.</p>
<p>That’s why libraries like React can be helpful. They let you <em>think</em> in the paradigm of always recreating the UI from scratch without necessarily doing it:</p>
<pre   class="language-jsx"><code class="language-jsx">function FormStatus() {
  let [state, setState] = useState({
    step: 'initial'
  });

  function handleSubmit(e) {
    e.preventDefault();
    if (state.step === 'pending') {
      // Don't allow to submit twice
      return;
    }
    setState({ step: 'pending' });
    submitForm().then(() =&gt; {
      setState({ step: 'success' });
    }).catch(error =&gt; {
      setState({ step: 'error', error });
    });
  }

  let content;
  switch (state.step) {
    case 'pending':
      content = &lt;Spinner /&gt;;
      break;
    case 'success':
      content = &lt;SuccessMessage /&gt;;
      break;
    case 'error':
      content = (
        &lt;&gt;
          &lt;ErrorMessage error={state.error} /&gt;
          &lt;RetryButton onClick={handleSubmit} /&gt;
        &lt;/&gt;
      );
      break;
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      {content}
    &lt;/form&gt;
  );
}
</code></pre><p>The code may look different, but the principle is the same. The component abstraction enforces boundaries so that you know no <em>other</em> code on the page could mess with its DOM or state. Componentization helps reduce the Bug-O.</p>
<p>In fact, if <em>any</em> value looks wrong in the DOM of a React app, you can trace where it comes from by looking at the code of components above it in the React tree one by one. No matter the app size, tracing a rendered value is 🐞(<em>tree height</em>).</p>
<p><strong>Next time you see an API discussion, consider: what is the 🐞(<em>n</em>) of common debugging tasks in it?</strong> What about existing APIs and principles you’re deeply familiar with? Redux, CSS, inheritance — they all have their own Bug-O.</p>
<hr>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[UI工程的要素]]></title>
            <link>/post/the-elements-of-ui-engineering-zh</link>
            <guid>/post/the-elements-of-ui-engineering-zh</guid>
            <description><![CDATA[UI工程的困难之处?]]></description>
            <content:encoded><![CDATA[<p>在我之前的文章中，我讨论了关于我们存在知识漏洞问题。你们也许会总结为我提倡平庸，并不是，这是很宽的领域。</p>
<p>我坚信你能从任何地方开始学习，并且不需要遵从特定的顺序。但是获取足够的经验还是有很大的价值的。我个人已经对创建用户界面非常感兴趣了。</p>
<p>我一直在思考我真正了解和认为有价值的是什么。当然，我熟悉一些技术（比如<code>JavaScript</code>和<code>React</code>）。但更重要的经验教训是难以捉摸的。我从未试图用语言表达出来。这是我第一次尝试将它们罗列出来并且对它们进行描述。</p>
<hr>
<p>市面上有很多关于技术或库的学习路线。哪个库将在2019流行？2020又会是什么？你应该学习<code>Vue</code>或者<code>React</code>吗？<code>Angular</code>？<code>Redux</code>或者<code>Rx</code>吗？你需要学习<code>Apollo</code>？<code>REST</code>或者<code>GraphQL</code>吗？这是很容易迷茫的。如果作者错了呢？</p>
<p>我学习的最大突破不是学习一门固定的技术。而是，当我在解决一个特定的UI问题时学到了很多。有时，我会在之后发现一些库或者同伴帮助了我。在其他情况下，我会想到自己的解决方案（好的或者坏的）。</p>
<p>理解问题、尝试使用解决方案、应用不同的策略，这些组合使得我获取了最具价值的学习经验。这篇文章主要就是探讨这些问题的。</p>
<hr>
<p>如果你主要工作于用户页面，你可能处理了不少这样的挑战——直接的或使用库。无论如何，我鼓励你创建一个不依赖库的小应用，然后进行复现和解决这些问题。它们都没有一个正确的解。学习来自于探索问题领域和尝试不同可能的权衡。</p>
<p>🤔列举出页面开发中的一些问题，自己思考解决</p>
<hr>
<ul>
<li><strong>一致性（Consistency）。</strong> 你点击了“like”按钮后，文本变成了：“你和你另外的三个朋友喜欢了这篇文章。”你再此点击，文本又变回去了。听起来很简单吧。但是在屏幕上好几个地方都存在这样的标签。也许有一些其他的提示需要改变（例如按钮的背景色）。‘likers’列表已经提前从服务端获取到了，并且当鼠标移上去的时候也应该能够看到你的名字了。如果你导航到另一个屏幕并返回，博客不应该“忘记”它被喜欢过。即使是局部一致性本身，也会带来一些挑战。但是其它的用户可能也会改变我们展示的一些数据（例如喜欢我们正在看的帖子）。我们怎样保证屏幕上不同部分同步相同的数据呢？我们如何以及何时使本地数据与服务器一致，反之亦然？</li>
<li><strong>响应性（Responsiveness）。</strong> 人们只能在有限的时间内忍受他们的行为缺乏反馈。对于手势和滚动等连续性操作，这个限制很低。(即便是跳过一个16ms的帧也会让人感觉很“不爽”。)对于像点击这样的离散操作，有研究表明，用户认为任何小于100ms的延迟都很快。如果一个动作需要更长的时间，我们需要显示一个视觉指示器。但也有一些违反直觉。导致页面布局的“跳跃”或经历几个加载阶段的指示器会让动作感觉比以前更慢。类似地，在20ms内处理交互(以丢帧为代价)比在30ms内处理交互要慢，而且没有删除帧。大脑并不是基准。我们如何保证我们的应用响应不同的输入呢？</li>
<li><strong>延迟（Latency）。</strong> 计算和网络链接都需要时间。有时，如果不影响目标设备的响应能力，我们可以忽略计算成本（确保在低配的设备上测试过你的应用）。但是处理网络延迟是无可避免的——它将消耗几秒钟！我们的应用不能静止等待数据或代码加载。但是那有可能发生在每一个屏幕中。如何在不显示“loading”加载或空白情况下优雅地处理延迟呢？如何避免“跳跃”布局呢？以及如何在每次不“重新连接”代码的情况下更改异步加载项呢？</li>
<li><strong>导航（Navigation）。</strong> 当我们与页面交互时，我们期望UI能够保持“稳定”。事物不应该就在我们眼前消失。导航，无论是在应用程序内部启动（如单击链接），还是由于外部事件（如单击“后退”按钮），都应该遵从这一原则。例如，在配置文件屏幕上的<code>/profile/likes</code>和<code>/profile/following</code>选项卡之间切换不应该清除选项卡视图之外的搜索输入。尽管导航到另一个屏幕中就像走进了一间房间一样。人们期望能够走回去并能找到他们留下的东西。如果你在导航中，单击一个链接，然后返回，你失去了在导航中的位置，这是令人沮丧的——或者等待它再次加载。我们如何在不丢失重要上下文的情况下设计应用程序来处理任意导航。</li>
<li><strong>陈旧（Staleness）。</strong> 通过引入本地缓存，我们可以使“后退”按钮导航立即生效。在缓存中，我们可以“记住”一些数据，以便快捷访问，即使理论上我们可以重新获取它。但是缓存自身也存在着一些问题。缓存可能会过期。如何处理当我改变了一个头像，缓存也应该会更新的问题。如果我创建了一篇新的文章，也应该立即出现在缓存中，否则缓存将是无效的。这将变得困难且容易出错。如果发布失败了呢？缓存在内存中停留多长时间？当我们重新获取提要时，是将新获取的提要与缓存的提要“整合”，还是将缓存丢弃？如何在缓存中表示分页或排序？</li>
<li><strong>熵（Entropy）。</strong> 热力学第二定律是这样说的，随着时间的推移，物质会变得一团糟（嗯，不完全是）。这也同样适用于用户界面。我们不能准确地预测用户交互及其顺序。在任何时间点，我们的应用程序可能处于数量惊人的状态下。我们尽最大努力使结果可预测并且限制我们的设计。我们不想看到一个bug截图，然后疑惑“这是怎样发生的？”。对于N个可能的状态，它们之间有N*(N - 1)个可能的跃迁。例如，如果一个按钮可以处于5种不同的状态之一（正常，激活，悬停，危险，禁用），对于5×4=20个可能的转换，更新按钮的代码必须是正确的——或者禁止其中一些。我们如何控制可能状态的组合爆炸，并使视觉输出可预测？</li>
<li><strong>优先级（Priority）。</strong> 有些事情比其它事情更重要。对话框可能出现在产生它的按钮的“上方”，并“跳出”其内容的剪辑边界。新调度的任务(例如响应单击)可能比已经启动的长时间运行的任务(例如在屏幕折叠下方呈现下一篇文章)更重要。随着我们应用程序的成长，它的部分代码是由不同的人和团队编写的，它们争夺有限的资源，如处理器、网络、屏幕空间和包大小预算。有时您可以根据“重要性”的共享级别对竞争者进行排序，比如CSS z-index属性。<a href="https://blogs.msdn.microsoft.com/oldnewthing/20050607-00/?p=35413">但是它很少有好的结局</a> 每个开发人员都偏颇地认为他们的代码很重要。如果一切都很重要，那么什么都不重要!我们如何让独立的小部件合作，而不是争夺资源?</li>
<li><strong>可访问性（Accessibility）。</strong> 无法访问的网站不是一个小众问题。例如，在英国，每5个人中就有1人患有残疾。（<a href="https://www.abrightclearweb.com/web-accessibility-in-the-uk/">这是一张不错的信息图表</a>）我也有这种感觉。虽然我只有26岁，但我还是很难阅读字体细、对比度低的网站。我试着减少使用触控板的次数，我担心有一天我将不得不通过键盘来浏览功能不佳的网站。我们需要让我们的应用程序对于有困难的人来说不那么可怕——好消息是有很多唾手可得的成果。首先是教育和工具。但我们也需要让产品开发人员做正确的事情。我们可以做些什么来使易访问性成为默认而不是事后考虑?</li>
<li><strong>国际化（Internationalization）。</strong> 我们的应用程序需要在全世界各地运行。人们不仅会说不同的语言，而且我们还需要用产品工程师最少的工作量来支持从右到左的布局。我们如何在不牺牲延迟和响应性的情况下支持不同的语言？</li>
<li><strong>交付（Delivery）。</strong> 我们需要将应用程序代码发送到用户的计算机。我们使用什么传输和格式?这听起来很简单，但是这里有很多权衡。例如，本机应用程序倾向于提前加载所有代码，代价就是使得应用程序变得更大。Web应用程序的初始负载往往较小，但在使用过程中会有更多的延迟。我们如何选择在哪个点引入延迟？我们如何基于使用模式优化我们的交付？最优解需要什么样的数据？</li>
<li><strong>伸缩性（Resilience）。</strong> 如果你是昆虫学者你可能会喜欢bugs，但你可能不喜欢看到它们出现在你的程序中。然而，你的一些bug将不可避免地进入生产环境。然后会发生什么？一些bug会导致错误但定义良好的行为。例如，你的代码可能在某些条件下显示不正确的输出。但是如果渲染代码崩溃了呢?那么我们就不能有意义地继续，因为视觉输出会不一致。一个帖子的崩溃不应该“拉下”整个feed，也不应该让它进入一个导致更多崩溃的半中断状态。我们如何编写代码来隔离渲染和获取失败，并保持应用程序的其余部分运行？容错对于用户界面意味着什么？</li>
<li><strong>抽象（Abstraction）。</strong> 在一个小的应用程序中，我们可以硬编码许多特殊的情况来解决上述问题。但是应用程序往往会增长。我们希望能够<a href="https://overreacted.io/optimized-for-change/">重用、分叉和联接</a>代码的各个部分，使它们能够一起工作。我们想在不同的人熟悉的片段之间定义清晰的界限，避免使经常变化的逻辑过于僵化。我们如何创建隐藏特定UI部分实现细节的抽象？我们如何避免在我们的应用增长过程中再次引入我们刚刚解决的问题？</li>
</ul>
<hr>
<p>当然，还有很多我没有提到的问题。这个列表绝不是详尽的!例如，我没有谈到设计人员和工程协作，或者调试和测试。也许下一次我会写的更详尽。阅读关于这些问题的文章时，很容易想到使用特定的视图库或数据获取库作为解决方案。但是我鼓励你假装这些库不存在，从这个角度再读一遍。您将如何解决这些问题?去试试构建一个小的应用程序吧!(我很乐意看到你在GitHub上做的实验——你可以发推特（Twitter）回复我。)</p>
<p>这些问题的有趣之处在于，它们中的大多数都能以任何规模出现。你可以在诸如typeahead或工具提示这样的小工具中看到它们，也可以在诸如Twitter和Facebook这样的大型应用程序中看到它们。</p>
<p><strong>想想你喜欢使用的应用程序中的一个非试验性的UI元素，仔细检查一下这个问题列表。您能描述一下它的开发人员所选择的一些折衷方案吗?尝试从头创建一个类似的行为!</strong></p>
<p>通过在不使用库的小型应用程序中试验这些问题，我学到了很多关于UI工程的知识。我向任何想对UI工程中权衡利弊的人推荐同样的方法。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Elements of UI Engineering]]></title>
            <link>/post/the-elements-of-ui-engineering</link>
            <guid>/post/the-elements-of-ui-engineering</guid>
            <description><![CDATA[What makes UI engineering difficult?]]></description>
            <content:encoded><![CDATA[<p>In my <a href="/things-i-dont-know-as-of-2018/">previous post</a>, I talked about admitting our knowledge gaps. You might conclude that I suggest settling for mediocrity. I don’t! This is a broad field.</p>
<p>I strongly believe that you can “begin anywhere” and don’t need to learn technologies in any particular order. But I also place great value in gaining expertise. Personally I’ve mostly been interested in creating user interfaces.</p>
<p><strong>I’ve been mulling over what it is that I <em>do</em> know about and consider valuable.</strong> Sure, I’m familiar with a few technologies (e.g. JavaScript and React). But the more important lessons from experience are elusive. I never tried to put them into words. This is my first attempt to catalog and describe some of them.</p>
<hr>
<p>There are plenty of “learning roadmaps” about technologies and libraries. Which library is going to be in vogue in 2019? What about 2020? Should you learn Vue or React? Angular? What about Redux or Rx? Do you need to learn Apollo? REST or GraphQL? It’s easy to get lost. What if the author is wrong?</p>
<p><strong>My biggest learning breakthroughs weren’t about a particular technology.</strong> Rather, I learned the most when I struggled to solve a particular UI problem. Sometimes, I would later discover libraries or patterns that helped me. In other cases, I’d come up with my own solutions (both good and bad ones).</p>
<p>It’s this combination of understanding the <em>problems</em>, experimenting with the <em>solutions</em>, and applying different <em>strategies</em> that led to the most rewarding learning experiences in my life. <strong>This post focuses on just the problems.</strong></p>
<hr>
<p>If you worked a user interface, you’ve likely dealt with at least some of these challenges — either directly or using a library. In either case, I encourage you to create a tiny app with <em>no</em> libraries, and play with reproducing and solving these problems. There’s no one right solution to any of them. Learning comes from exploring the problem space and trying different possible tradeoffs.</p>
<hr>
<ul>
<li>
<p><strong>Consistency.</strong> You click on a “Like” button and the text updates: “You and 3 other friends liked this post.” You click it again, and the text flips back. Sounds easy. But maybe a label like this exists in several places on the screen. Maybe there is some other visual indication (such as the button background) that needs to change. The list of “likers” that was previously fetched from the server and is visible on hover should now include your name. If you navigate to another screen and go back, the post shouldn’t “forget” it was liked. Even local consistency <em>alone</em> creates a set of challenges. But other users might also modify the data we display (e.g. by liking a post we’re viewing). How do we keep the same data in sync on different parts of the screen? How and when do we make the local data consistent with the server, and the other way around?</p>
</li>
<li>
<p><strong>Responsiveness.</strong> People can only tolerate a lack of visual feedback to their actions for a limited time. For <em>continuous</em> actions like gestures and scroll, this limit is low. (Even skipping a single 16ms frame feels “janky”.) For <em>discrete</em> actions like clicks, there is research saying users perceive any &lt; 100ms delays as equally fast. If an action takes longer, we need to show a visual indicator. But there are some counter-intuitive challenges. Indicators that cause the page layout to “jump” or that go through several loading “stages” can make the action <em>feel longer</em> than it was. Similarly, handling an interaction within 20ms at the cost of dropping an animation frame can <em>feel slower</em> than handling it within 30ms and no dropped frames. Brains aren’t benchmarks. How do we keep our apps responsive to different kinds of inputs?</p>
</li>
<li>
<p><strong>Latency.</strong> Both computations and network access take time. <em>Sometimes</em> we can ignore the computational cost if it doesn’t hurt the responsiveness on our target devices (make sure to test your app on the low-end device spectrum). But handling network latency is unavoidable — it can take seconds! Our app can’t just freeze waiting for the data or code to load. This means any action that depends on new data, code, or assets is potentially asynchronous and needs to handle the “loading” case. But that can happen for almost every screen. How do we gracefully handle latency without displaying a “cascade” of spinners or empty “holes”? How do we avoid “jumpy” layout? And how do we change async dependencies without “rewiring” our code every time?</p>
</li>
<li>
<p><strong>Navigation.</strong> We expect that the UI remains “stable” as we interact with it. Things shouldn’t disappear from right under our noses. Navigation, whether started within the app (e.g. clicking a link) or due to an external event (e.g. clicking the “back” button), should also respect this principle. For example, switching between <code>/profile/likes</code> and <code>/profile/follows</code> tabs on a profile screen shouldn’t clear a search input outside the tabbed view. Even navigating to <em>another</em> screen is like walking into a room. People expect to go back later and find things as they left them (with, perhaps, some new items). If you’re in the middle of a feed, click on a profile, and go back, it’s frustrating to lose your position in the feed — or wait for it to load again. How do we architect our app to handle arbitrary navigation without losing important context?</p>
</li>
<li>
<p><strong>Staleness.</strong> We can make the “back” button navigation instant by introducing a local cache. In that cache, we can “remember” some data for quick access even if we could theoretically refetch it. But caching brings its own problems. Caches can get stale. If I change an avatar, it should update in the cache too. If I make a new post, it needs to appear in the cache immediately, or the cache needs to be invalidated. This can become difficult and error-prone. What if the posting fails? How long does the cache stay in memory? When we refetch the feed, do we “stitch” the newly fetched feed with the cached one, or throw the cache away? How is pagination or sorting represented in the cache?</p>
</li>
<li>
<p><strong>Entropy.</strong> The second law of thermodynamics says something like “with time, things turn into a mess” (well, not exactly). This applies to user interfaces too. We can’t predict the exact user interactions and their order. At any point in time, our app may be in one of a mind-boggling number of possible states. We do our best to make the result predictable and limited by our design. We don’t want to look at a bug screenshot and wonder “how did <em>that</em> happen”. For <em>N</em> possible states, there are <em>N×(N–1)</em> possible transitions between them. For example, if a button can be in one of 5 different states (normal, active, hover, danger, disabled), the code updating the button must be correct for 5×4=20 possible transitions — or forbid some of them. How do we tame the combinatorial explosion of possible states and make visual output predictable?</p>
</li>
<li>
<p><strong>Priority.</strong> Some things are more important than others. A dialog might need to appear physically “above” the button that spawned it and “break out” of its container’s clip boundaries. A newly scheduled task (e.g. responding to a click) might be more important than a long-running task that already started (e.g. rendering next posts below the screen fold). As our app grows, parts of its code written by different people and teams compete for limited resources like processor, network, screen estate, and the bundle size budget. Sometimes you can rank the contenders on a shared scale of “importance”, like the CSS <code>z-index</code> property. <a href="https://blogs.msdn.microsoft.com/oldnewthing/20050607-00/?p=35413">But it rarely ends well.</a> Every developer is biased to think <em>their</em> code is important. And if everything is important, then nothing is! How do we get independent widgets to <em>cooperate</em> instead of fighting for resources?</p>
</li>
<li>
<p><strong>Accessibility.</strong> Inaccessible websites are <em>not</em> a niche problem. For example, in UK disability affects 1 in 5 people. <a href="https://www.abrightclearweb.com/web-accessibility-in-the-uk/">(Here’s a nice infographic.)</a> I’ve felt this personally too. Though I’m only 26, I struggle to read websites with thin fonts and low contrast. I try to use the trackpad less often, and I dread the day I’ll have to navigate poorly implemented websites by keyboard. We need to make our apps not horrible to people with difficulties — and the good news is that there’s a lot of low-hanging fruit. It starts with education and tooling. But we also need to make it easy for product developers to do the right thing. What can we do to make accessibility a <em>default</em> rather than an afterthought?</p>
</li>
<li>
<p><strong>Internationalization.</strong> Our app needs to work all over the world. Not only do people speak different languages, but we also need to support right-to-left layouts with the least amount of effort from product engineers. How do we support different languages without sacrificing latency and responsiveness?</p>
</li>
<li>
<p><strong>Delivery.</strong> We need to get our application code to the user’s computer. What transport and format do we use? This might sound straightforward but there are many tradeoffs here. For example, native apps tend to load all code in advance at the cost of a huge app size. Web apps tend to have smaller initial payload at the cost of more latency during use. How do we choose at which point to introduce latency? How do we optimize our delivery based on the usage patterns? What kind of data would we need for an optimal solution?</p>
</li>
<li>
<p><strong>Resilience.</strong> You might like bugs if you’re an entomologist, but you probably don’t enjoy seeing them in your programs. However, some of your bugs will inevitably get to production. What happens then? Some bugs cause wrong but well-defined behavior. For example, maybe your code displays incorrect visual output under some condition. But what if the rendering code <em>crashes</em>? Then we can’t meaningfully continue because the visual output would be inconsistent. A crash rendering a single post shouldn’t “bring down” an entire feed or get it into a semi-broken state that causes further crashes. How do we write code in a way that isolates rendering and fetching failures and keeps the rest of the app running? What does fault tolerance mean for user interfaces?</p>
</li>
<li>
<p><strong>Abstraction.</strong> In a tiny app, we can hardcode a lot of special cases to account for the above problems. But apps tend to grow. We want to be able to <a href="/optimized-for-change/">reuse, fork, and join</a> parts of our code, and work on it collectively. We want to define clear boundaries between the pieces familiar to different people, and avoid making often-changing logic too rigid. How do we create abstractions that hide implementation details of a particular UI part? How do we avoid re-introducing the same problems that we just solved as our app grows?</p>
</li>
</ul>
<hr>
<p>Of course, there are many problems I haven’t mentioned. This list is by no means exhaustive! For example, I haven’t talked about the designer and engineering collaboration, or debugging and testing. Maybe another time.</p>
<p>It’s tempting to read about these problems with a particular view library or a data fetching library in mind as a solution. But I encourage you to pretend that these libraries don’t exist, and read again from that perspective. How would <em>you</em> approach solving these issues? Give them a try on a tiny app! (I’d love to see your experiments on GitHub — feel free to tweet me in response.)</p>
<p>What’s interesting about these problems is that most of them show up at any scale. You can see them both in small widgets like a typeahead or a tooltip, and in huge apps like Twitter and Facebook.</p>
<p><strong>Think of a non-trivial UI element from an app you enjoy using, and go through this list of problems. Can you describe some of the tradeoffs chosen by its developers? Try to recreate a similar behavior from scratch!</strong></p>
<p>I learned a lot about UI engineering by experimenting with these problems in small apps without using libraries. I recommend the same to anyone who wants to gain a deeper appreciation for the tradeoffs in UI engineering.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[聊聊 2018 年我所不了解的技术]]></title>
            <link>/post/things-i-dont-know-as-of-2018-zh</link>
            <guid>/post/things-i-dont-know-as-of-2018-zh</guid>
            <description><![CDATA[承认知识缺口，并不会使我们的知识经验贬值。]]></description>
            <content:encoded><![CDATA[<p>大家总以为我懂得许多技术，但实际情况并非如此。我不是在抱怨什么，这也不是什么坏事。 （尽管少数派朋友们有来之不易的证据，但他们总是受到偏见，这就比较恶心了。）</p>
<p><strong>在这篇文章中，我将列出一份大家经常误以为我很了解的编程主题列表</strong>。我并不是说<em>你</em>不必学习它们 - 或者我不了解<em>其他</em>有用的东西。 但由于我现在的立场并不弱，所以我可以开诚布公地谈。</p>
<p>以下是我认为这很重要的原因。</p>
<hr>
<p>首先，大家有个不现实的期望，认为经验丰富的工程师就该了解所在领域的每一项技术。你应该见过囊括了上百个库和工具的「学习路线图」吧？它很有用 - 但令人望而却步。</p>
<p>更有甚者，无论你经验多丰富，你可能还是会时而感觉良好、时而信心不足（冒名顶替综合症（Impostor syndrome）），时而过度自信（Dunning-Kruger 效应）。这取决于你所处的环境，你的工作，个性，队友，精神状态，做事的时间等等因素。</p>
<p>老练的开发者有时会公开表示他们的不安，以鼓励初学者。但其实二者有天壤之别，就像一个经验丰富但仍会紧张的外科医生，和一个第一次拿手术刀的学生！</p>
<p>听见别人说「我们都是初级开发者」挺丧的，就像是对着与你有知识差距的学习者空谈。像我这样善意的从业者也并不能用多好的口述解决这个问题。</p>
<p>尽管如此，即使是经验丰富的工程师也存在许多知识缺口。这篇文章写了我的知识缺口，我鼓励那些能够接受类似不足的工程师们分享你们的经验见解。但分享的时候，记住不要低估我们的价值。</p>
<p><strong>我们可以大方承认我们的知识缺口，但也要记得我们仍然拥有宝贵的专业知识，这些需要多年努力积累才能获得。</strong></p>
<hr>
<p>先说好免责声明，以下是我不了解的一些东西：</p>
<ul>
<li>
<p><strong>Unix 命令和 Bash（Unix commands and Bash）</strong> 我记得 <code>ls</code> 和 <code>cd</code>, 但其他命令我也得查了才会用。我理解管道（piping）的概念，但我只在简单的场景下使用它。我不知道如何使用 <code>xargs</code> 创建复杂的链（chain），如何组合并重定向不同的输出流。我也从来没有系统地学习过 Bash，所以我只能编写非常简单（通常是错误的）shell 脚本。</p>
</li>
<li>
<p><strong>低级语言（Low-level languages）</strong> 我知道 Assembly 能将内容存储在内存中并跳转执行代码，但我了解的仅此而已。我写过几行 C，明白指针是什么，但我不知道如何使用 <code>malloc</code> 或其他手动内存管理技术。从来没玩过 Rust。</p>
</li>
<li>
<p><strong>网络堆栈（Networking stack）</strong> 我知道计算机有 IP 地址，DNS 是我们解析主机名（hostname）的方式。我知道有像 TCP/IP 这样的低级协议来交换数据包（可能？）以确保完整性。我就知道这么多 - 并且对细节认识比较模糊。</p>
</li>
<li>
<p><strong>容器（Containers）</strong> 我不知道如何使用 Docker 或 Kubernetes。 （它们有关系吗？）我对它们一个模糊的认知，知道它们能让我以可靠的方式启动一个单独的 VM。听起来很酷，但我还没试过。</p>
</li>
<li>
<p><strong>无服务（Serverless）</strong> 听起来也很酷，但没试过。我不是很明白该模型如何改变了后端编程（也许它并没有）。</p>
</li>
<li>
<p><strong>微服务（Microservices）</strong> 如果我理解没错的话，它只是意味着「许多 API endpoints 间相互通信」。我不知道这种方法的实际优缺点是什么，因为我没用过。</p>
</li>
<li>
<p><strong>Python.</strong> 我不是很喜欢它- 我<em>已经</em>用 Python 工作了好多年，而且我从来没有费心力去学它。它的导入（import）行为等很多东西对我来说是完全的黑盒。</p>
</li>
<li>
<p><strong>Node 后端（Node backends）</strong> 我知道如何运行 Node，使用像 <code>fs</code> 这样的 API 来构建工具，并且能使用 Express。但我从来没有用 Node 连接过数据库，也不知道如何用它编写后端。我也不熟悉像 Next 这样能实现「hello world」的 React 框架。</p>
</li>
<li>
<p><strong>原生平台（Native platforms）</strong> 我曾尝试学过 Objective C 但是没有成功。我也没有学过 Swift, Java 也是如此。（虽然我可以学习 Java，因为我会 C#, 但是我并没有学习它）。</p>
</li>
<li>
<p><strong>算法（Algorithms）</strong> 我会的最多就只有冒泡排序以及快排了。如果它们与特定的实际问题联系在一起，我能进行简单的图形遍历。我理解 O(n) 符号，但我的理解并不比「不要在循环中嵌套循环」深刻多少。</p>
</li>
<li>
<p><strong>函数式语言（Functional languages）</strong> 除非算上 JavaScript，否则我不会流畅的使用任何传统函数式语言。 （我只精通 C# 和 JavaScript - C# 的知识我差不多都忘了）。阅读 LISP 风格（如 Clojure），Haskell 风格（如 Elm）或 ML 风格（如 OCaml）的代码也让我觉得吃力。</p>
</li>
<li>
<p><strong>函数式术语（Functional terminology）</strong> 就我而言，Map 和 reduce 是最重要的。我不了解 monoids，functors 等。我知道 monad 是什么（但也许是我的幻觉吧 🤣）。</p>
</li>
<li>
<p><strong>Modern CSS.</strong> 我不了解 Flexbox 或 Grid。Floats 才是我的菜。</p>
</li>
<li>
<p><strong>CSS 方法论（CSS Methodologies）</strong> 我用过 BEM（意思是 CSS 部分，而不是原始的 BEM），但我就知道这么多了。我没有尝试过 OOCSS 或其他方法。</p>
</li>
<li>
<p><strong>SCSS/Sass.</strong> 从来没有学过。</p>
</li>
<li>
<p><strong>CORS.</strong> 我超怕这些错误！我知道得设置一些首部字段（header）来修复它们，但过去我浪费了几个小时做这事情。</p>
</li>
<li>
<p><strong>HTTPS/SSL.</strong> 从未设置过。仅了解公钥私钥的概念，不知道它们是如何运作的。</p>
</li>
<li>
<p><strong>GraphQL.</strong> 我会使用 query，但我真的不知道如何解释 node 和 edge 等东西，何时使用 fragment，以及分页的原理。</p>
</li>
<li>
<p><strong>Sockets.</strong> 我的心智模型是他们实现了计算机在请求/响应模型（request/response model）之外互联，但我就知道这么多。</p>
</li>
<li>
<p><strong>Streams.</strong> 除了 Rx Observables 之外，我还没有密切关注过 stream。我使用一两次旧的 node 流，但总是搞乱错误处理。</p>
</li>
<li>
<p><strong>Electron.</strong> 没试过。</p>
</li>
<li>
<p><strong>TypeScript.</strong> 我理解类型（types）的概念，可以看懂注释，但从来没有写过它。我试过几次，遇到了困难。</p>
</li>
<li>
<p><strong>部署和 DevOps（Deployment and devops）</strong> 我可以通过 FTP 发送文件或杀死进程，但我的 devops 技能仅限于此。</p>
</li>
<li>
<p><strong>图形（Graphics）</strong> 无论是 canvas，SVG，WebGL 还是低级图形，我都没有高效使用过。我了解整体想法，但需要学习原语（primitives）。</p>
</li>
</ul>
<p>当然，这份清单并非详尽无遗。 我不知道的还多着呢。</p>
<hr>
<p>讨论这些可能看起来很奇怪，甚至这篇文章都写得有问题。 我吹嘘自己的无知吗？不，我想表达的是：</p>
<ul>
<li>
<p><strong>即使是你最喜欢的开发者也可能不知道很多你知道的东西。</strong></p>
</li>
<li>
<p><strong>无论你的知识水平如何，不同时期你的信心都会有很大差异。</strong></p>
</li>
<li>
<p><strong>尽管存在知识缺口，但经验丰富的开发者术业有专攻。</strong></p>
</li>
</ul>
<p>我知道我的知识缺口（至少是一部分）。 如果我对某个技术感到好奇，或者项目需要用到，我之后可以学习它。</p>
<p>这不会使我的知识经验贬值。 我可以做很多事情。 例如，在需要的时候再去学它。</p>
<blockquote>
<p>更新: 在 <a href="/the-elements-of-ui-engineering/">UI 工程的元素</a>中，我写了一些我掌握的技术。</p>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Things I Don’t Know as of 2018]]></title>
            <link>/post/things-i-dont-know-as-of-2018</link>
            <guid>/post/things-i-dont-know-as-of-2018</guid>
            <description><![CDATA[We can admit our knowledge gaps without devaluing our expertise.]]></description>
            <content:encoded><![CDATA[<p>People often assume that I know far more than I actually do. That’s not a bad problem to have and I’m not complaining. (Folks from minority groups often suffer the opposite bias despite their hard-earned credentials, and that <em>sucks</em>.)</p>
<p><strong>In this post I’ll offer an incomplete list of programming topics that people often wrongly assume that I know.</strong> I’m not saying <em>you</em> don’t need to learn them — or that I don’t know <em>other</em> useful things. But since I’m not in a vulnerable position myself right now, I can be honest about this.</p>
<p>Here’s why I think it’s important.</p>
<hr>
<p>First, there is often an unrealistic expectation that an experienced engineer knows every technology in their field. Have you seen a “learning roadmap” that consists of a hundred libraries and tools? It’s useful — but intimidating.</p>
<p>What’s more, no matter how experienced you get, you may still find yourself switching between feeling capable, inadequate (“Impostor syndrome”), and overconfident (“Dunning–Kruger effect”). It depends on your environment, job, personality, teammates, mental state, time of day, and so on.</p>
<p>Experienced developers sometimes open up about their insecurities to encourage beginners. But there’s a world of difference between a seasoned surgeon who still gets the jitters and a student holding their first scalpel!</p>
<p>Hearing how “we’re all junior developers” can be disheartening and sound like empty talk to the learners faced with an actual gap in knowledge. Feel-good confessions from well-intentioned practitioners like me can’t bridge it.</p>
<p>Still, even experienced engineers have many knowledge gaps. This post is about mine, and I encourage those who can afford similar vulnerability to share their own. But let’s not devalue our experience while we do that.</p>
<p><strong>We can admit our knowledge gaps, may or may not feel like impostors, and still have deeply valuable expertise that takes years of hard work to develop.</strong></p>
<hr>
<p>With that disclaimer out of the way, here’s just a few things I don’t know:</p>
<ul>
<li>
<p><strong>Unix commands and Bash.</strong> I can <code>ls</code> and <code>cd</code> but I look up everything else. I get the concept of piping but I’ve only used it in simple cases. I don’t know how to use <code>xargs</code> to create complex chains, or how to compose and redirect different output streams. I also never properly learned Bash so I can only write very simple (and often buggy) shell scripts.</p>
</li>
<li>
<p><strong>Low-level languages.</strong> I understand Assembly lets you store things in memory and jump around the code but that’s about it. I wrote a few lines of C and understand what a pointer is, but I don’t know how to use <code>malloc</code> or other manual memory management techniques. Never played with Rust.</p>
</li>
<li>
<p><strong>Networking stack.</strong> I know computers have IP addresses, and DNS is how we resolve hostnames. I know there’s low level protocols like TCP/IP to exchange packets that (maybe?) ensure integrity. That’s it — I’m fuzzy on details.</p>
</li>
<li>
<p><strong>Containers.</strong> I have no idea about how to use Docker or Kubernetes. (Are those related?) I have a vague idea that they let me spin up a separate VM in a predictable way. Sounds cool but I haven’t tried it.</p>
</li>
<li>
<p><strong>Serverless.</strong> Also sounds cool. Never tried it. I don’t have a clear idea of how that model changes backend programming (if it does at all).</p>
</li>
<li>
<p><strong>Microservices.</strong> If I understand correctly, this just means “many API endpoints talking to each other”. I don’t know what the practical advantages or downsides of this approach are because I haven’t worked with it.</p>
</li>
<li>
<p><strong>Python.</strong> I feel bad about this one — I <em>have</em> worked with Python for several years at some point and I’ve never bothered to actually learn it. There are many things there like import behavior that are completely opaque to me.</p>
</li>
<li>
<p><strong>Node backends.</strong> I understand how to run Node, used some APIs like <code>fs</code> for build tooling, and can set up Express. But I’ve never talked from Node to a database and don’t really know how to write a backend in it. I’m also not familiar with React frameworks like Next beyond a “hello world”.</p>
</li>
<li>
<p><strong>Native platforms.</strong> I tried learning Objective C at some point but it didn’t work out. I haven’t learned Swift either. Same about Java. (I could probably pick it up though since I worked with C#.)</p>
</li>
<li>
<p><strong>Algorithms.</strong> The most you’ll get out of me is bubble sort and maybe quicksort on a good day. I can probably do simple graph traversing tasks if they’re tied to a particular practical problem. I understand the O(n) notation but my understanding isn’t much deeper than “don’t put loops inside loops”.</p>
</li>
<li>
<p><strong>Functional languages.</strong> Unless you count JavaScript, I’m not fluent in any traditionally functional language. (I’m only fluent in C# and JavaScript — and I already forgot most of C#.) I struggle to read either LISP-inspired (like Clojure), Haskell-inspired (like Elm), or ML-inspired (like OCaml) code.</p>
</li>
<li>
<p><strong>Functional terminology.</strong> Map and reduce is as far as I go. I don’t know monoids, functors, etc. I know what a monad is but maybe that’s an illusion.</p>
</li>
<li>
<p><strong>Modern CSS.</strong> I don’t know Flexbox or Grid. Floats are my jam.</p>
</li>
<li>
<p><strong>CSS Methodologies.</strong> I used BEM (meaning the CSS part, not the original BEM) but that’s all I know. I haven’t tried OOCSS or other methodologies.</p>
</li>
<li>
<p><strong>SCSS / Sass.</strong> Never got to learn them.</p>
</li>
<li>
<p><strong>CORS.</strong> I dread these errors! I know I need to set up some headers to fix them but I’ve wasted hours here in the past.</p>
</li>
<li>
<p><strong>HTTPS / SSL.</strong> Never set it up. Don’t know how it works beyond the idea of private and public keys.</p>
</li>
<li>
<p><strong>GraphQL.</strong> I can read a query but I don’t really know how to express stuff with nodes and edges, when to use fragments, and how pagination works there.</p>
</li>
<li>
<p><strong>Sockets.</strong> My mental model is they let computers talk to each other outside the request/response model but that’s about all I know.</p>
</li>
<li>
<p><strong>Streams.</strong> Aside from Rx Observables, I haven’t worked with streams closely. I used old Node streams one or two times but always messed up error handling.</p>
</li>
<li>
<p><strong>Electron.</strong> Never tried it.</p>
</li>
<li>
<p><strong>TypeScript.</strong> I understand the concept of types and can read annotations but I’ve never written it. The few times I tried, I ran into difficulties.</p>
</li>
<li>
<p><strong>Deployment and devops.</strong> I can manage to send some files over FTP or kill some processes but that’s the limit of my devops skills.</p>
</li>
<li>
<p><strong>Graphics.</strong> Whether it’s canvas, SVG, WebGL or low-level graphics, I’m not productive in it. I get the overall idea but I’d need to learn the primitives.</p>
</li>
</ul>
<p>Of course this list is not exhaustive. There are many things that I don’t know.</p>
<hr>
<p>It might seem like a strange thing to discuss. It even feels wrong to write it. Am I boasting of my ignorance? My intended takeaway from this post is that:</p>
<ul>
<li>
<p><strong>Even your favorite developers may not know many things that you know.</strong></p>
</li>
<li>
<p><strong>Regardless of your knowledge level, your confidence can vary greatly.</strong></p>
</li>
<li>
<p><strong>Experienced developers have valuable expertise despite knowledge gaps.</strong></p>
</li>
</ul>
<p>I’m aware of my knowledge gaps (at least, some of them). I can fill them in later if I become curious or if I need them for a project.</p>
<p>This doesn’t devalue my knowledge and experience. There’s plenty of things that I can do well. For example, learning technologies when I need them.</p>
<blockquote>
<p>Update: I also <a href="/the-elements-of-ui-engineering/">wrote</a> about a few things that I know.</p>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Why Do React Hooks Rely on Call Order?]]></title>
            <link>/post/why-do-hooks-rely-on-call-order</link>
            <guid>/post/why-do-hooks-rely-on-call-order</guid>
            <description><![CDATA[Lessons learned from mixins, render props, HOCs, and classes.]]></description>
            <content:encoded><![CDATA[<p>At React Conf 2018, the React team presented the <a href="https://reactjs.org/docs/hooks-intro.html">Hooks proposal</a>.</p>
<p>If you’d like to understand what Hooks are and what problems they solve, check out <a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">our talks</a> introducing them and <a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889">my follow-up article</a> addressing common misconceptions.</p>
<p>Chances are you won’t like Hooks at first:</p>
<p><img src="./hooks-hn1.png" alt="Negative HN comment"></p>
<p>They’re like a music record that grows on you only after a few good listens:</p>
<p><img src="./hooks-hn2.png" alt="Positive HN comment from the same person four days later"></p>
<p>When you read the docs, don’t miss <a href="https://reactjs.org/docs/hooks-custom.html">the most important page</a> about building your own Hooks! Too many people get fixated on some part of our messaging they disagree with (e.g. that learning classes is difficult) and miss the bigger picture behind Hooks. And the bigger picture is that <strong>Hooks are like <em>functional mixins</em> that let you create and compose your own abstractions.</strong></p>
<p>Hooks <a href="https://reactjs.org/docs/hooks-faq.html#what-is-the-prior-art-for-hooks">are influenced by some prior art</a> but I haven’t seen anything <em>quite</em> like them until Sebastian shared his idea with the team. Unfortunately, it’s easy to overlook the connection between the specific API choices and the valuable properties unlocked by this design. With this post I hope to help more people understand the rationale for the most controversial aspect of Hooks proposal.</p>
<p><strong>The rest of this post assumes you know the <code>useState()</code> Hook API and how to write a custom Hook. If you don’t, check out the earlier links. Also, keep in mind Hooks are experimental and you don’t have to learn them right now!</strong></p>
<p>(Disclaimer: this is a personal post and doesn’t necessarily reflect the opinions of the React team. It’s large, the topic is complex, and I may have made mistakes somewhere.)</p>
<hr>
<p>The first and probably the biggest shock when you learn about Hooks is that they rely on <em>persistent call index between re-renders</em>. This has some <a href="https://reactjs.org/docs/hooks-rules.html">implications</a>.</p>
<p>This decision is obviously controversial. This is why, <a href="https://www.reddit.com/r/reactjs/comments/9xs2r6/sebmarkbages_response_to_hooks_rfc_feedback/e9wh4um/">against our principles</a>, we only published this proposal after we felt the documentation and talks describe it well enough for people to give it a fair chance.</p>
<p><strong>If you’re concerned about some aspects of the Hooks API design, I encourage you to read Sebastian’s <a href="https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884">full response</a> to the 1,000+ comment RFC discussion.</strong> It is thorough but also quite dense. I could probably turn every paragraph of this comment into its own blog post. (In fact, I already <a href="/how-does-setstate-know-what-to-do/">did</a> that once!)</p>
<p>There is one specific part that I’d like to focus on today. As you may recall, each Hook can be used in a component more than once. For example, we can declare <a href="https://reactjs.org/docs/hooks-state.html#tip-using-multiple-state-variables">multiple state variables</a> by calling <code>useState()</code> repeatedly:</p>
<pre data-line="2,3,4,"  2,3,4="" class="language-jsx"><code 2,3,4="" class="language-jsx">function Form() {
  const [name, setName] = useState('Mary'); // State variable 1
  const [surname, setSurname] = useState('Poppins'); // State variable 2
  const [width, setWidth] = useState(window.innerWidth); // State variable 3

  useEffect(() =&gt; {
    const handleResize = () =&gt; setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () =&gt; window.removeEventListener('resize', handleResize);
  });

  function handleNameChange(e) {
    setName(e.target.value);
  }

  function handleSurnameChange(e) {
    setSurname(e.target.value);
  }

  return (
    &lt;&gt;
      &lt;input value={name} onChange={handleNameChange} /&gt;
      &lt;input value={surname} onChange={handleSurnameChange} /&gt;
      &lt;p&gt;
        Hello, {name} {surname}
      &lt;/p&gt;
      &lt;p&gt;Window width: {width}&lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre><p>Note that we use array destructuring syntax to name <code>useState()</code> state variables but these names are not passed to React. Instead, in this example <strong>React treats <code>name</code> as “the first state variable”, <code>surname</code> as “the second state variable”, and so on</strong>. Their <em>call index</em> is what gives them a stable identity between re-renders. This mental model is well-described <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">in this article</a>.</p>
<p>On a surface level, relying on the call index just <em>feels wrong</em>. A gut feeling is a useful signal but it can be misleading — especially if we haven’t fully internalized the problem we’re solving. <strong>In this post, I’ll take a few commonly suggested alternative designs for Hooks and show where they break down.</strong></p>
<hr>
<p>This post won’t be exhaustive. Depending on how granular you’re counting, we’ve seen from a dozen to <em>hundreds</em> of different alternative proposals. We’ve also been <a href="https://github.com/reactjs/react-future">thinking</a> about alternative component APIs for the last five years.</p>
<p>Blog posts like this are tricky because even if you cover a hundred alternatives, somebody can tweak one and say: “Ha, you didn’t think of <em>that</em>!”</p>
<p>In practice, different alternative proposals tend to overlap in their downsides. Rather than enumerate <em>all</em> the suggested APIs (which would take me months), I’ll demonstrate the most common flaws with specific examples. Categorizing other possible APIs by these problems could be an exercise to the reader. 🧐</p>
<p><em>That is not to say that Hooks are flawless.</em> But once you get familiar with the flaws of other solutions, you might find that the Hooks design makes some sense.</p>
<hr>
<h3>Flaw #1: Can’t Extract a Custom Hook</h3>
<p>Surprisingly, many alternative proposals don’t allow <a href="https://reactjs.org/docs/hooks-custom.html">custom Hooks</a> at all. Perhaps we didn’t emphasize custom Hooks enough in the “motivation” docs. It’s difficult to do until the primitives are well-understood. So it’s a chicken-and-egg problem. But custom Hooks are largely the point of the proposal.</p>
<p>For example, an alternative banned multiple <code>useState()</code> calls in a component. You’d keep state in one object. That works for classes, right?</p>
<pre   class="language-jsx"><code class="language-jsx">function Form() {
  const [state, setState] = useState({
    name: 'Mary',
    surname: 'Poppins',
    width: window.innerWidth,
  });
  // ...
}
</code></pre><p>To be clear, Hooks <em>do</em> allow this style. You don’t <em>have to</em> split your state into a bunch of state variables (see our <a href="https://reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables">recommendations</a> in the FAQ).</p>
<p>But the point of supporting multiple <code>useState()</code> calls is so that you can <em>extract</em> parts of stateful logic (state + effects) out of your components into custom Hooks which can <em>also</em> independently use local state and effects:</p>
<pre data-line="6-7,"  6-7="" class="language-jsx"><code 6-7="" class="language-jsx">function Form() {
  // Declare some state variables directly in component body
  const [name, setName] = useState('Mary');
  const [surname, setSurname] = useState('Poppins');

  // We moved some state and effects into a custom Hook
  const width = useWindowWidth();
  // ...
}

function useWindowWidth() {
  // Declare some state and effects in a custom Hook
  const [width, setWidth] = useState(window.innerWidth);
  useEffect(() =&gt; {
    // ...
  });
  return width;
}
</code></pre><p>If you only allow one <code>useState()</code> call per component, you lose the ability of custom Hooks to introduce local state. Which is the point of custom Hooks.</p>
<h3>Flaw #2: Name Clashes</h3>
<p>One common suggestion is to let <code>useState()</code> accept a key argument (e.g. a string) that uniquely identifies a particular state variable within a component.</p>
<p>There are a few variations on this idea, but they roughly look like this:</p>
<pre   class="language-jsx"><code class="language-jsx">// ⚠️ This is NOT the React Hooks API
function Form() {
  // We pass some kind of state key to useState()
  const [name, setName] = useState('name');
  const [surname, setSurname] = useState('surname');
  const [width, setWidth] = useState('width');
  // ...
</code></pre><p>This tries to avoid reliance on the call index (yay explicit keys!) but introduces another problem — name clashes.</p>
<p>Granted, you probably won’t be tempted to call <code>useState('name')</code> twice in the same component except by mistake. This can happen accidentally but we could argue that about any bug. However, it’s quite likely that when you work on a <em>custom Hook</em>, you’ll want to add or remove state variables and effects.</p>
<p>With this proposal, any time you add a new state variable inside a custom Hook, you risk breaking any components that use it (directly or transitively) because <em>they might already use the same name</em> for their own state variables.</p>
<p>This is an example of an API that’s not <a href="/optimized-for-change/">optimized for change</a>. The current code might always look “elegant”, but it is very fragile to changes in requirements. We should <a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html#mixins-cause-name-clashes">learn</a> from our mistakes.</p>
<p>The actual Hooks proposal solves this by relying on the call order: even if two Hooks use a <code>name</code> state variable, they would be isolated from each other. Every <code>useState()</code> call gets its own “memory cell”.</p>
<p>There are still a few other ways we could work around this flaw but they also have their own issues. Let’s explore this problem space more closely.</p>
<h3>Flaw #3: Can’t Call the Same Hook Twice</h3>
<p>Another variation of the “keyed” <code>useState</code> proposal is to use something like Symbols. Those can’t clash, right?</p>
<pre   class="language-jsx"><code class="language-jsx">// ⚠️ This is NOT the React Hooks API
const nameKey = Symbol();
const surnameKey = Symbol();
const widthKey = Symbol();

function Form() {
  // We pass some kind of state key to useState()
  const [name, setName] = useState(nameKey);
  const [surname, setSurname] = useState(surnameKey);
  const [width, setWidth] = useState(widthKey);
  // ...
</code></pre><p>This proposal seems to work for extracting the <code>useWindowWidth()</code> Hook:</p>
<pre data-line="4,11-17,"  4,11-17="" class="language-jsx"><code 4,11-17="" class="language-jsx">// ⚠️ This is NOT the React Hooks API
function Form() {
  // ...
  const width = useWindowWidth();
  // ...
}

/*********************
 * useWindowWidth.js *
 ********************/
const widthKey = Symbol();

function useWindowWidth() {
  const [width, setWidth] = useState(widthKey);
  // ...
  return width;
}
</code></pre><p>But if we attempt to extract input handling, it would fail:</p>
<pre data-line="4,5,19-29,"  4,5,19-29="" class="language-jsx"><code 4,5,19-29="" class="language-jsx">// ⚠️ This is NOT the React Hooks API
function Form() {
  // ...
  const name = useFormInput();
  const surname = useFormInput();
  // ...
  return (
    &lt;&gt;
      &lt;input {...name} /&gt;
      &lt;input {...surname} /&gt;
      {/* ... */}
    &lt;/&gt;
  );
}

/*******************
 * useFormInput.js *
 ******************/
const valueKey = Symbol();

function useFormInput() {
  const [value, setValue] = useState(valueKey);
  return {
    value,
    onChange(e) {
      setValue(e.target.value);
    },
  };
}
</code></pre><p>(I’ll admit this <code>useFormInput()</code> Hook isn’t particularly useful but you could imagine it handling things like validation and dirty state flag a la <a href="https://github.com/jaredpalmer/formik">Formik</a>.)</p>
<p>Can you spot the bug?</p>
<p>We’re calling <code>useFormInput()</code> twice but our <code>useFormInput()</code> always calls <code>useState()</code> with the same key. So effectively we’re doing something like:</p>
<pre   class="language-jsx"><code class="language-jsx">const [name, setName] = useState(valueKey);
const [surname, setSurname] = useState(valueKey);
</code></pre><p>And this is how we get a clash again.</p>
<p>The actual Hooks proposal doesn’t have this problem because <strong>each <em>call</em> to <code>useState()</code> gets its own isolated state.</strong> Relying on a persistent call index frees us from worrying about name clashes.</p>
<h3>Flaw #4: The Diamond Problem</h3>
<p>This is technically the same flaw as the previous one but it’s worth mentioning for its notoriety. It’s even <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">described on Wikipedia</a>. (Apparently, it’s sometimes called “the deadly diamond of death” — cool beans.)</p>
<p>Our own mixin system <a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html#mixins-cause-name-clashes">suffered from it</a>.</p>
<p>Two custom Hooks like <code>useWindowWidth()</code> and <code>useNetworkStatus()</code> might want to use the same custom Hook like <code>useSubscription()</code> under the hood:</p>
<pre data-line="12,23-27,32-42,"  12,23-27,32-42="" class="language-jsx"><code 12,23-27,32-42="" class="language-jsx">function StatusMessage() {
  const width = useWindowWidth();
  const isOnline = useNetworkStatus();
  return (
    &lt;&gt;
      &lt;p&gt;Window width is {width}&lt;/p&gt;
      &lt;p&gt;You are {isOnline ? 'online' : 'offline'}&lt;/p&gt;
    &lt;/&gt;
  );
}

function useSubscription(subscribe, unsubscribe, getValue) {
  const [state, setState] = useState(getValue());
  useEffect(() =&gt; {
    const handleChange = () =&gt; setState(getValue());
    subscribe(handleChange);
    return () =&gt; unsubscribe(handleChange);
  });
  return state;
}

function useWindowWidth() {
  const width = useSubscription(
    handler =&gt; window.addEventListener('resize', handler),
    handler =&gt; window.removeEventListener('resize', handler),
    () =&gt; window.innerWidth,
  );
  return width;
}

function useNetworkStatus() {
  const isOnline = useSubscription(
    handler =&gt; {
      window.addEventListener('online', handler);
      window.addEventListener('offline', handler);
    },
    handler =&gt; {
      window.removeEventListener('online', handler);
      window.removeEventListener('offline', handler);
    },
    () =&gt; navigator.onLine,
  );
  return isOnline;
}
</code></pre><p>This is a completely valid use case. <strong>It should be safe for a custom Hook author to start or stop using another custom Hook without worrying whether it is “already used” somewhere in the chain.</strong> In fact, <em>you can never know</em> the whole chain unless you audit every component using your Hook on every change.</p>
<p>(As a counterexample, the legacy React <code>createClass()</code> mixins did not let you do this. Sometimes you’d have two mixins that both do exactly what you need but are mutually incompatible due to extending the same “base” mixin.)</p>
<p>This is our “diamond”: 💎</p>
<pre   class="language-javascript"><code class="language-javascript">       / useWindowWidth()   \                   / useState()  🔴 Clash
Status                        useSubscription()
       \ useNetworkStatus() /                   \ useEffect() 🔴 Clash
</code></pre><p>Reliance on the persistent call order naturally resolves it:</p>
<pre   class="language-javascript"><code class="language-javascript">                                                 / useState()  ✅ #1. State
       / useWindowWidth()   -&gt; useSubscription()
      /                                          \ useEffect() ✅ #2. Effect
Status
      \                                          / useState()  ✅ #3. State
       \ useNetworkStatus() -&gt; useSubscription()
                                                 \ useEffect() ✅ #4. Effect
</code></pre><p>Function calls don’t have a “diamond” problem because they form a tree. 🎄</p>
<h3>Flaw #5: Copy Paste Breaks Things</h3>
<p>Maybe we could salvage the keyed state proposal by introducing some sort of namespacing. There are a few different ways to do it.</p>
<p>One way could be to isolate state keys with closures. This would require you to “instantiate” custom Hooks and add a function wrapper around each of them:</p>
<pre data-line="5,6,"  5,6="" class="language-jsx"><code 5,6="" class="language-jsx">/*******************
 * useFormInput.js *
 ******************/
function createUseFormInput() {
  // Unique per instantiation
  const valueKey = Symbol();

  return function useFormInput() {
    const [value, setValue] = useState(valueKey);
    return {
      value,
      onChange(e) {
        setValue(e.target.value);
      },
    };
  };
}
</code></pre><p>This approach is rather heavy-handed. One of the design goals of Hooks is to avoid the deeply nested functional style that is prevalent with higher-order components and render props. Here, we have to “instantiate” <em>any</em> custom Hook before its use — and use the resulting function <em>exactly once</em> in the body of a component. This isn’t much simpler than calling Hooks unconditionally.</p>
<p>Additionally, you have to repeat every custom Hook used in a component twice. Once in the top level scope (or inside a function scope if we’re writing a custom Hook), and once at the actual call site. This means you have to jump between the rendering and top-level declarations even for small changes:</p>
<pre data-line="2,3,7,8,"  2,3,7,8="" class="language-jsx"><code 2,3,7,8="" class="language-jsx">// ⚠️ This is NOT the React Hooks API
const useNameFormInput = createUseFormInput();
const useSurnameFormInput = createUseFormInput();

function Form() {
  // ...
  const name = useNameFormInput();
  const surname = useNameFormInput();
  // ...
}
</code></pre><p>You also need to be very precise with their names. You would always have “two levels” of names — factories like <code>createUseFormInput</code> and the instantiated Hooks like <code>useNameFormInput</code> and <code>useSurnameFormInput</code>.</p>
<p>If you call the same custom Hook “instance” twice you’d get a state clash. In fact, the code above has this mistake — have you noticed? It should be:</p>
<pre   class="language-jsx"><code class="language-jsx">const name = useNameFormInput();
const surname = useSurnameFormInput(); // Not useNameFormInput!
</code></pre><p>These problems are not insurmountable but I would argue that they add <em>more</em> friction than following the <a href="https://reactjs.org/docs/hooks-rules.html">Rules of Hooks</a>.</p>
<p>Importantly, they break the expectations of copy-paste. Extracting a custom Hook without an extra closure wrapper <em>still works</em> with this approach but only until you call it twice. (Which is when it creates a conflict.) It’s unfortunate when an API seems to work but then forces you to Wrap All the Things™️ once you realize there is a conflict somewhere deep down the chain.</p>
<h3>Flaw #6: We Still Need a Linter</h3>
<p>There is another way to avoid conflicts with keyed state. If you know about it, you were probably really annoyed I still haven’t acknowledged it! Sorry.</p>
<p>The idea is that we could <em>compose</em> keys every time we write a custom Hook. Something like this:</p>
<pre data-line="4,5,16,17,"  4,5,16,17="" class="language-jsx"><code 4,5,16,17="" class="language-jsx">// ⚠️ This is NOT the React Hooks API
function Form() {
  // ...
  const name = useFormInput('name');
  const surname = useFormInput('surname');
  // ...
  return (
    &lt;&gt;
      &lt;input {...name} /&gt;
      &lt;input {...surname} /&gt;
      {/* ... */}
    &lt;/&gt;
  );
}

function useFormInput(formInputKey) {
  const [value, setValue] = useState('useFormInput(' + formInputKey + ').value');
  return {
    value,
    onChange(e) {
      setValue(e.target.value);
    },
  };
}
</code></pre><p>Out of different alternatives, I dislike this approach the least. I don’t think it’s worth it though.</p>
<p>Code passing non-unique or badly composed keys would <em>accidentally work</em> until a Hook is called multiple times or clashes with another Hook. Worse, if it’s meant to be conditional (we’re trying to “fix” the unconditional call requirement, right?), we might not even encounter the clashes until later.</p>
<p>Remembering to pass keys through all layers of custom Hooks seems fragile enough that we’d want to lint for that. They would add extra work at runtime (don’t forget they’d need to serve <em>as keys</em>), and each of them is a paper cut for bundle size. <strong>But if we have to lint anyway, what problem did we solve?</strong></p>
<p>This might make sense if conditionally declaring state and effects was very desirable. But in practice I find it confusing. In fact, I don’t recall anyone ever asking to conditionally define <code>this.state</code> or <code>componentDidMount</code> either.</p>
<p>What does this code mean exactly?</p>
<pre data-line="3,4,"  3,4="" class="language-jsx"><code 3,4="" class="language-jsx">// ⚠️ This is NOT the React Hooks API
function Counter(props) {
  if (props.isActive) {
    const [count, setCount] = useState('count');
    return (
      &lt;p onClick={() =&gt; setCount(count + 1)}&gt;
        {count}
      &lt;/p&gt;;
    );
  }
  return null;
}
</code></pre><p>Is <code>count</code> preserved when <code>props.isActive</code> is <code>false</code>? Or does it get reset because <code>useState('count')</code> wasn’t called?</p>
<p>If conditional state gets preserved, what about an effect?</p>
<pre data-line="5-8,"  5-8="" class="language-jsx"><code 5-8="" class="language-jsx">// ⚠️ This is NOT the React Hooks API
function Counter(props) {
  if (props.isActive) {
    const [count, setCount] = useState('count');
    useEffect(() =&gt; {
      const id = setInterval(() =&gt; setCount(c =&gt; c + 1), 1000);
      return () =&gt; clearInterval(id);
    }, []);
    return (
      &lt;p onClick={() =&gt; setCount(count + 1)}&gt;
        {count}
      &lt;/p&gt;;
    );
  }
  return null;
}
</code></pre><p>It definitely can’t run <em>before</em> <code>props.isActive</code> is <code>true</code> for the first time. But once it becomes <code>true</code>, does it ever stop running? Does the interval reset when <code>props.isActive</code> flips to <code>false</code>? If it does, it’s confusing that effect behaves differently from state (which we said wouldn’t reset). If the effect keeps running, it’s confusing that <code>if</code> outside the effect doesn’t actually make the effect conditional. Didn’t we say we wanted conditional effects?</p>
<p>If the state <em>does</em> get reset when we don’t “use” it during a render, what happens if multiple <code>if</code> branches contain <code>useState('count')</code> but only one runs at any given time? Is that valid code? If our mental model is a “map with keys”, why do things “disappear” from it? Would the developer expect an early <code>return</code> from a component to reset all state after it? If we truly wanted to reset the state, we could make it explicit by extracting a component:</p>
<pre   class="language-jsx"><code class="language-jsx">function Counter(props) {
  if (props.isActive) {
    // Clearly has its own state
    return &lt;TickingCounter /&gt;;
  }
  return null;
}
</code></pre><p>That would probably become the “best practice” to avoid these confusing questions anyway. So whichever way you choose to answer them, I think the semantics of conditionally <em>declaring</em> state and effects itself end up weird enough that you might want to lint against it.</p>
<p>If we have to lint anyway, the requirement to correctly compose keys becomes “dead weight”. It doesn’t buy us anything we actually <em>want</em> to do. However, dropping that requirement (and going back to the original proposal) <em>does</em> buy us something. It makes copy-pasting component code into a custom Hook safe without namespacing it, reduces bundle size paper cuts from keys and unlocks a slightly more efficient implementation (no need for Map lookups).</p>
<p>Small things add up.</p>
<h3>Flaw #7: Can’t Pass Values Between Hooks</h3>
<p>One of the best features of Hooks is that you can pass values between them.</p>
<p>Here is a hypothetical example of a message recipient picker that shows whether the currently chosen friend is online:</p>
<pre data-line="8,9,"  8,9="" class="language-jsx"><code 8,9="" class="language-jsx">const friendList = [{ id: 1, name: 'Phoebe' }, { id: 2, name: 'Rachel' }, { id: 3, name: 'Ross' }];

function ChatRecipientPicker() {
  const [recipientID, setRecipientID] = useState(1);
  const isRecipientOnline = useFriendStatus(recipientID);

  return (
    &lt;&gt;
      &lt;Circle color={isRecipientOnline ? 'green' : 'red'} /&gt;
      &lt;select value={recipientID} onChange={e =&gt; setRecipientID(Number(e.target.value))}&gt;
        {friendList.map(friend =&gt; (
          &lt;option key={friend.id} value={friend.id}&gt;
            {friend.name}
          &lt;/option&gt;
        ))}
      &lt;/select&gt;
    &lt;/&gt;
  );
}

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);
  const handleStatusChange = status =&gt; setIsOnline(status.isOnline);
  useEffect(() =&gt; {
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });
  return isOnline;
}
</code></pre><p>When you change the recipient, our <code>useFriendStatus()</code> Hook would unsubscribe from the previous friend’s status, and subscribe to the next one.</p>
<p>This works because we can pass the return value of the <code>useState()</code> Hook to the <code>useFriendStatus()</code> Hook:</p>
<pre data-line="2,"  2="" class="language-jsx"><code 2="" class="language-jsx">const [recipientID, setRecipientID] = useState(1);
const isRecipientOnline = useFriendStatus(recipientID);
</code></pre><p>Passing values between Hooks is very powerful. For example, <a href="https://medium.com/@drcmda/hooks-in-react-spring-a-tutorial-c6c436ad7ee4">React Spring</a> lets you create a trailing animation of several values “following” each other:</p>
<pre   class="language-jsx"><code class="language-jsx">const [{ pos1 }, set] = useSpring({ pos1: [0, 0], config: fast });
const [{ pos2 }] = useSpring({ pos2: pos1, config: slow });
const [{ pos3 }] = useSpring({ pos3: pos2, config: slow });
</code></pre><p>(Here’s a <a href="https://codesandbox.io/s/ppxnl191zx">demo</a>.)</p>
<p>Proposals that put Hook initialization into default argument values or that write Hooks in a decorator form make it difficult to express this kind of logic.</p>
<p>If calling Hooks doesn’t happen in the function body, you can no longer easily pass values between them, transform those values without creating many layers of components, or add <code>useMemo()</code> to memoize an intermediate computation. You also can’t easily reference these values in effects because they can’t capture them in a closure. There are ways to work around these issues with some convention but they require you to mentally “match up” inputs and outputs. This is tricky and violates React’s otherwise direct style.</p>
<p>Passing values between Hooks is at the heart of our proposal. Render props pattern was the closest you could get to it without Hooks, but you couldn’t get full benefits without something like <a href="https://ui.reach.tech/component-component">Component Component</a> which has a lot of syntactic noise due to a “false hierarchy”. Hooks flatten that hierarchy to passing values — and function calls is the simplest way to do that.</p>
<h3>Flaw #8: Too Much Ceremony</h3>
<p>There are many proposals that fall under this umbrella. Most attempt to avoid the perceived dependency of Hooks on React. There is a wide variety of ways to do it: by making built-in Hooks available on <code>this</code>, making them an extra argument you have to pass through everything, and so on.</p>
<p>I think <a href="https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884">Sebastian’s answer</a> addresses this way better than I could describe so I encourage you to check out its first section (“Injection Model”).</p>
<p>I’ll just say there is a reason programmers tend to prefer <code>try</code> / <code>catch</code> for error handling to passing error codes through every function. It’s the same reason why we prefer ES Modules with <code>import</code> (or CommonJS <code>require</code>) to AMD’s “explicit” definitions where <code>require</code> is passed to us.</p>
<pre   class="language-jsx"><code class="language-jsx">// Anyone miss AMD?
define(['require', 'dependency1', 'dependency2'], function (require) {
  var dependency1 = require('dependency1'),
  var dependency2 = require('dependency2');
  return function () {};
});
</code></pre><p>Yes, AMD may be more “honest” to the fact that modules aren’t actually synchronously loaded in a browser environment. But once you learn about that, writing the <code>define</code> sandwich becomes a mindless chore.</p>
<p><code>try</code> / <code>catch</code>, <code>require</code>, and React Context API are pragmatic examples of how we want to have some “ambient” handler available to us instead of explicitly threading it through every level — even if in general we value explicitness. I think the same is true for Hooks.</p>
<p>This is similar to how, when we define components, we just grab <code>Component</code> from <code>React</code>. Maybe our code would be more decoupled from React if we exported a factory for every component instead:</p>
<pre   class="language-jsx"><code class="language-jsx">function createModal(React) {
  return class Modal extends React.Component {
    // ...
  };
}
</code></pre><p>But in practice this ends up being just an annoying indirection. When we actually want to stub React with something else, we can always do that at the module system level instead.</p>
<p>The same applies to Hooks. Still, as <a href="https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884">Sebastian’s answer</a> mentions, it is <em>technically possible</em> to “redirect” Hooks exported from <code>react</code> to a different implementation. (<a href="/how-does-setstate-know-what-to-do/">One of my previous posts</a> mentions how.)</p>
<p>Another way to impose more ceremony is by making Hooks <a href="https://paulgray.net/an-alternative-design-for-hooks/">monadic</a> or adding a first-class concept like <code>React.createHook()</code>. Aside from the runtime overhead, any solution that adds wrappers loses a huge benefit of using plain functions: <em>they are as easy to debug as it gets</em>.</p>
<p>Plain functions let you step in and out with a debugger without any library code in the middle, and see exactly how values flow inside your component body. Indirections make this difficult. Solutions similar in spirit to either higher-order components (“decorator” Hooks) or render props (e.g. <code>adopt</code> proposal or <code>yield</code>ing from generators) suffer from the same problem. Indirections also complicate static typing.</p>
<hr>
<p>As I mentioned earlier, this post doesn’t aim to be exhaustive. There are other interesting problems with different proposals. Some of them are more obscure (e.g. related to concurrency or advanced compilation techniques) and might be a topic for another blog post in the future.</p>
<p>Hooks aren’t perfect either, but it’s the best tradeoff we could find for solving these problems. There are things we <a href="https://github.com/reactjs/rfcs/pull/68#issuecomment-440780509">still need to fix</a>, and there exist things that are more awkward with Hooks than classes. That is also a topic for another blog post.</p>
<p>Whether I covered your favorite alternative proposal or not, I hope this writeup helped shed some light on our thinking process and the criteria we consider when choosing an API. As you can see, a lot of it (such as making sure that copy-pasting, moving code, adding and removing dependencies works as expected) has to do with <a href="/optimized-for-change/">optimizing for change</a>. I hope that React users will appreciate these aspects.</p>
]]></content:encoded>
        </item>
    </channel>
</rss>