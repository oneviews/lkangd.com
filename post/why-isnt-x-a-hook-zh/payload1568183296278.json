{"post":{"attributes":{"title":"为什么 'XX' 不是一个 Hooks API?","date":"2019-01-26","spoiler":"我们可以这样做，但并不是意味着我们应该这样做。","link":"/post/why-isnt-x-a-hook-zh","min2read":"☕️☕️ 8 min read","wordcount":"2.2k"},"body":"<p>自从 <a href=\"https://reactjs.org/hooks\">React Hooks</a> 发布 alpha 版本, 就有很多人对一些问题的讨论，比如: “为什么有些 API 不是一个 Hook?”。</p>\n<p>比如下面这些就是一些 Hooks API：</p>\n<ul>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#usestate\"><code>useState()</code></a> 可以用来声明 <code>state</code> 变量。</li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#useeffect\"><code>useEffect()</code></a> 可以用来声明 <code>side effects</code>。</li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#usecontext\"><code>useContext()</code></a> 可以用来读取 <code>context</code>。</li>\n</ul>\n<p>但是有些 API 就不是 hooks，比如 <code>React.memo()</code> 和 <code>&lt;Context.Provider&gt;</code>。一般大家提出来的 Hook 基本上是*不可组合（noncompositional）<em>和</em>反模块化（antimodular）*的，这篇文章会帮助你理解为什么。</p>\n<p><strong>注：这篇文章是一篇深入探讨的文章，阅读对象应该是对 API 的讨论是非常感兴趣的，而不是为了考虑使用 React 来提升效率的！</strong></p>\n<hr>\n<p>我们想让 React 的 API 保持以下非常重要的两点:</p>\n<ol>\n<li>\n<p><strong>组合:</strong> 对于 Hooks API来说，可以<a href=\"https://reactjs.org/docs/hooks-custom.html\">自定义 Hooks</a> 是让我们感到非常兴奋的. 我们期望大家都可以来构建自己的Hooks API, 并且我们需要确保不同人写的 Hooks API <a href=\"/why-do-hooks-rely-on-call-order/#flaw-4-the-diamond-problem\">不会造成冲突</a>。 (我们是不是已经被自由的组合组件而不用担心相互造成影响给惯坏了？)</p>\n</li>\n<li>\n<p><strong>调试:</strong> 我们希望随着应用规模的不断增长 <a href=\"/the-bug-o-notation/\">bug 是很容易发现的</a>的。React最棒的一个特性就是如果某些内容被错误的渲染了，你可以轻松的找到对应的组件的 prop 或者 state 导致了这个问题。</p>\n</li>\n</ol>\n<p>结合这两点来看，我们就可以知道哪些是<em>不能</em>成为一个 Hook。我们可以用一些例子来说明：</p>\n<hr>\n<h2>一个 Hook: <code>useState()</code></h2>\n<h3>组合</h3>\n<p>多个自定义的 Hooks 调用 <code>useState()</code>，而不会造成冲突：</p>\n<pre   class=\"language-js\"><code class=\"language-js\">function useMyCustomHook1() {\n  const [value, setValue] = useState(0);\n  // What happens here, stays here.\n}\n\nfunction useMyCustomHook2() {\n  const [value, setValue] = useState(0);\n  // What happens here, stays here.\n}\n\nfunction MyComponent() {\n  useMyCustomHook1();\n  useMyCustomHook2();\n  // ...\n}\n</code></pre><p>添加一个不在条件判断里的 <code>useState()</code> ， 调用这个 API 是很安全的。你不需要了解在一个组件里面声明了新的 state 变量被其他 Hooks 使用了。也不会因为更新了其他状态导致 state 变量被破坏。</p>\n<p><strong>结论:</strong> ✅ <code>useState()</code> 不会对其他自定义的 Hooks 造成破坏。</p>\n<h3>调试</h3>\n<p>Hooks 是非常有用的，你可以在 Hooks <em>之间</em>传递值：</p>\n<pre data-line=\"4,12,14,\"  4,12,14=\"\" class=\"language-js\"><code 4,12,14=\"\" class=\"language-js\">function useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n  // ...\n  return width;\n}\n\nfunction useTheme(isMobile) {\n  // ...\n}\n\nfunction Comment() {\n  const width = useWindowWidth();\n  const isMobile = width &lt; MOBILE_VIEWPORT;\n  const theme = useTheme(isMobile);\n  return (\n    &lt;section className={theme.comment}&gt;\n      {/* ... */}\n    &lt;/section&gt;\n  );\n}\n</code></pre><p>但是如过我们的代码出错了，我们怎么调试？</p>\n<p>假设我们从 <code>theme.comment</code> 里拿出来的一个 css class 是错误的, 那我们怎么调试这个问题？我们可以在组件里设置一个断点或者输出一些日志。</p>\n<p>也许我们可以发现 <code>theme</code> 是错误的，但是 <code>width</code> 和 <code>isMobile</code>是正确的。这就告诉我们问题是发生在 <code>useTheme()</code> 里面。也有可能 <code>width</code> 不对，那么相应的问题就出在 <code>useWindowWidth()</code> 里。</p>\n<p><strong>一看最顶部的对应 Hooks 里的中间值就知道问题发生在哪里了。</strong> 我们不需要查看组件里所有的 Hooks 的实现。</p>\n<p>我们直接查看有问题的那个实现，重复这个步骤就可以确定问题具体问题发生在什么地方。</p>\n<p>如果自定义 Hooks 的嵌套层级增加了，那么这个就变的更加重要。想象一下，我们有三层嵌套的自定义 Hook，每层使用了三个不同的自定 Hooks。 定位<strong>3个有问题的地方</strong>和定位 <strong>3 + 3×3 + 3×3×3 = 39个有问题地方</strong>，二者之间的成本<a href=\"/the-bug-o-notation/\">差别</a>是非常大的。幸运的是，<code>useState()</code> 不会对其他 Hooks 或者组件造成莫名其妙的影响。雁过留痕，一个 Hooks 返回的错误值，和普通的变量是没有任何区别的。🐛</p>\n<p><strong>结论:</strong> ✅ <code>useState()</code> 不会隐藏我们代码中的因果关系。我们可以一步步的定位到对应的bug。</p>\n<hr>\n<h2>不是一个 Hook: <code>useBailout()</code></h2>\n<p>作为一种优化, 组件使用 Hooks 可以避免重新渲染。</p>\n<p>另一种方式是我们可以使用 <a href=\"https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactmemo\"><code>React.memo()</code></a> 包裹整个组件。 为了避免重新渲染，<code>React.memo()</code> 会用本次即将渲染的 props 和最后一次然的 props 通过 <code>shallowly equal</code> 去做比较， 这个和 <code>PureComponent</code> 是类似的。</p>\n<p><code>React.memo()</code> 接收一个组件作为参数并返回一个组件：</p>\n<pre data-line=\"4,\"  4=\"\" class=\"language-js\"><code 4=\"\" class=\"language-js\">function Button(props) {\n  // ...\n}\nexport default React.memo(Button);\n</code></pre><p><strong>但是 <code>useBailout()</code> 为什么不仅仅是一个钩子</strong></p>\n<p>不论你将其称之为 <code>useShouldComponentUpdate()</code>， <code>usePure()</code>， <code>useSkipRender()</code> 或者 <code>useBailout()</code>， 这个提案(proposal)看起来就和下面这个是一样的：</p>\n<pre   class=\"language-js\"><code class=\"language-js\">function Button({ color }) {\n  // ⚠️ 非真实API\n  useBailout(prevColor =&gt; prevColor !== color, color);\n\n  return (\n    &lt;button className={'button-' + color}&gt;  \n      OK\n    &lt;/button&gt;\n  )\n}\n</code></pre><p>也有一些其他不同的提案（比如：<a href=\"https://github.com/reactjs/rfcs/pull/30#issuecomment-371337630\"><code>usePure()</code></a>），但是一般来说，这个提案也有同样的问题。</p>\n<h3>组合</h3>\n<p>让我们尝试将 <code>useBailout()</code> 在两个自定义的 Hooks 中使用：</p>\n<pre data-line=\"4,5,19,20,\"  4,5,19,20=\"\" class=\"language-js\"><code 4,5,19,20=\"\" class=\"language-js\">function useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  // ⚠️ 非真实API\n  useBailout(prevIsOnline =&gt; prevIsOnline !== isOnline, isOnline);\n\n  useEffect(() =&gt; {\n    const handleStatusChange = status =&gt; setIsOnline(status.isOnline);\n    ChatAPI.subscribe(friendID, handleStatusChange);\n    return () =&gt; ChatAPI.unsubscribe(friendID, handleStatusChange);\n  });\n\n  return isOnline;\n}\n\nfunction useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n  \n  // ⚠️ 非真实API\n  useBailout(prevWidth =&gt; prevWidth !== width, width);\n\n  useEffect(() =&gt; {\n    const handleResize = () =&gt; setWidth(window.innerWidth);\n    window.addEventListener('resize', handleResize);\n    return () =&gt; window.removeEventListener('resize', handleResize);\n  });\n\n  return width;\n}\n</code></pre><p>如果现在在同一个组件中使用这两个自定义的 Hooks 会发生什么？</p>\n<pre data-line=\"2,3,\"  2,3=\"\" class=\"language-js\"><code 2,3=\"\" class=\"language-js\">function ChatThread({ friendID, isTyping }) {\n  const width = useWindowWidth();\n  const isOnline = useFriendStatus(friendID);\n  return (\n    &lt;ChatLayout width={width}&gt;\n      &lt;FriendStatus isOnline={isOnline} /&gt;\n      {isTyping &amp;&amp; 'Typing...'}\n    &lt;/ChatLayout&gt;\n  );\n}\n</code></pre><p>什么时候重新渲染?</p>\n<p>如果每一个 <code>useBailout()</code> 都有权限去跳过更新，那么 <code>useWindowWidth()</code> 里面的更新就会被 <code>useFriendStatus()</code> 给阻塞，反之亦然。 <strong>这些 Hooks 会相互影响。</strong></p>\n<p>然而，如果允许<code>useBailout()</code> 在一个组件里去阻止更新的话，那么我们的 <code>ChatThread</code> 组件里的 <code>isTyping</code> 属性发生变化时也无法去更新这个组件。</p>\n<p>更糟糕的是，如果我们使用这种语义，<strong>任何新添加到 <code>ChatThread</code> 里的 Hooks 如果没有<em>同样</em>调用 <code>useBailout()</code>，那么这些 Hooks 也同样会被阻断</strong>。不然 <code>useBailout()</code> 也没有办法在 <code>useWindowWidth()</code> 和 <code>useFriendStatus()</code> 阻止更新时 “投上反对票（vote against）”。</p>\n<p><strong>结论:</strong> 🔴 <code>useBailout()</code> 违反了组合原则. 添加 <code>useBailout()</code> 到一个 Hook 里面就会影响其他 Hooks 的状态更新。我希望和 API 是<a href=\"/optimized-for-change/\">健壮的(antifragile)</a>, 但是 <code>useBailout()</code> 的行为是完完全全相反的。</p>\n<h3>调试</h3>\n<p>像 <code>useBailout()</code> 的这样的 hook 会对调试造成什么影响？</p>\n<p>我们使用同样的列子:</p>\n<pre   class=\"language-js\"><code class=\"language-js\">function ChatThread({ friendID, isTyping }) {\n  const width = useWindowWidth();\n  const isOnline = useFriendStatus(friendID);\n  return (\n    &lt;ChatLayout width={width}&gt;\n      &lt;FriendStatus isOnline={isOnline} /&gt;\n      {isTyping &amp;&amp; 'Typing...'}\n    &lt;/ChatLayout&gt;\n  );\n}\n</code></pre><p>假设有些上层组件的属性发生了变化，但是 <code>Typing...</code> label 没有按照我们预期显示出来。这时候我们怎么调试呢？</p>\n<p><strong>通常，你会很自信的回答这个问题，我们只需要去看<em>上层组件</em>。</strong> 如果 <code>ChatThread</code> 没有获得 <code>isTyping</code> 的新值。我们可以打开渲染 <code>&lt;ChatThread isTyping={myVar} /&gt;</code> 的组件，然后去检查 <code>myVar</code> 等等。在同级组件中，我们可能在 <code>shouldComponentUpdate()</code> 中发现被阻止了，或者 <code>isTyping</code> 的值没有正确的传递过去。检查在这个链中的每一个组件通常也能轻松的定位到问题的根源。</p>\n<p>如果 <code>useBailout()</code> Hook 是一个真实的 API。在你深度地检查 <code>ChatThread</code> 和 <code>ChatThread</code> 里所有组件<em>中使用到的每一个自定义 Hook</em> 之前，你永远不知道跳过更新的原因。由于每一个父组件<em>同样</em>可以使用自定义 Hooks，这个<a href=\"/the-bug-o-notation/\">情况（scales）</a>就变的更加复杂了。</p>\n<p>这就像你在一个抽屉柜里有一堆小抽屉的其中一个找到一把小螺丝刀一样。你永远不知道这个“坑”到底有多深。</p>\n<p><strong>结论:</strong> 🔴 <code>useBailout()</code> Hook 不仅仅破坏可组合性, 为了找到有 bug 的阻止更新代码，大大的增加了调试步骤和认知负荷 —— 在某些情况下，这是指数级别的。</p>\n<hr>\n<p>我们讨论了一个真正存在的 Hook - <code>useState()</code>，和另一个看上去是 Hook，但是实际上<em>不</em>是一个 Hook - <code>useBailout()</code> 的例子，我们比较了组合和调试，并讨论了为什么其中一个是有效的，另一个事无效的。</p>\n<p>虽然没有 “Hook 版本” 的 <code>memo()</code> 和 <code>shouldComponentUpdate()</code>，但是React确实提供了一个叫 <a href=\"https://reactjs.org/docs/hooks-reference.html#usememo\"><code>useMemo()</code></a> 的 API. 虽然有相同的用途，但是 <code>useMemo()</code> 本身的语义是不一样的，不会遇到上面所说的问题。</p>\n<p><code>useBailout()</code> 只是一个不会像 Hook 一样工作的例子。但是也还有一些其他的 Hooks API —— 比如，<code>useProvider()</code>, <code>useCatch()</code>, 和 <code>useSuspense()</code>。</p>\n<p>现在明白为什么了吗?</p>\n<p><em>(低头嘀咕: 组合... 调试...)</em></p>\n","frontmatter":"title: 为什么 'XX' 不是一个 Hooks API?\ndate: '2019-01-26'\nspoiler: 我们可以这样做，但并不是意味着我们应该这样做。","link":"/post/why-isnt-x-a-hook-zh","next":{"title":"Why Isn’t X a Hook?","date":"2019-01-26","spoiler":"Just because we can, doesn’t mean we should.","link":"/post/why-isnt-x-a-hook","min2read":"☕️☕️ 8 min read","wordcount":"1.4k"},"prev":{"title":"Why Do We Write super(props)?","date":"2018-11-30","spoiler":"There’s a twist at the end.","link":"/post/why-do-we-write-super-props","min2read":"☕️ 5 min read","wordcount":938}}}