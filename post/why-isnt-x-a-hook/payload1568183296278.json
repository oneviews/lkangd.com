{"post":{"attributes":{"title":"Why Isnâ€™t X a Hook?","date":"2019-01-26","spoiler":"Just because we can, doesnâ€™t mean we should.","link":"/post/why-isnt-x-a-hook","min2read":"â˜•ï¸â˜•ï¸ 8 min read","wordcount":"1.4k"},"body":"<p>Since the first alpha version of <a href=\"https://reactjs.org/hooks\">React Hooks</a> was released, there is a question that keeps coming up in discussions: â€œWhy isnâ€™t <em>&lt;some other API&gt;</em> a Hook?â€</p>\n<p>To remind you, hereâ€™s a few things that <em>are</em> Hooks:</p>\n<ul>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#usestate\"><code>useState()</code></a> lets you declare a state variable.</li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#useeffect\"><code>useEffect()</code></a> lets you declare a side effect.</li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#usecontext\"><code>useContext()</code></a> lets you read some context.</li>\n</ul>\n<p>But there are some other APIs, like <code>React.memo()</code> and <code>&lt;Context.Provider&gt;</code>, that are <em>not</em> Hooks. Commonly proposed Hook versions of them would be <em>noncompositional</em> or <em>antimodular</em>. This article will help you understand why.</p>\n<p><strong>Note: this post is a deep dive for folks who are interested in API discussions. You donâ€™t need to think about any of this to be productive with React!</strong></p>\n<hr>\n<p>There are two important properties that we want React APIs to preserve:</p>\n<ol>\n<li>\n<p><strong>Composition:</strong> <a href=\"https://reactjs.org/docs/hooks-custom.html\">Custom Hooks</a> are largely the reason weâ€™re excited about the Hooks API. We expect people to build their own Hooks very often, and we need to make sure Hooks written by different people <a href=\"/why-do-hooks-rely-on-call-order/#flaw-4-the-diamond-problem\">don't conflict</a>. (Arenâ€™t we all spoiled by how components compose cleanly and donâ€™t break each other?)</p>\n</li>\n<li>\n<p><strong>Debugging:</strong> We want the bugs to be <a href=\"/the-bug-o-notation/\">easy to find</a> as the application grows. One of React's best features is that if you see something wrong rendered, you can walk up the tree until you find which component's prop or state caused the mistake.</p>\n</li>\n</ol>\n<p>These two constraints put together can tell us what can or <em>cannot</em> be a Hook. Letâ€™s try a few examples.</p>\n<hr>\n<h2>A Real Hook: <code>useState()</code></h2>\n<h3>Composition</h3>\n<p>Multiple custom Hooks each calling <code>useState()</code> donâ€™t conflict:</p>\n<pre   class=\"language-jsx\"><code class=\"language-jsx\">function useMyCustomHook1() {\n  const [value, setValue] = useState(0);\n  // What happens here, stays here.\n}\n\nfunction useMyCustomHook2() {\n  const [value, setValue] = useState(0);\n  // What happens here, stays here.\n}\n\nfunction MyComponent() {\n  useMyCustomHook1();\n  useMyCustomHook2();\n  // ...\n}\n</code></pre><p>Adding a new unconditional <code>useState()</code> call is always safe. You donâ€™t need to know anything about other Hooks used by a component to declare a new state variable. You also canâ€™t break other state variables by updating one of them.</p>\n<p><strong>Verdict:</strong> âœ… <code>useState()</code> doesnâ€™t make custom Hooks fragile.</p>\n<h3>Debugging</h3>\n<p>Hooks are useful because you can pass values <em>between</em> Hooks:</p>\n<pre data-line=\"4,12,14,\"  4,12,14=\"\" class=\"language-jsx\"><code 4,12,14=\"\" class=\"language-jsx\">function useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n  // ...\n  return width;\n}\n\nfunction useTheme(isMobile) {\n  // ...\n}\n\nfunction Comment() {\n  const width = useWindowWidth();\n  const isMobile = width &lt; MOBILE_VIEWPORT;\n  const theme = useTheme(isMobile);\n  return (\n    &lt;section className={theme.comment}&gt;\n      {/* ... */}\n    &lt;/section&gt;\n  );\n}\n</code></pre><p>But what if we make a mistake? Whatâ€™s the debugging story?</p>\n<p>Let's say the CSS class we get from <code>theme.comment</code> is wrong. How would we debug this? We can set a breakpoint or a few logs in the body of our component.</p>\n<p>Maybe weâ€™d see that <code>theme</code> is wrong but <code>width</code> and <code>isMobile</code> are correct. That would tell us the problem is inside <code>useTheme()</code>. Or perhaps we'd see that <code>width</code> itself is wrong. That would tell us to look into <code>useWindowWidth()</code>.</p>\n<p><strong>A single look at the intermediate values tells us which of the Hooks at the top level contains the bug.</strong> We don't need to look at <em>all</em> of their implementations.</p>\n<p>Then we can â€œzoom inâ€ on the one that has a bug, and repeat.</p>\n<p>This becomes more important if the depth of custom Hook nesting increases. Imagine we have 3 levels of custom Hook nesting, each level using 3 different custom Hooks inside. The <a href=\"/the-bug-o-notation/\">difference</a> between looking for a bug in <strong>3 places</strong> versus potentially checking <strong>3 + 3Ã—3 + 3Ã—3Ã—3 = 39 places</strong> is enormous. Luckily, <code>useState()</code> can't magically â€œinfluenceâ€ other Hooks or components. A buggy value returned by it leaves a trail behind it, just like any variable. ğŸ›</p>\n<p><strong>Verdict:</strong> âœ… <code>useState()</code> doesnâ€™t obscure the cause-effect relationship in our code. We can follow the breadcrumbs directly to the bug.</p>\n<hr>\n<h2>Not a Hook: <code>useBailout()</code></h2>\n<p>As an optimization, components using Hooks can bail out of re-rendering.</p>\n<p>One way to do it is to put a <a href=\"https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactmemo\"><code>React.memo()</code></a> wrapper around the whole component. It bails out of re-rendering if props are shallowly equal to what we had during the last render. This makes it similar to <code>PureComponent</code> in classes.</p>\n<p><code>React.memo()</code> takes a component and returns a component:</p>\n<pre data-line=\"4,\"  4=\"\" class=\"language-jsx\"><code 4=\"\" class=\"language-jsx\">function Button(props) {\n  // ...\n}\nexport default React.memo(Button);\n</code></pre><p><strong>But why isnâ€™t it just a Hook?</strong></p>\n<p>Whether you call it <code>useShouldComponentUpdate()</code>, <code>usePure()</code>, <code>useSkipRender()</code>, or <code>useBailout()</code>, the proposal tends to look something like this:</p>\n<pre   class=\"language-jsx\"><code class=\"language-jsx\">function Button({ color }) {\n  // âš ï¸ Not a real API\n  useBailout(prevColor =&gt; prevColor !== color, color);\n\n  return (\n    &lt;button className={'button-' + color}&gt;  \n      OK\n    &lt;/button&gt;\n  )\n}\n</code></pre><p>There are a few more variations (e.g. a simple <code>usePure()</code> marker) but in broad strokes they have the same flaws.</p>\n<h3>Composition</h3>\n<p>Letâ€™s say we try to put <code>useBailout()</code> in two custom Hooks:</p>\n<pre data-line=\"4,5,19,20,\"  4,5,19,20=\"\" class=\"language-jsx\"><code 4,5,19,20=\"\" class=\"language-jsx\">function useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  // âš ï¸ Not a real API\n  useBailout(prevIsOnline =&gt; prevIsOnline !== isOnline, isOnline);\n\n  useEffect(() =&gt; {\n    const handleStatusChange = status =&gt; setIsOnline(status.isOnline);\n    ChatAPI.subscribe(friendID, handleStatusChange);\n    return () =&gt; ChatAPI.unsubscribe(friendID, handleStatusChange);\n  });\n\n  return isOnline;\n}\n\nfunction useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n  \n  // âš ï¸ Not a real API\n  useBailout(prevWidth =&gt; prevWidth !== width, width);\n\n  useEffect(() =&gt; {\n    const handleResize = () =&gt; setWidth(window.innerWidth);\n    window.addEventListener('resize', handleResize);\n    return () =&gt; window.removeEventListener('resize', handleResize);\n  });\n\n  return width;\n}\n</code></pre><p>Now what happens if you use them both in the same component?</p>\n<pre data-line=\"2,3,\"  2,3=\"\" class=\"language-jsx\"><code 2,3=\"\" class=\"language-jsx\">function ChatThread({ friendID, isTyping }) {\n  const width = useWindowWidth();\n  const isOnline = useFriendStatus(friendID);\n  return (\n    &lt;ChatLayout width={width}&gt;\n      &lt;FriendStatus isOnline={isOnline} /&gt;\n      {isTyping &amp;&amp; 'Typing...'}\n    &lt;/ChatLayout&gt;\n  );\n}\n</code></pre><p>When does it re-render?</p>\n<p>If every <code>useBailout()</code> call has the power to skip an update, then updates from <code>useWindowWidth()</code> would be blocked by <code>useFriendStatus()</code>, and vice versa. <strong>These Hooks would break each other.</strong></p>\n<p>However, if <code>useBailout()</code> was only respected when <em>all</em> calls to it inside a single component â€œagreeâ€ to block an update, our <code>ChatThread</code> would fail to update on changes to the <code>isTyping</code> prop.</p>\n<p>Even worse, with these semantics <strong>any newly added Hooks to <code>ChatThread</code> would break if they donâ€™t <em>also</em> call <code>useBailout()</code></strong>. Otherwise, they canâ€™t â€œvote againstâ€ the bailout inside <code>useWindowWidth()</code> and <code>useFriendStatus()</code>.</p>\n<p><strong>Verdict:</strong> ğŸ”´ <code>useBailout()</code> breaks composition. Adding it to a Hook breaks state updates in other Hooks. We want the APIs to be <a href=\"/optimized-for-change/\">antifragile</a>, and this behavior is pretty much the opposite.</p>\n<h3>Debugging</h3>\n<p>How does a Hook like <code>useBailout()</code> affect debugging?</p>\n<p>Weâ€™ll use the same example:</p>\n<pre   class=\"language-jsx\"><code class=\"language-jsx\">function ChatThread({ friendID, isTyping }) {\n  const width = useWindowWidth();\n  const isOnline = useFriendStatus(friendID);\n  return (\n    &lt;ChatLayout width={width}&gt;\n      &lt;FriendStatus isOnline={isOnline} /&gt;\n      {isTyping &amp;&amp; 'Typing...'}\n    &lt;/ChatLayout&gt;\n  );\n}\n</code></pre><p>Letâ€™s say the <code>Typing...</code> label doesnâ€™t appear when we expect, even though somewhere many layers above the prop is changing. How do we debug it?</p>\n<p><strong>Normally, in React you can confidently answer this question by looking <em>up</em>.</strong> If <code>ChatThread</code> doesnâ€™t get a new <code>isTyping</code> value, we can open the component that renders <code>&lt;ChatThread isTyping={myVar} /&gt;</code> and check <code>myVar</code>, and so on. At one of these levels, weâ€™ll either find a buggy <code>shouldComponentUpdate()</code> bailout, or an incorrect <code>isTyping</code> value being passed down. One look at each component in the chain is usually enough to locate the source of the problem.</p>\n<p>However, if this <code>useBailout()</code> Hook was real, you would never know the reason an update was skipped until you checked <em>every single custom Hook</em> (deeply) used by our <code>ChatThread</code> and components in its owner chain. Since every parent component can <em>also</em> use custom Hooks, this <a href=\"/the-bug-o-notation/\">scales</a> terribly.</p>\n<p>Itâ€™s like if you were looking for a screwdriver in a chest of drawers, and each drawer contained a bunch of smaller chests of drawers, and you donâ€™t know how deep the rabbit hole goes.</p>\n<p><strong>Verdict:</strong> ğŸ”´ Not only <code>useBailout()</code> Hook breaks composition, but it also vastly increases the number of debugging steps and cognitive load for finding a buggy bailout â€” in some cases, exponentially.</p>\n<hr>\n<p>We just looked at one real Hook, <code>useState()</code>, and a common suggestion that is intentionally <em>not</em> a Hook â€” <code>useBailout()</code>. We compared them through the prism of Composition and Debugging, and discussed why one of them works and the other one doesnâ€™t.</p>\n<p>While there is no â€œHook versionâ€ of <code>memo()</code> or <code>shouldComponentUpdate()</code>, React <em>does</em> provide a Hook called <a href=\"https://reactjs.org/docs/hooks-reference.html#usememo\"><code>useMemo()</code></a>. It serves a similar purpose, but its semantics are different enough to not run into the pitfalls described above.</p>\n<p><code>useBailout()</code> is just one example of something that doesnâ€™t work well as a Hook. But there are a few others â€” for example, <code>useProvider()</code>, <code>useCatch()</code>, or <code>useSuspense()</code>.</p>\n<p>Can you see why?</p>\n<p><em>(Whispers: Composition... Debugging...)</em></p>\n","frontmatter":"title: Why Isnâ€™t X a Hook?\ndate: '2019-01-26'\nspoiler: Just because we can, doesnâ€™t mean we should.","link":"/post/why-isnt-x-a-hook","next":{"title":"ç¼–å†™æœ‰å¼¹æ€§çš„ç»„ä»¶","date":"2019-03-16","spoiler":"æŒ‡å‘æ­£ç¡®é“è·¯çš„å››é¡¹åŸºæœ¬åŸåˆ™.","link":"/post/writing-resilient-components-zh","min2read":"â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸ 26 min read","wordcount":"7k"},"prev":{"title":"ä¸ºä»€ä¹ˆ 'XX' ä¸æ˜¯ä¸€ä¸ª Hooks API?","date":"2019-01-26","spoiler":"æˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼Œä½†å¹¶ä¸æ˜¯æ„å‘³ç€æˆ‘ä»¬åº”è¯¥è¿™æ ·åšã€‚","link":"/post/why-isnt-x-a-hook-zh","min2read":"â˜•ï¸â˜•ï¸ 8 min read","wordcount":"2.2k"}}}