window.__NUXT__=function(e,o,s,n){return{layout:"default",data:[{post:{attributes:{title:"为什么我们要写 super(props) ？",date:e,spoiler:"结尾处有彩蛋。",featured:!0,link:s,min2read:n,wordcount:"1.4k"},body:'<p>据说 <a href="https://reactjs.org/docs/hooks-intro.html">Hooks</a> 势头正盛，不过我还是想略带调侃地从 <em>class</em> 的有趣之处开始这篇博客。可还行？</p>\n<p><strong>这些梗对于使用 React 输出产品并<em>不</em>重要，但如果你想深入的了解它们的运作原理，它们会非常的有用。</strong></p>\n<hr>\n<p>首先，在这一生中，<code>super(props)</code> 出现在我代码里的次数比我知道的还要多：</p>\n<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">class Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  // ...\n}\n</code></pre><p>当然了，我们可以通过 <a href="https://github.com/tc39/proposal-class-fields">class fields proposal</a> 来省略这个声明：</p>\n<pre   class="language-jsx"><code class="language-jsx">class Checkbox extends React.Component {\n  state = { isOn: true };\n  // ...\n}\n</code></pre><p>早在 2015 年 React 0.13 已经<a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers">计划支持</a> 。在当时，声明 <code>constructor</code> 和调用 <code>super(props)</code> 一直被视作暂时的解决方案，直到有合适的类字段声明形式。</p>\n<p>但在此之前，我们先回到 ES2015 风格的代码：</p>\n<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">class Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  // ...\n}\n</code></pre><p>**为什么我们要调用 <code>super</code>，我们可以不这么做吗？那么在我们调用它时不传入 <code>props</code>，又会发生什么呢？会有其他的缺省参数吗？**接来下我们就解开这一系列谜题。</p>\n<hr>\n<p>在 JavaScript 中，<code>super</code> 指的是父类（即超类）的构造函数。（在我们的例子中，它指向了 <code>React.Component</code> 的实现。）</p>\n<p>值得注意的是，在调用父类的构造函数之前，你是不能在 constructor 中使用 <code>this</code> 关键字的。JavaScript 不允许这个行为。</p>\n<pre   class="language-jsx"><code class="language-jsx">class Checkbox extends React.Component {\n  constructor(props) {\n    // 🔴  还不能使用 `this`\n    super(props);\n    // ✅  现在可以了\n    this.state = { isOn: true };\n  }\n  // ...\n}\n</code></pre><p>JavaScript 有足够合理的动机来强制你在接触 <code>this</code> 之前执行父类构造函数。考虑考虑一些类层次结构的东西：</p>\n<pre   class="language-jsx"><code class="language-jsx">class Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass PolitePerson extends Person {\n  constructor(name) {\n    this.greetColleagues(); // 🔴  这是禁止的，往后见原因\n    super(name);\n  }\n  greetColleagues() {\n    alert(\'Good morning folks!\');\n  }\n}\n</code></pre><p>试想一下，在调用 <code>super</code> 之前使用 <code>this</code> 不被禁止的情况下，一个月后，我们可能在 <code>greetColleagues</code> 打印的消息中使用了 person 的 name 属性：</p>\n<pre   class="language-jsx"><code class="language-jsx">  greetColleagues() {\n    alert(\'Good morning folks!\');\n    alert(\'My name is \' + this.name + \', nice to meet you!\');\n  }\n</code></pre><p>但是我们并未想起 <code>this.greetColleagues</code> 在 <code>super()</code> 给 <code>this.name</code> 赋值前就已经执行。<code>this.name</code> 此时甚至尚未定义。可以看到，这样的代码难以往下推敲。</p>\n<p>为了避免落入这个陷阱，**JavaScript 强制你在使用 <code>this</code> 之前先行调用 <code>super</code>。**让父类来完成这件事情！：</p>\n<pre   class="language-jsx"><code class="language-jsx">  constructor(props) {\n    super(props);\n    // ✅ 能使用 `this` 了\n    this.state = { isOn: true };\n  }\n</code></pre><p>这里留下了另一个问题：为什么要传入 <code>props</code> ？</p>\n<hr>\n<p>你或许会想到，为了让 React.Component 构造函数能够初始化 <code>this.props</code>，将 <code>props</code> 传入 <code>super</code> 是必须的：</p>\n<pre   class="language-jsx"><code class="language-jsx">// React 內部\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n</code></pre><p>这几乎就是真相了 — 确然，它是 <a href="https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22">这样做</a> 的。</p>\n<p>但有些扑朔迷离的是，即便你调用 <code>super()</code> 的时候没有传入 <code>props</code>，你依然能够在 <code>render</code> 函数或其他方法中访问到 <code>this.props</code>。（如果你质疑这个机制，尝试一下即可）</p>\n<p>那么这是怎么做到的呢？事实证明，React 在调用构造函数后也立即将 <code>props</code> 赋值到了实例上：**</p>\n<pre   class="language-jsx"><code class="language-jsx">  // React 内部\n  const instance = new YourComponent(props);\n  instance.props = props;\n</code></pre><p>因此即便你忘记了将 <code>props</code> 传给 <code>super()</code>，React 也仍然会在之后将它定义到实例上。这么做是有原因的。</p>\n<p>当 React 增加了对类的支持时，不仅仅是为了服务于 ES6。其目标是尽可能广泛地支持类抽象。当时我们 <a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages">不清楚</a>  ClojureScript，CoffeeScript，ES6，Fable，Scala.js，TypeScript 等解決方案是如何成功的实践组件定义的。因而 React 刻意地没有显式要求调用 <code>super()</code> —— 即便 ES6 自身就包含这个机制。</p>\n<p>这意味着你能够用 <code>super()</code> 代替 <code>super(props)</code> 吗？</p>\n<p><strong>最好不要，毕竟这样写在逻辑上并不明确</strong>确然，React 会在构造函数执行完毕<em>之后</em>给 <code>this.props</code> 赋值。但如此为之会使得 <code>this.props</code> 在 <code>super</code> 调用<em>一直到构造函数结束期间</em>值为 undefined。</p>\n<pre data-line="14,"  14="" class="language-jsx"><code 14="" class="language-jsx">// React 內部\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n\n// 你的程式碼內部\nclass Button extends React.Component {\n  constructor(props) {\n    super(); // 😬 我们忘了传入 props\n    console.log(props);      // ✅ {}\n    console.log(this.props); // 😬 未定义\n  }\n  // ...\n}\n</code></pre><p>如果在构造函数中调用了其他的内部方法，那么一旦出错这会使得调试过程阻力更大。<strong>这就是我建议开发者一定执行 <code>super(props)</code> 的原因，即使理论上这并非必要：</strong></p>\n<pre   class="language-jsx"><code class="language-jsx">class Button extends React.Component {\n  constructor(props) {\n    super(props); // ✅ 传入 props\n    console.log(props);      // ✅ {}\n    console.log(this.props); // ✅ {}\n  }\n  // ...\n}\n</code></pre><p>确保了 <code>this.props</code> 在构造函数执行完毕之前已被赋值。</p>\n<hr>\n<p>最后，还有一点是 React 爱好者长期以来的好奇之处。</p>\n<p>你会发现当你在类中使用 Context API （无论是旧版的 <code>contextTypes</code> 或是在 React 16.6 更新的新版 <code>contextTypes</code>）的时候，<code>context</code> 是作为第二个参数传入构造函数的。</p>\n<p>那么为什么我们不能转而写成 <code>super(props, context)</code> 呢？我们当然可以，但 context 的使用频率较低，因而并没有掘这个坑。</p>\n<p><strong>class fields proposal 出台后，这些坑大部分都会自然地消失</strong>在没有显示的定义构造函数的情况下，以上的属性都会被自动地初始化。这使得像 <code>state = {}</code> 这类表达式能够在需要的情况下引用 <code>this.props</code> 和 <code>this.context</code> 的内容。</p>\n<p>然而，有了 Hooks 以后，我们几乎就不需要 <code>super</code> 和 <code>this</code> 了。但那就是另一个下午的茶点了。</p>\n',frontmatter:"title: 为什么我们要写 super(props) ？\ndate: '2018-11-30'\nspoiler: 结尾处有彩蛋。\nfeatured: true",link:s,next:{title:"Why Do We Write super(props)?",date:e,spoiler:"There’s a twist at the end.",link:"/post/why-do-we-write-super-props",min2read:n,wordcount:938},prev:{title:"Why Do React Elements Have a $$typeof Property?",date:"2018-12-03",spoiler:"It has something to do with security.",link:"/post/why-do-react-elements-have-typeof-property",min2read:"☕️ 6 min read",wordcount:"1k"}}}],error:null,serverRendered:!0}}("2018-11-30",0,"/post/why-do-we-write-super-props-zh","☕️ 5 min read")