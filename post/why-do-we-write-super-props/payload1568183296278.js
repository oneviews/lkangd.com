window.__NUXT__=function(e,o,s){return{layout:"default",data:[{post:{attributes:{title:"Why Do We Write super(props)?",date:e,spoiler:"There’s a twist at the end.",link:o,min2read:s,wordcount:938},body:'<p>I heard <a href="https://reactjs.org/docs/hooks-intro.html">Hooks</a> are the new hotness. Ironically, I want to start this blog by describing fun facts about <em>class</em> components. How about that!</p>\n<p><strong>These gotchas are <em>not</em> important for using React productively. But you might find them amusing if you like to dig deeper into how things work.</strong></p>\n<p>Here’s the first one.</p>\n<hr>\n<p>I wrote <code>super(props)</code> more times in my life than I’d like to know:</p>\n<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">class Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  // ...\n}\n</code></pre><p>Of course, the <a href="https://github.com/tc39/proposal-class-fields">class fields proposal</a> lets us skip the ceremony:</p>\n<pre data-line="1,2,3,"  1,2,3="" class="language-jsx"><code 1,2,3="" class="language-jsx">class Checkbox extends React.Component {\n  state = { isOn: true };\n  // ...\n}\n</code></pre><p>A syntax like this was <a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers">planned</a> when React 0.13 added support for plain classes in 2015. Defining <code>constructor</code> and calling <code>super(props)</code> was always intended to be a temporary solution until class fields provide an ergonomic alternative.</p>\n<p>But let’s get back to this example using only ES2015 features:</p>\n<pre data-line="3,"  3="" class="language-jsx"><code 3="" class="language-jsx">class Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  // ...\n}\n</code></pre><p><strong>Why do we call <code>super</code>? Can we <em>not</em> call it? If we have to call it, what happens if we don’t pass <code>props</code>? Are there any other arguments?</strong> Let’s find out.</p>\n<hr>\n<p>In JavaScript, <code>super</code> refers to the parent class constructor. (In our example, it points to the <code>React.Component</code> implementation.)</p>\n<p>Importantly, you can’t use <code>this</code> in a constructor until <em>after</em> you’ve called the parent constructor. JavaScript won’t let you:</p>\n<pre   class="language-jsx"><code class="language-jsx">class Checkbox extends React.Component {\n  constructor(props) {\n    // 🔴 Can’t use `this` yet\n    super(props);\n    // ✅ Now it’s okay though\n    this.state = { isOn: true };\n  }\n  // ...\n}\n</code></pre><p>There’s a good reason for why JavaScript enforces that parent constructor runs before you touch <code>this</code>. Consider a class hierarchy:</p>\n<pre   class="language-jsx"><code class="language-jsx">class Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass PolitePerson extends Person {\n  constructor(name) {\n    this.greetColleagues(); // 🔴 This is disallowed, read below why\n    super(name);\n  }\n  greetColleagues() {\n    alert(\'Good morning folks!\');\n  }\n}\n</code></pre><p>Imagine using <code>this</code> before <code>super</code> call <em>was</em> allowed. A month later, we might change <code>greetColleagues</code> to include the person’s name in the message:</p>\n<pre   class="language-jsx"><code class="language-jsx">  greetColleagues() {\n    alert(\'Good morning folks!\');\n    alert(\'My name is \' + this.name + \', nice to meet you!\');\n  }\n</code></pre><p>But we forgot that <code>this.greetColleagues()</code> is called before the <code>super()</code> call had a chance to set up <code>this.name</code>. So <code>this.name</code> isn’t even defined yet! As you can see, code like this can be very difficult to think about.</p>\n<p>To avoid such pitfalls, <strong>JavaScript enforces that if you want to use <code>this</code> in a constructor, you <em>have to</em> call <code>super</code> first.</strong> Let the parent do its thing! And this limitation applies to React components defined as classes too:</p>\n<pre   class="language-jsx"><code class="language-jsx">  constructor(props) {\n    super(props);\n    // ✅ Okay to use `this` now\n    this.state = { isOn: true };\n  }\n</code></pre><p>This leaves us with another question: why pass <code>props</code>?</p>\n<hr>\n<p>You might think that passing <code>props</code> down to <code>super</code> is necessary so that the base <code>React.Component</code> constructor can initialize <code>this.props</code>:</p>\n<pre   class="language-jsx"><code class="language-jsx">// Inside React\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n</code></pre><p>And that’s not far from truth — indeed, that’s <a href="https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22">what it does</a>.</p>\n<p>But somehow, even if you call <code>super()</code> without the <code>props</code> argument, you’ll still be able to access <code>this.props</code> in the <code>render</code> and other methods. (If you don’t believe me, try it yourself!)</p>\n<p>How does <em>that</em> work? It turns out that <strong>React also assigns <code>props</code> on the instance right after calling <em>your</em> constructor:</strong></p>\n<pre   class="language-jsx"><code class="language-jsx">  // Inside React\n  const instance = new YourComponent(props);\n  instance.props = props;\n</code></pre><p>So even if you forget to pass <code>props</code> to <code>super()</code>, React would still set them right afterwards. There is a reason for that.</p>\n<p>When React added support for classes, it didn’t just add support for ES6 classes alone. The goal was to support as wide range of class abstractions as possible. It was <a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages">not clear</a> how relatively successful would ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript, or other solutions be for defining components. So React was intentionally unopinionated about whether calling <code>super()</code> is required — even though ES6 classes are.</p>\n<p>So does this mean you can just write <code>super()</code> instead of <code>super(props)</code>?</p>\n<p><strong>Probably not because it’s still confusing.</strong> Sure, React would later assign <code>this.props</code> <em>after</em> your constructor has run. But <code>this.props</code> would still be undefined <em>between</em> the <code>super</code> call and the end of your constructor:</p>\n<pre data-line="14,"  14="" class="language-jsx"><code 14="" class="language-jsx">// Inside React\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n\n// Inside your code\nclass Button extends React.Component {\n  constructor(props) {\n    super(); // 😬 We forgot to pass props\n    console.log(props);      // ✅ {}\n    console.log(this.props); // 😬 undefined \n  }\n  // ...\n}\n</code></pre><p>It can be even more challenging to debug if this happens in some method that’s called <em>from</em> the constructor. <strong>And that’s why I recommend always passing down <code>super(props)</code>, even though it isn’t strictly necessary:</strong></p>\n<pre   class="language-jsx"><code class="language-jsx">class Button extends React.Component {\n  constructor(props) {\n    super(props); // ✅ We passed props\n    console.log(props);      // ✅ {}\n    console.log(this.props); // ✅ {}\n  }\n  // ...\n}\n</code></pre><p>This ensures <code>this.props</code> is set even before the constructor exits.</p>\n<hr>\n<p>There’s one last bit that longtime React users might be curious about.</p>\n<p>You might have noticed that when you use the Context API in classes (either with the legacy <code>contextTypes</code> or the modern <code>contextType</code> API added in React 16.6), <code>context</code> is passed as a second argument to the constructor.</p>\n<p>So why don’t we write <code>super(props, context)</code> instead? We could, but context is used less often so this pitfall just doesn’t come up as much.</p>\n<p><strong>With the class fields proposal this whole pitfall mostly disappears anyway.</strong> Without an explicit constructor, all arguments are passed down automatically. This is what allows an expression like <code>state = {}</code> to include references to <code>this.props</code> or <code>this.context</code> if necessary.</p>\n<p>With Hooks, we don’t even have <code>super</code> or <code>this</code>. But that’s a topic for another day.</p>\n',frontmatter:"title: Why Do We Write super(props)?\ndate: '2018-11-30'\nspoiler: There’s a twist at the end.",link:o,next:{title:"为什么 'XX' 不是一个 Hooks API?",date:"2019-01-26",spoiler:"我们可以这样做，但并不是意味着我们应该这样做。",link:"/post/why-isnt-x-a-hook-zh",min2read:"☕️☕️ 8 min read",wordcount:"2.2k"},prev:{title:"为什么我们要写 super(props) ？",date:e,spoiler:"结尾处有彩蛋。",featured:!0,link:"/post/why-do-we-write-super-props-zh",min2read:s,wordcount:"1.4k"}}}],error:null,serverRendered:!0}}("2018-11-30","/post/why-do-we-write-super-props","☕️ 5 min read")