window.__NUXT__=function(e,t,o,a){return{layout:"default",data:[{post:{attributes:{title:"Why Do React Elements Have a $$typeof Property?",date:t,spoiler:"It has something to do with security.",link:o,min2read:"â˜•ï¸ 6 min read",wordcount:"1k"},body:'<p>You might think youâ€™re writing JSX:</p>\n<pre   class="language-jsx"><code class="language-jsx">&lt;marquee bgcolor=&quot;#ffa7c4&quot;&gt;hi&lt;/marquee&gt;\n</code></pre><p>But really, youâ€™re calling a function:</p>\n<pre   class="language-jsx"><code class="language-jsx">React.createElement(\n  /* type */ \'marquee\',\n  /* props */ { bgcolor: \'#ffa7c4\' },\n  /* children */ \'hi\'\n)\n</code></pre><p>And that function gives you back an object. We call this object a React <em>element</em>. It tells React what to render next. Your components return a tree of them.</p>\n<pre data-line="9,"  9="" class="language-jsx"><code 9="" class="language-jsx">{\n  type: \'marquee\',\n  props: {\n    bgcolor: \'#ffa7c4\',\n    children: \'hi\',\n  },\n  key: null,\n  ref: null,\n  $$typeof: Symbol.for(\'react.element\'), // ğŸ§ Who dis\n}\n</code></pre><p>If you used React you might be familiar with <code>type</code>, <code>props</code>, <code>key</code>, and <code>ref</code> fields. <strong>But what is <code>$$typeof</code>? And why does it have a <code>Symbol()</code> as a value?</strong></p>\n<p>Thatâ€™s another one of those things that you donâ€™t <em>need</em> to know to use React, but that will make you feel good when you do. Thereâ€™s also some tips about security in this post that you might want to know. Maybe one day youâ€™ll write your own UI library and all of this will come in handy. I certainly hope so.</p>\n<hr>\n<p>Before client-side UI libraries became common and added basic protection, it was common for app code to construct HTML and insert it into the DOM:</p>\n<pre   class="language-jsx"><code class="language-jsx">const messageEl = document.getElementById(\'message\');\nmessageEl.innerHTML = \'&lt;p&gt;\' + message.text + \'&lt;/p&gt;\';\n</code></pre><p>That works fine, except when your <code>message.text</code> is something like <code>\'&lt;img src onerror=&quot;stealYourPassword()&quot;&gt;\'</code>. <strong>You donâ€™t want things written by strangers to appear verbatim in your appâ€™s rendered HTML.</strong></p>\n<p>(Fun fact: if you only do client-side rendering, a <code>&lt;script&gt;</code> tag here wouldnâ€™t let you run JavaScript. But <a href="https://gomakethings.com/preventing-cross-site-scripting-attacks-when-using-innerhtml-in-vanilla-javascript/">donâ€™t let this</a> lull you into a false sense of security.)</p>\n<p>To protect against such attacks, you can use safe APIs like <code>document.createTextNode()</code> or <code>textContent</code> that only deal with text. You can also preemptively â€œescapeâ€ inputs by replacing potentially dangerous characters like <code>&lt;</code>, <code>&gt;</code> and others in any user-provided text.</p>\n<p>Still, the cost of a mistake is high and itâ€™s a hassle to remember it every time you interpolate a user-written string into your output. <strong>This is why modern libraries like React escape text content for strings by default:</strong></p>\n<pre   class="language-jsx"><code class="language-jsx">&lt;p&gt;\n  {message.text}\n&lt;/p&gt;\n</code></pre><p>If <code>message.text</code> is a malicious string with an <code>&lt;img&gt;</code> or another tag, it wonâ€™t turn into a real <code>&lt;img&gt;</code> tag. React will escape the content and <em>then</em> insert it into the DOM. So instead of seeing the <code>&lt;img&gt;</code> tag youâ€™ll just see its markup.</p>\n<p>To render arbitrary HTML inside a React element, you have to write <code>dangerouslySetInnerHTML={{ __html: message.text }}</code>. <strong>The fact that itâ€™s clumsy to write is a <em>feature</em>.</strong> Itâ€™s meant to be highly visible so that you can catch it in code reviews and codebase audits.</p>\n<hr>\n<p><strong>Does it mean React is entirely safe from injection attacks? No.</strong> HTML and DOM offer <a href="https://github.com/facebook/react/issues/3473#issuecomment-90594748">plenty of attack surface</a> that is too difficult or slow for React or other UI libraries to mitigate against. Most of the remaining attack vectors involve attributes. For example, if you render <code>&lt;a href={user.website}&gt;</code>, beware of the user whose website is <code>\'javascript: stealYourPassword()\'</code>. Spreading user input like <code>&lt;div {...userData}&gt;</code> is rare but also dangerous.</p>\n<p>React <a href="https://github.com/facebook/react/issues/10506">could</a> provide more protection over time but in many cases these are consequences of server issues that <a href="https://github.com/facebook/react/issues/3473#issuecomment-91327040">should</a> be fixed there anyway.</p>\n<p>Still, escaping text content is a reasonable first line of defence that catches a lot of potential attacks. Isnâ€™t it nice to know that code like this is safe?</p>\n<pre   class="language-jsx"><code class="language-jsx">// Escaped automatically\n&lt;p&gt;\n  {message.text}\n&lt;/p&gt;\n</code></pre><p><strong>Well, that wasnâ€™t always true either.</strong> And thatâ€™s where <code>$$typeof</code> comes in.</p>\n<hr>\n<p>React elements are plain objects by design:</p>\n<pre   class="language-jsx"><code class="language-jsx">{\n  type: \'marquee\',\n  props: {\n    bgcolor: \'#ffa7c4\',\n    children: \'hi\',\n  },\n  key: null,\n  ref: null,\n  $$typeof: Symbol.for(\'react.element\'),\n}\n</code></pre><p>While normally you create them with <code>React.createElement()</code>, it is not required. There are valid use cases for React to support plain element objects written like I just did above. Of course, you probably wouldnâ€™t <em>want</em> to write them like this â€” but this <a href="https://github.com/facebook/react/pull/3583#issuecomment-90296667">can be</a> useful for an optimizing compiler, passing UI elements between workers, or for decoupling JSX from the React package.</p>\n<p>However, <strong>if your server has a hole that lets the user store an arbitrary JSON object</strong> while the client code expects a string, this could become a problem:</p>\n<pre data-line="2-10,15,"  2-10,15="" class="language-jsx"><code 2-10,15="" class="language-jsx">// Server could have a hole that lets user store JSON\nlet expectedTextButGotJSON = {\n  type: \'div\',\n  props: {\n    dangerouslySetInnerHTML: {\n      __html: \'/* put your exploit here */\'\n    },\n  },\n  // ...\n};\nlet message = { text: expectedTextButGotJSON };\n\n// Dangerous in React 0.13\n&lt;p&gt;\n  {message.text}\n&lt;/p&gt;\n</code></pre><p>In that case, React 0.13 would be <a href="http://danlec.com/blog/xss-via-a-spoofed-react-element">vulnerable</a> to an XSS attack. To clarify, again, <strong>this attack depends on an existing server hole</strong>. Still, React could do a better job of protecting people against it. And starting with React 0.14, it does.</p>\n<p>The fix in React 0.14 was to <a href="https://github.com/facebook/react/pull/4832">tag every React element with a Symbol</a>:</p>\n<pre data-line="9,"  9="" class="language-jsx"><code 9="" class="language-jsx">{\n  type: \'marquee\',\n  props: {\n    bgcolor: \'#ffa7c4\',\n    children: \'hi\',\n  },\n  key: null,\n  ref: null,\n  $$typeof: Symbol.for(\'react.element\'),\n}\n</code></pre><p>This works because you canâ€™t just put <code>Symbol</code>s in JSON. <strong>So even if the server has a security hole and returns JSON instead of text, that JSON canâ€™t include <code>Symbol.for(\'react.element\')</code>.</strong> React will check <code>element.$$typeof</code>, and will refuse to process the element if itâ€™s missing or invalid.</p>\n<p>The nice thing about using <code>Symbol.for()</code> specifically is that <strong>Symbols are global between environments like iframes and workers.</strong> So this fix doesnâ€™t prevent passing trusted elements between different parts of the app even in more exotic conditions. Similarly, even if there are multiple copies of React on the page, they can still â€œagreeâ€ on the valid <code>$$typeof</code> value.</p>\n<hr>\n<p>What about the browsers that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility">donâ€™t support</a> Symbols?</p>\n<p>Alas, they donâ€™t get this extra protection. React still includes the <code>$$typeof</code> field on the element for consistency, but itâ€™s <a href="https://github.com/facebook/react/blob/8482cbe22d1a421b73db602e1f470c632b09f693/packages/shared/ReactSymbols.js#L14-L16">set to a number</a> â€” <code>0xeac7</code>.</p>\n<p>Why this number specifically? <code>0xeac7</code> kinda looks like â€œReactâ€.</p>\n',frontmatter:"title: Why Do React Elements Have a $$typeof Property?\ndate: '2018-12-03'\nspoiler: It has something to do with security.",link:o,next:{title:"ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦å†™ super(props) ï¼Ÿ",date:"2018-11-30",spoiler:"ç»“å°¾å¤„æœ‰å½©è›‹ã€‚",featured:!0,link:"/post/why-do-we-write-super-props-zh",min2read:a,wordcount:"1.4k"},prev:{title:"ä¸ºä»€ä¹ˆReactå…ƒç´ æœ‰ä¸€ä¸ª$$typeofå±æ€§ï¼Ÿ",date:t,spoiler:"æœ‰äº›éƒ¨åˆ†æ˜¯å…³äºå®‰å…¨çš„ã€‚",featured:!0,link:"/post/why-do-react-elements-have-typeof-property-zh",min2read:a,wordcount:"1.3k"}}}],error:null,serverRendered:!0}}(0,"2018-12-03","/post/why-do-react-elements-have-typeof-property","â˜•ï¸ 5 min read")